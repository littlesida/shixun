{"version":3,"sources":["webpack:///static/js/2.cdf123478cd95191923c.js","webpack:///Data.vue","webpack:///./src/components/Data.vue?69d3","webpack:///./src/components/Data.vue?98b4","webpack:///./src/components/Data.vue?ddab","webpack:///./src/components/Data.vue","webpack:///./src/echarts.js"],"names":["webpackJsonp","15","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_echarts","_echarts2","data","typeMap","radio","checkbox","textarea","vuex","getters","questionnaire","state","currentQuestionnaire","questionnaireList","actions","setCurrentQuest","_ref","item","dispatch","route","_ref2","_this","this","to","next","id","params","questId","forEach","parseInt","directives","echarts","bind","self","vm","$nextTick","instance","init","el","update","newVal","oldVal","seriesData","option","type","selections","push","Math","random","grid","top","bottom","title","text","textAlign","yAxis","xAxis","series","radius","name","setOption","unbind","dispose","23","version","sources","names","mappings","file","sourcesContent","sourceRoot","27","content","locals","34","41","__vue_script__","__vue_template__","__vue_styles__","__vue_options__","options","template","computed","keys","key","47","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","root","factory","apply","undefined","require","define","normalize","baseId","indexOf","basePath","split","namePath","baseLen","length","nameLen","cutBaseTerms","cutNameTerms","pathLoop","i","slice","concat","join","createRequire","localRequire","callback","cacheMods","getModExports","Array","getModsExports","ids","es","mod","mods","l","min","arg","Error","defined","factoryReturn","deps","zrUtil","event","method","registerVisual","curry","registerLayout","registerProcessor","barLayoutGrid","ecModel","eachSeriesByType","seriesModel","getData","setVisual","graphic","layout","extendComponentModel","layoutMode","ignoreSize","defaultOption","zlevel","z","show","target","subtext","subtarget","left","backgroundColor","borderColor","borderWidth","padding","itemGap","textStyle","fontSize","fontWeight","color","subtextStyle","extendComponentView","render","titleModel","api","group","removeAll","get","textStyleModel","getModel","subtextStyleModel","textBaseline","textEl","Text","style","textFont","getFont","fill","getTextColor","z2","textRect","getBoundingRect","subText","subTextEl","y","height","link","sublink","silent","on","window","open","add","groupRect","layoutOption","getBoxLayoutParams","width","layoutRect","getLayoutRect","getWidth","getHeight","x","attr","alignStyle","textVerticalAlign","setStyle","margin","getItemStyle","rect","Rect","shape","subPixelOptimizeRect","gridModel","coordinateSystem","getRect","defaults","registerPreprocessor","numberUtil","formatUtil","IntervalScale","intervalScaleProto","prototype","mathCeil","ceil","mathFloor","floor","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_DAY","bisect","a","lo","hi","mid","TimeScale","extend","getLabel","val","stepLvl","_stepLvl","date","Date","formatTime","niceExtent","approxTickNum","fixMin","fixMax","extent","_extent","Infinity","d","getFullYear","getMonth","getDate","niceTicks","interval","_interval","round","span","approxInterval","scaleLevelsLen","scaleLevels","idx","level","yearSpan","yearStep","nice","_niceExtent","parse","parseDate","each","methodName","call","create","createRegisterEventWithLowercaseName","eventName","handler","context","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","b","prio","themeStorage","_dom","_zr","zrender","renderer","devicePixelRatio","_theme","clone","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_api","ExtensionAPI","_coordSysMgr","CoordinateSystemManager","_messageCenter","_initEvents","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","_onframe","toggleHighlight","payload","_model","eachComponent","mainType","query","index","chartView","__viewId","__alive","invokeUpdateMethod","component","componentModel","__model","updateZ","eachSeries","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","zr","componentType","model","viewId","view","classType","ComponentModel","parseClassType","Clazz","ComponentView","getClass","main","sub","ChartView","__id","remove","splice","processData","process","func","stackSeriesData","stackedDataMap","stack","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","clearColorPalette","doRender","componentView","storage","elCount","traverse","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","stopAnimation","blendMode","canvasSupported","console","warn","enableConnect","updateConnectedChartsStatus","charts","status","otherChart","STATUS_KEY","STATUS_PENDING","STATUS_UPDATING","STATUS_UPDATED","eventActionMap","actionType","eventType","connectedGroups","action","makeActionFromEvent","otherCharts","instances","dispatchAction","GlobalModel","OptionManager","SeriesModel","colorTool","PRIORITY_PROCESSOR_FILTER","PRIORITY_PROCESSOR_STATISTIC","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_GLOBAL","PRIORITY_VISUAL_CHART","PRIORITY_VISUAL_COMPONENT","PRIORITY_VISUAL_BRUSH","IN_MAIN_PROCESS","HAS_GRADIENT_OR_PATTERN_BG","OPTION_UPDATED","off","one","mixin","echartsProto","updateMethods","prepareAndUpdate","getDom","getZr","notMerge","lazyUpdate","assert","optionManager","optionPreprocessorFuncs","refreshImmediately","_flushPendingActions","setTheme","log","getOption","getRenderedCanvas","pixelRatio","list","getDisplayList","painter","getDataURL","excludeComponents","excludesComponentViews","url","toDataURL","getConnectedDataURL","groupId","mathMin","mathMax","max","MAX_NUMBER","right","canvasList","dpr","canvas","boundingRect","getBoundingClientRect","targetCanvas","createCanvas","img","Image","image","coordSysMgr","restoreData","isSingleCanvas","configLayer","clearColor","colorArr","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","highlight","downplay","optionChanged","resetOption","_loadingFX","showLoading","cfg","isObject","hideLoading","loadingEffects","eventObj","actionWrap","actionInfo","updateMethod","payloads","batched","batch","map","eventObjBatch","isHighlightOrDownplay","batchItem","trigger","pendingActions","shift","MOUSE_EVENT_NAMES","eveName","e","dataIndex","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","groupIdBase","DOM_ATTRIBUTE_KEY","dependencies","replace","isDom","nodeName","toUpperCase","clientWidth","clientHeight","setAttribute","connect","isArray","disConnect","getInstanceByDom","getAttribute","getInstanceById","registerTheme","preprocessorFunc","priority","processorFunc","isNaN","registerAction","registerCoordinateSystem","CoordinateSystem","register","layoutFunc","visualFunc","registerLoading","loadingFx","superClass","extendSeriesModel","extendChartView","setCanvasCreator","creator","noop","List","Model","number","format","matrix","vector","util","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","Scale","scaleProto","mathPow","pow","mathLog","LogScale","base","getTicks","scale","setExtent","start","end","getExtent","unionExtent","quantity","err","abs","updateDataSelected","uid","hasAnimation","getName","selectedOffset","from","seriesId","toggleItemSelected","getItemGraphicEl","getItemLayout","isSelected","midAngle","startAngle","endAngle","dx","cos","dy","sin","offset","position","animate","when","PiePiece","onEmphasis","polyline","hoverIgnore","onNormal","normalIgnore","Group","sector","Sector","Polyline","updateData","getLabelStyle","labelModel","labelPosition","isLabelInside","getItemVisual","opacity","retrieve","hostModel","getFormattedLabel","piePieceProto","firstCreate","animateTo","r","childAt","itemModel","getItemModel","sectorShape","label","setShape","updateProps","itemStyleModel","visualColor","useStyle","lineJoin","hoverStyle","ifEnableAnimation","_updateLabel","setHoverStyle","labelLine","labelText","labelLayout","points","linePoints","verticalAlign","font","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","stroke","getLineStyle","smooth","inherits","Pie","sectorGroup","_sectorGroup","oldData","_data","isFirstRender","onSectorClick","selectedMode","diff","piePiece","eachChild","child","setItemGraphicEl","newIdx","oldIdx","execute","count","removeClipPath","setClipPath","_createClipPath","cx","cy","clockwise","cb","clipPath","r0","initProps","PI","modelUtil","completeDimensions","dataSelectableMixin","PieSeries","superApply","arguments","legendDataProvider","_dataBeforeProcessed","updateSelectedMap","_defaultLabelLine","mergeOption","newOption","superCall","getInitialData","dimensions","initData","sum","getSum","percent","toFixed","$vars","defaultEmphasis","labelLineNormalOpt","normal","labelLineEmphasisOpt","emphasis","legendHoverLink","hoverAnimation","center","minAngle","avoidLabelOverlap","rotate","length2","lineStyle","itemStyle","animationEasing","seriesType","actionInfos","selected","subType","source","result","len","isBuildInObject","hasOwnProperty","merge","overwrite","targetProp","sourceProp","mergeAll","targetAndSources","overlay","document","createElement","getContext","_ctx","array","clazz","baseClazz","F","clazzPrototype","prop","constructor","isArrayLike","nativeForEach","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","args","nativeSlice","objToString","isFunction","isString","BUILTIN_OBJECT","nodeType","values","Function","condition","message","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","toString","arrayProto","paletteScope","eachRawSeriesByType","dataAll","getRawData","idxMap","isSeriesFiltered","rawIdx","getRawIndex","filteredIdx","singleDataColor","setItemVisual","getColorFromPalette","parsePercent","PI2","RADIAN","size","unitRadian","roseType","getDataExtent","restAngle","valueSumLargerThanMinAngle","currentAngle","dir","angle","setItemLayout","linearMap","legendModels","findComponents","filterSelf","isAxisUsedInTheGrid","axisModel","findGridModel","getLabelUnionRect","axis","labels","getFormattedLabels","step","labelCount","isLabelIgnored","singleRect","getTextRect","union","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","updateAxisTransfrom","coordBase","axisExtent","axisExtentSum","toGlobalCoord","dim","coord","toLocalCoord","findAxesModels","axesTypes","axisType","queryComponents","isCartesian2D","axisHelper","Cartesian2D","Axis2D","ifAxisCrossZero","niceScaleExtent","gridProto","_rect","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","onZero","adjustAxes","axesList","isHorizontal","gridRect","inverse","labelUnionRect","getAxis","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","createAxisCreator","axisPosition","axisPositionUsed","createScaleByModel","isCategory","onBand","axesCount","cartesian","addAxis","coordDimToDataDim","axesModels","xAxisModel","yAxisModel","componentIndex","grids","createListFromArray","coordSys","getMarkerPosition","pt","dataToPoint","getLayout","offsetIndex","getBaseAxis","NaN","brushSelector","barMinHeight","fixLayoutWithLineWidth","lineWidth","signX","signY","coordinateSystemType","_renderOnCartesian","createRect","isUpdate","barBorderWidthQuery","enableAnimation","rectShape","animateProperty","animateTarget","baseAxis","hasValue","newIndex","oldIndex","_updateStyle","setLabel","labelPositionOutside","setText","textPosition","eachItemGraphicEl","getBarItemStyle","hoverLabelModel","rectStyle","getRawValue","getSeriesStackId","getAxisKey","calBarWidthAndOffset","barSeries","columnsMap","bandWidth","getBandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","stackId","maxWidth","barWidth","barMaxWidth","barGap","barCategoryGap","coordSysName","barGapPercent","autoWidth","column","lastColumn","widthSum","barWidthAndOffset","getSeriesByType","lastStackCoords","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","valueAxisStart","dataToCoord","getGlobalExtent","coords","dataToPoints","setLayout","p","n","sign","lastCoord","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","doSingleLeaveHover","normalStl","removeHover","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","props","animatableModel","animationEnabled","getShallow","postfix","duration","animationDelay","pathTool","Path","Circle","Ring","Polygon","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","extendShape","extendPath","pathData","extendFromString","makePath","path","createFromString","aspect","resizePath","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","x1","x2","y1","y2","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","labelColor","textDistance","textFill","getTransform","ancestor","mat","identity","mul","getLocalTransform","parent","vertex","transform","invert","transformDirection","direction","hBase","vBase","groupTransition","g1","g2","getElMap","g","elMap","anid","getAnimatableProps","elMap1","oldEl","newProp","boxLayout","orient","maxHeight","currentLineMaxSize","nextX","nextY","nextChild","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","containerWidth","containerHeight","parseFloat","normalizeCssArray","verticalMargin","horizontalMargin","positionGroup","mergeLayoutParam","targetOption","opt","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","hasProp","copy","hNames","vNames","hResult","vResult","getLayoutParams","copyLayoutParams","_trim","str","RADIAN_EPSILON","domain","range","clamp","subDomain","subRange","all","match","precision","asc","arr","sort","getPrecision","getPrecisionSafe","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","MAX_SAFE_INTEGER","remRadian","radian","pi2","isRadianAroundZero","ret","nf","exp10","f","textContain","addCommas","toCamelCase","group1","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","formatTpl","tpl","paramsList","seriesLen","alias","k","s2d","M","h","getHours","getMinutes","s","getSeconds","capitalFirst","charAt","substr","truncateText","roundingErrorFix","thisExtent","other","getInterval","setInterval","ticks","safeLimit","tick","getTicksLabels","splitNumber","isFinite","reverse","expandSize","detect","ua","os","browser","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","navigator","userAgent","chartInstance","echartsAPIList","mergeTheme","hasClass","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","types","makeKeyInfo","mapResult","idMap","existCpt","exist","determineSubType","keyInfo","idNum","newCptOption","existComponent","createSeriesIndices","seriesModels","filterBySubType","components","cpt","assertSeriesInitialized","parentModel","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","normalizeToArray","mappingToExists","dependentModels","resultItem","ComponentModelClass","optionUpdated","extraOpt","newCptTypes","componentOption","topologicalTravel","getAllClassMainTypes","isIdInner","getTheme","getComponent","cpts","isIdArray","isNameArray","getQueryCond","q","indexAttr","idAttr","nameAttr","doFilter","res","queryCond","queryResult","getSeriesByName","oneSeries","getSeries","rawSeriesIndex","eachRawSeries","filterSeries","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","compare","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","indices","_coordinateSystems","coordinateSystemCreators","coordinateSystems","coordinateSystemCreator","colorPaletteMixin","visualColorAccessPath","mergeDefaultAndTheme","cloneShallow","getDefaultOption","LABEL_OPTIONS","fillDataTextStyle","newSeriesOption","getLinkedData","setData","coordDim","dataDimToCoordDim","dataDim","formatTooltip","multipleSeries","formatArrayValue","dimInfo","getDimensionInfo","dimType","formattedValue","colorEl","seriesName","scope","getAxisTooltipDataIndex","dataFormatMixin","getDependencies","getClassesByMainType","arrayPush","clazzUtil","componentUtil","$constructor","getUID","inputPositionParams","themeModel","isInit","optList","Class","__defaultOption","enableClassManagement","registerWhenExtend","enableSubTypeDefaulter","enableTopologicalTravel","Component","componentProto","enableClassExtend","Chart","elSetState","childCount","dataIndices","indexOfName","chartProto","delInstance","guid","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","Ctor","rendererType","vml","handerProxy","getViewportRoot","stage","_needsRefresh","_needsRefreshHover","refreshHoverImmediately","oldDelFromMap","delFromMap","oldAddToMap","addToMap","elId","removeSelfFromZr","addSelfToZr","getId","addRoot","delRoot","zLevel","config","refresh","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventHandler","stop","arrySlice","_$handlers","_h","ctx","isSilent","newList","argLen","triggerWithContext","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","m1","m2","lerp","colorStr","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","toHex","fastMapToColor","normalizedValue","colors","out","leftIndex","rightIndex","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","runHi","reverseRun","t","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","tmp","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Gradient","encodeColor","colorAccessPath","set","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","pointerColor","dataRange","visualMap","componentName","textColor","maskColor","mask","arc","lineCap","labelRect","animateShape","delay","ArrayCtor","Float32Array","out0","out1","out2","out3","out4","out5","translate","v","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","ignoreParent","thisParentModel","isEmpty","setReadOnly","properties","normalizeDimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","transferProperties","_storage","originalStorage","dimStore","UNDEFINED","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","listProto","hasItemOption","getDimension","nameList","dimValueGetter","dimensionInfoMap","idList","nameRepeatCount","DataCtor","dataItem","dimName","dimIndex","getDataItemValue","isDataItemOption","converDataValue","dimStorage","stackedValue","getValues","dimData","dimExtent","rawIndex","indexOfRawIndex","indexOfNearest","maxDistance","nearestIdx","minDist","Number","MAX_VALUE","dist","getRawDataItem","dims","dimSize","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","getVisual","clearItemLayouts","itemVisual","setItemDataAndSeriesIndex","dimensionInfoList","wrapMethod","injectFunction","originalMethod","TRANSFERABLE_METHODS","CHANGABLE_METHODS","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","distance","distanceSquare","negate","lengthSquare","distSquare","contain","OrdinalScale","getScaleExtent","originalExtent","getMin","getMax","crossZero","getNeedCrossZero","boundaryGap","minInterval","intervalScale","getCategories","getAxisLabelInterval","tickCoords","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","tickCoord","intersect","labelFormatter","Cartesian","getAxesByScale","containPoint","point","axisX","axisY","containData","pointToData","coordToData","Axis","axisLabelInterval","coordExtent","getLabelInterval","labelInterval","_labelInterval","containLabel","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","PathProxy","CMD","c","ctlPtx","ctlPty","C","Q","A","Z","toStatic","createPathOptions","pathProxy","buildPath","transformPath","rebuildPath","dirty","vMag","acos","pathEls","pathList","pathEl","__dirty","pathBundle","appendPath","Displayable","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","restoreTransform","drawRectText","shapeCfg","inBundle","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","strokeNoScale","getLineScale","localPos","transformCoordToLocal","containStroke","dirtyPath","__clipTarget","loop","attrKV","Sub","extendFrom","defaultShape","thisShape","addColorStop","Element","_children","__storage","children","childOfName","_doAdd","addBefore","nextSibling","addChildrenToStorage","delChildrenFromStorage","includeChildren","tmpRect","tmpMat","invisible","childRect","lineHeight","measureText","textLines","fillText","strokeText","ZImage","LRU","globalImageCache","src","_image","cachedImgObj","onload","pending","put","sWidth","sHeight","sx","sy","drawImage","moveTo","unitX","unitY","lineTo","closePath","roundRectHelper","polyHelper","smoothConstraint","pointAt","someVectorAt","isTangent","cpx2","cpy2","cubicDerivativeAt","cubicAt","cpx1","cpy1","quadraticDerivativeAt","quadraticAt","curveTool","vec2","quadraticSubdivide","cubicSubdivide","quadraticCurveTo","bezierCurveTo","tangentAt","globalCoord","paths","_updatePathDirty","beforeBrush","afterBrush","v2ApplyTransform","mathAbs","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","getTextWidth","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","textLineLen","adjustTextPositionOnRect","textHeight","halfHeight","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","j","subLength","estimateLength","charCode","charCodeAt","nubmerUtil","subOpts","emphasisOpt","normalOpt","subOptName","createDataFormatModel","rawValue","rawDataIndex","itemOpt","componentSubType","formatter","exists","newCptOptions","cptOption","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","otherDataIndices","lenj","mapToArray","isData","mapA","mapB","platform","fontFamily","fontStyle","animationDuration","animationDurationUpdate","animationEasingUpdate","animationThreshold","progressiveThreshold","hoverLayerThreshold","_colorIdx","_colorNameMap","colorIdx","colorNameMap","colorPalette","curve","bbox","min2","max2","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","anticlockwise","arcTo","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","nPoint","mathAtan2","atan2","TYPE_DELIMITER","IS_CONTAINER","RootClass","proto","ExtendedClass","entity","makeContainer","container","registerClass","componentTypeMain","throwWhenNotFound","o","hasSubTypes","originalExtend","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","rectContain","animateStyle","isAroundEqual","EPSILON","swapExtrema","extrema","windingCubic","nRoots","cubicRootAt","roots","y0_","y1_","nExtrema","unit","x_","cubicExtrema","windingQuadratic","quadraticRootAt","quadraticExtremum","y_","windingArc","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","line","excludes","getLineDash","lineType","rank","repeat","_canvasPattern","createPattern","getAreaStyle","gTextStyleModel","align","baseline","getBorderLineDash","createLinearGradient","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","styleProto","maxValue","lastIndexOf","save","shadowColor","textShadowColor","restore","Transformable","Animatable","drift","decomposeTransform","beforeUpdate","afterUpdate","updateTransform","hide","animators","addAnimator","removeAnimator","dimAxisMapper","_axes","_dimList","getAxes","scaleType","_dataCoordConvert","input","dimList","output","idStart","isNotAroundZero","mIdentity","transformableProto","needLocalTransform","parentHasTransform","invTransform","tmpTransform","transformCoordToGlobal","Animator","animatingShape","pathSplitted","animator","during","done","forwardToLast","easing","_animateToShallow","objShallow","propertyCount","DELIMITER","subTypeDefaulters","registerSubTypeDefaulter","defaulter","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","targetNameList","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","fixExtentWithBands","nTick","normalizedExtent","getTicksCoords","alignWithLabel","bands","getBands","getLabelsCoords","debugMode","defaultGetter","defaultSetter","interpolateNumber","p0","p1","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","rgba2String","createTrackClip","oneTrackDone","keyframes","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","getAxisType","axisDim","axisModelCreator","AxisModel","_resetRange","setRange","rangeStart","rangeEnd","extraOption","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","axisDefault","AXIS_TYPES","axisName","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","nameLocation","nameRotate","nameTruncate","nameTextStyle","nameGap","triggerEvent","tooltip","axisLine","axisTick","inside","axisLabel","splitLine","splitArea","areaStyle","categoryAxis","timeAxis","logAxis","logBase","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","creators","registeredCoordSys","axesInfo","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","isAroundZero","onet","t1","disc","K","discSqrt","Y1","Y2","ONE_THIRD","T","ASqrt","THREE_SQRT","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","prev","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","divider","quadraticProjectPoint","v2Create","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_update","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","_l","_a","_b","_s","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","LRUProto","leastUsedEntry","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","pos","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","d0","cp0","r1","r2","r3","r4","total","shapeCompareFunc","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","clipPaths","elements","_renderList","displayableSortFunc","makeEventPacket","eveType","cancelBubble","offsetX","zrX","offsetY","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","EmptyProxy","isHover","displayable","Draggable","handlerNames","proxy","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","findHover","lastHovered","setCursor","dispatchToElement","mouseout","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","_downel","_upel","Dispatcher","requestAnimationFrame","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","getTime","deferredEvents","deferredClips","_startLoop","pause","resume","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","_touching","clearTimeout","_touchTimer","setTimeout","useTouchEvent","initDomHandler","makeMouseHandler","fn","touchHandlerNames","_handlers","domHandlers","mouseHandlerNames","HandlerDomProxy","mountHandlers","addEventListener","GestureMgr","eventTool","removeEventListener","normalizeEvent","TOUCH_CLICK_DELAY","element","toElement","relatedTarget","parentNode","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","domRootStyle","overflow","Layer","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_getWidth","_getHeight","_domRoot","appendChild","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","getLayer","originalEl","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","imageLayer","stl","defaultView","getComputedStyle","paddingLeft","paddingRight","paddingTop","paddingBottom","_pathToImage","clearRect","pathTransform","ImageShape","imgShape","me","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","_y","dropTarget","lastDropTarget","_dropTarget","clientToLocal","clientX","clientY","isTouch","touch","targetTouches","changedTouches","detail","isDomLevel2","attachEvent","detachEvent","preventDefault","stopPropagation","returnValue","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","recognizers","pinch","track","pinchEnd","pinchPre","pinchCenter","returnFalse","createDom","newDom","newDomStyle","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","targetList","_selectTargetMap","targetMap","select","unSelect","toggleSelected","layoutAxis","getZero","theAxis","rawAxisPosition","rectBound","axisOffset","posMap","dirMap","labelDirection","tickDirection","nameDirection","labelOffset","labelRotation","AxisBuilder","ifIgnoreOnTick","axisBuilderAttrs","selfBuilderAttrs","AxisView","oldAxisGroup","_axisGroup","axisBuilder","getGroup","_splitLine","splitLineModel","lineStyleModel","lineColors","lineInterval","lineCount","ticksCoords","colorIndex","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","areaInterval","adjustSingleSide","viewWidth","viewHeight","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelLineLen","labelLineLen2","labelRotate","makeAxisEventDataBase","innerTextLayout","rotationDiff","endTextLayout","textRotate","onLeft","tooltipOpt","dumbGroup","_transform","_dumbGroup","hasBuilder","builders","pt1","pt2","tickModel","tickLen","tickInterval","isTwoLabelOverlapped","current","firstRect","nextRect","axisLabelShow","labelMargin","categoryData","textEls","itemTextStyleModel","labelBeforeFormat","targetType","firstLabel","nextLabel","lastLabel","prevLabel","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","truncatedText","formatterParams","__fullText","__truncatedText","rawTick"],"mappings":"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GAEAC,YACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,OACA,EACA,EACA,EACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,MACA,EACA,EACA,IACA,GAEAC,YACA,IACA,GACA,IACA,GAEAC,OACA,IACA,GACA,GACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,YACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,OACA,IACA,IACA,GACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,SACA,IACA,GACA,GACA,GAEAC,MACA,EACA,IACA,IACA,GAEAC,UACA,EACA,EACA,IACA,GAEAC,UACA,EACA,IACA,IACA,GAEAC,eACA,IACA,IACA,GACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,WACA,EACA,IACA,EACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,aACA,IACA,EACA,IACA,GAEAC,gBACA,GACA,IACA,GACA,GAEAC,YACA,IACA,IACA,EACA,GAEAC,YACA,IACA,GACA,IACA,GAEAC,SACA,IACA,EACA,EACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,eACA,GACA,GACA,IACA,GAEAC,eACA,GACA,GACA,GACA,GAEAC,eACA,GACA,GACA,GACA,GAEAC,eACA,EACA,IACA,IACA,GAEAC,YACA,IACA,EACA,IACA,GAEAC,UACA,IACA,GACA,IACA,GAEAC,aACA,EACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,YACA,GACA,IACA,IACA,GAEAC,WACA,IACA,GACA,GACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,aACA,GACA,IACA,GACA,GAEAC,SACA,IACA,EACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,OACA,EACA,IACA,EACA,GAEAC,aACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,WACA,IACA,GACA,GACA,GAEAC,QACA,GACA,EACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,EACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,sBACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,eACA,GACA,IACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,MACA,EACA,IACA,EACA,GAEAC,WACA,GACA,IACA,GACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,SACA,IACA,EACA,IACA,GAEAC,QACA,IACA,EACA,EACA,GAEAC,kBACA,IACA,IACA,IACA,GAEAC,YACA,EACA,EACA,IACA,GAEAC,cACA,IACA,GACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,gBACA,GACA,IACA,IACA,GAEAC,iBACA,IACA,IACA,IACA,GAEAC,mBACA,EACA,IACA,IACA,GAEAC,iBACA,GACA,IACA,IACA,GAEAC,iBACA,IACA,GACA,IACA,GAEAC,cACA,GACA,GACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,MACA,EACA,EACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,QACA,IACA,IACA,EACA,GAEAC,WACA,IACA,GACA,EACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,QACA,IACA,EACA,IACA,GAEAC,KACA,IACA,EACA,EACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,aACA,IACA,GACA,GACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,GACA,GAEAC,UACA,GACA,IACA,GACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,QACA,IACA,GACA,GACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,WACA,IACA,GACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,aACA,EACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,KACA,IACA,IACA,IACA,GAEAC,MACA,EACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,QACA,IACA,GACA,GACA,GAEAC,WACA,GACA,IACA,IACA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","file":"static/js/2.cdf123478cd95191923c.js","sourcesContent":["webpackJsonp([2,4],{\n\n/***/ 15:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _echarts = __webpack_require__(47);\n\t\n\tvar _echarts2 = _interopRequireDefault(_echarts);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    data: function data() {\n\t        return {\n\t            typeMap: {\n\t                radio: '',\n\t                checkbox: '',\n\t                textarea: ''\n\t            }\n\t        };\n\t    },\n\t\n\t    vuex: {\n\t        getters: {\n\t            questionnaire: function questionnaire(state) {\n\t                return state.currentQuestionnaire;\n\t            },\n\t            questionnaireList: function questionnaireList(state) {\n\t                return state.questionnaireList;\n\t            }\n\t        },\n\t        actions: {\n\t            setCurrentQuest: function setCurrentQuest(_ref, item) {\n\t                var dispatch = _ref.dispatch;\n\t\n\t                dispatch(\"SET_QUEST\", item);\n\t            }\n\t        }\n\t    },\n\t    route: {\n\t        data: function data(_ref2) {\n\t            var _this = this;\n\t\n\t            var to = _ref2.to,\n\t                next = _ref2.next;\n\t\n\t            var id = to.params.questId;\n\t            if (!this.questionnaire) {\n\t                this.questionnaireList.forEach(function (item) {\n\t                    if (parseInt(item.id) === parseInt(id)) {\n\t                        _this.setCurrentQuest(item);\n\t                        return;\n\t                    }\n\t                });\n\t            }\n\t\n\t            next();\n\t        }\n\t    },\n\t    directives: {\n\t        'echarts': {\n\t            bind: function bind() {\n\t                var self = this;\n\t                this.vm.$nextTick(function () {\n\t                    self.instance = _echarts2.default.init(self.el);\n\t                });\n\t            },\n\t            update: function update(newVal, oldVal) {\n\t                var self = this;\n\t                var seriesData = [];\n\t                var option = {};\n\t\n\t                if (newVal.type !== 'textarea') {\n\t                    newVal.selections.forEach(function (item) {\n\t                        seriesData.push(parseInt(Math.random() * 100));\n\t                    });\n\t                    option = {\n\t                        grid: {\n\t                            top: 40,\n\t                            bottom: 25\n\t                        },\n\t                        title: {\n\t                            text: self.vm.typeMap[newVal.type] + '.' + newVal.title,\n\t                            textAlign: \"left\"\n\t                        },\n\t                        yAxis: {},\n\t                        xAxis: {\n\t                            data: newVal.selections\n\t                        },\n\t                        series: [{\n\t                            type: 'bar',\n\t                            data: seriesData\n\t                        }]\n\t                    };\n\t                } else {\n\t                    seriesData.push(parseInt(Math.random() * 100));\n\t                    seriesData.push(100 - seriesData[0]);\n\t                    option = {\n\t                        title: {\n\t                            text: self.vm.typeMap[newVal.type] + '.' + newVal.title,\n\t                            textAlign: \"left\"\n\t                        },\n\t                        series: [{\n\t                            type: 'pie',\n\t                            radius: \"60%\",\n\t                            data: [{ name: '', value: seriesData[0] }, { name: '', value: seriesData[1] }]\n\t                        }]\n\t                    };\n\t                }\n\t                this.vm.$nextTick(function () {\n\t                    self.instance.setOption(option);\n\t                });\n\t            },\n\t            unbind: function unbind() {\n\t                this.instance.dispose();\n\t            }\n\t        }\n\t    }\n\t};\n\n/***/ }),\n\n/***/ 23:\n/***/ (function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/Data.vue\"],\"names\":[],\"mappings\":\"AAAA,0BAA0B,iBAAiB,iBAAiB,iBAAiB,CAAC,6BAA6B,kBAAkB,sBAAsB,iBAAiB,eAAgB,CAAC,wBAAwB,eAAe,sBAAsB,oBAAoB,CAAC,eAAe,gBAAgB,WAAW,aAAa,CAAC\",\"file\":\"Data.vue\",\"sourcesContent\":[\"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:bold}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ }),\n\n/***/ 27:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(23);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js!../../node_modules/less-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/selector.js?type=style&index=0!../../node_modules/eslint-loader/index.js!./Data.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js!../../node_modules/less-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/selector.js?type=style&index=0!../../node_modules/eslint-loader/index.js!./Data.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }),\n\n/***/ 34:\n/***/ (function(module, exports) {\n\n\tmodule.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem-data track-by=$index> <div class=chart v-echarts=questItem></div> </div> </div> <p class=preview-deadline>{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n/***/ }),\n\n/***/ 41:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\tvar __vue_styles__ = {}\n\t__webpack_require__(27)\n\t__vue_script__ = __webpack_require__(15)\n\t__vue_template__ = __webpack_require__(34)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tvar __vue_options__ = typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports\n\tif (__vue_template__) {\n\t__vue_options__.template = __vue_template__\n\t}\n\tif (!__vue_options__.computed) __vue_options__.computed = {}\n\tObject.keys(__vue_styles__).forEach(function (key) {\n\tvar module = __vue_styles__[key]\n\t__vue_options__.computed[key] = function () { return module }\n\t})\n\n\n/***/ }),\n\n/***/ 47:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(global) {(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module === 'object' && module.exports) {\n\t        // Node. Does not work with strict CommonJS, but\n\t        // only CommonJS-like environments that support module.exports,\n\t        // like Node.\n\t        module.exports = factory();\n\t    } else {\n\t        // Browser globals (root is window)\n\t        root.echarts = factory();\n\t    }\n\t}(this, function () {var require, define;\n\t(function () {\n\t    var mods = {};\n\t\n\t    define = function (id, deps, factory) {\n\t        mods[id] = {\n\t            id: id,\n\t            deps: deps,\n\t            factory: factory,\n\t            defined: 0,\n\t            exports: {},\n\t            require: createRequire(id)\n\t        };\n\t    };\n\t\n\t    require = createRequire('');\n\t\n\t    function normalize(id, baseId) {\n\t        if (!baseId) {\n\t            return id;\n\t        }\n\t\n\t        if (id.indexOf('.') === 0) {\n\t            var basePath = baseId.split('/');\n\t            var namePath = id.split('/');\n\t            var baseLen = basePath.length - 1;\n\t            var nameLen = namePath.length;\n\t            var cutBaseTerms = 0;\n\t            var cutNameTerms = 0;\n\t\n\t            pathLoop: for (var i = 0; i < nameLen; i++) {\n\t                switch (namePath[i]) {\n\t                    case '..':\n\t                        if (cutBaseTerms < baseLen) {\n\t                            cutBaseTerms++;\n\t                            cutNameTerms++;\n\t                        }\n\t                        else {\n\t                            break pathLoop;\n\t                        }\n\t                        break;\n\t                    case '.':\n\t                        cutNameTerms++;\n\t                        break;\n\t                    default:\n\t                        break pathLoop;\n\t                }\n\t            }\n\t\n\t            basePath.length = baseLen - cutBaseTerms;\n\t            namePath = namePath.slice(cutNameTerms);\n\t\n\t            return basePath.concat(namePath).join('/');\n\t        }\n\t\n\t        return id;\n\t    }\n\t\n\t    function createRequire(baseId) {\n\t        var cacheMods = {};\n\t\n\t        function localRequire(id, callback) {\n\t            if (typeof id === 'string') {\n\t                var exports = cacheMods[id];\n\t                if (!exports) {\n\t                    exports = getModExports(normalize(id, baseId));\n\t                    cacheMods[id] = exports;\n\t                }\n\t\n\t                return exports;\n\t            }\n\t            else if (id instanceof Array) {\n\t                callback = callback || function () {};\n\t                callback.apply(this, getModsExports(id, callback, baseId));\n\t            }\n\t        };\n\t\n\t        return localRequire;\n\t    }\n\t\n\t    function getModsExports(ids, factory, baseId) {\n\t        var es = [];\n\t        var mod = mods[baseId];\n\t\n\t        for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {\n\t            var id = normalize(ids[i], baseId);\n\t            var arg;\n\t            switch (id) {\n\t                case 'require':\n\t                    arg = (mod && mod.require) || require;\n\t                    break;\n\t                case 'exports':\n\t                    arg = mod.exports;\n\t                    break;\n\t                case 'module':\n\t                    arg = mod;\n\t                    break;\n\t                default:\n\t                    arg = getModExports(id);\n\t            }\n\t            es.push(arg);\n\t        }\n\t\n\t        return es;\n\t    }\n\t\n\t    function getModExports(id) {\n\t        var mod = mods[id];\n\t        if (!mod) {\n\t            throw new Error('No ' + id);\n\t        }\n\t\n\t        if (!mod.defined) {\n\t            var factory = mod.factory;\n\t            var factoryReturn = factory.apply(\n\t                this,\n\t                getModsExports(mod.deps || [], factory, id)\n\t            );\n\t            if (typeof factoryReturn !== 'undefined') {\n\t                mod.exports = factoryReturn;\n\t            }\n\t            mod.defined = 1;\n\t        }\n\t\n\t        return mod.exports;\n\t    }\n\t}());\n\tdefine('echarts/chart/pie', ['require', 'zrender/core/util', '../echarts', './pie/PieSeries', './pie/PieView', '../action/createDataSelectAction', '../visual/dataColor', './pie/pieLayout', '../processor/dataFilter'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var echarts = require('../echarts');\n\t    require('./pie/PieSeries');\n\t    require('./pie/PieView');\n\t    require('../action/createDataSelectAction')('pie', [\n\t        {\n\t            type: 'pieToggleSelect',\n\t            event: 'pieselectchanged',\n\t            method: 'toggleSelected'\n\t        },\n\t        {\n\t            type: 'pieSelect',\n\t            event: 'pieselected',\n\t            method: 'select'\n\t        },\n\t        {\n\t            type: 'pieUnSelect',\n\t            event: 'pieunselected',\n\t            method: 'unSelect'\n\t        }\n\t    ]);\n\t    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\t    echarts.registerLayout(zrUtil.curry(require('./pie/pieLayout'), 'pie'));\n\t    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\t});\n\tdefine('echarts/chart/bar', ['require', 'zrender/core/util', '../coord/cartesian/Grid', './bar/BarSeries', './bar/BarView', '../layout/barGrid', '../echarts', '../component/grid'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    require('../coord/cartesian/Grid');\n\t    require('./bar/BarSeries');\n\t    require('./bar/BarView');\n\t    var barLayoutGrid = require('../layout/barGrid');\n\t    var echarts = require('../echarts');\n\t    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\t    // Visual coding for legend\n\t    echarts.registerVisual(function (ecModel) {\n\t        ecModel.eachSeriesByType('bar', function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            data.setVisual('legendSymbol', 'roundRect');\n\t        });\n\t    });\n\t    // In case developer forget to include grid component\n\t    require('../component/grid');\n\t});\n\tdefine('echarts/component/title', ['require', '../echarts', '../util/graphic', '../util/layout'], function (require) {\n\t    'use strict';\n\t    var echarts = require('../echarts');\n\t    var graphic = require('../util/graphic');\n\t    var layout = require('../util/layout');\n\t    // Model\n\t    echarts.extendComponentModel({\n\t        type: 'title',\n\t        layoutMode: {\n\t            type: 'box',\n\t            ignoreSize: true\n\t        },\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 6,\n\t            show: true,\n\t            text: '',\n\t            target: 'blank',\n\t            subtext: '',\n\t            subtarget: 'blank',\n\t            left: 0,\n\t            top: 0,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderColor: '#ccc',\n\t            borderWidth: 0,\n\t            padding: 5,\n\t            itemGap: 10,\n\t            textStyle: {\n\t                fontSize: 18,\n\t                fontWeight: 'bolder',\n\t                color: '#333'\n\t            },\n\t            subtextStyle: { color: '#aaa' }\n\t        }\n\t    });\n\t    // View\n\t    echarts.extendComponentView({\n\t        type: 'title',\n\t        render: function (titleModel, ecModel, api) {\n\t            this.group.removeAll();\n\t            if (!titleModel.get('show')) {\n\t                return;\n\t            }\n\t            var group = this.group;\n\t            var textStyleModel = titleModel.getModel('textStyle');\n\t            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\t            var textAlign = titleModel.get('textAlign');\n\t            var textBaseline = titleModel.get('textBaseline');\n\t            var textEl = new graphic.Text({\n\t                    style: {\n\t                        text: titleModel.get('text'),\n\t                        textFont: textStyleModel.getFont(),\n\t                        fill: textStyleModel.getTextColor()\n\t                    },\n\t                    z2: 10\n\t                });\n\t            var textRect = textEl.getBoundingRect();\n\t            var subText = titleModel.get('subtext');\n\t            var subTextEl = new graphic.Text({\n\t                    style: {\n\t                        text: subText,\n\t                        textFont: subtextStyleModel.getFont(),\n\t                        fill: subtextStyleModel.getTextColor(),\n\t                        y: textRect.height + titleModel.get('itemGap'),\n\t                        textBaseline: 'top'\n\t                    },\n\t                    z2: 10\n\t                });\n\t            var link = titleModel.get('link');\n\t            var sublink = titleModel.get('sublink');\n\t            textEl.silent = !link;\n\t            subTextEl.silent = !sublink;\n\t            if (link) {\n\t                textEl.on('click', function () {\n\t                    window.open(link, '_' + titleModel.get('target'));\n\t                });\n\t            }\n\t            if (sublink) {\n\t                subTextEl.on('click', function () {\n\t                    window.open(sublink, '_' + titleModel.get('subtarget'));\n\t                });\n\t            }\n\t            group.add(textEl);\n\t            subText && group.add(subTextEl);\n\t            // If no subText, but add subTextEl, there will be an empty line.\n\t            var groupRect = group.getBoundingRect();\n\t            var layoutOption = titleModel.getBoxLayoutParams();\n\t            layoutOption.width = groupRect.width;\n\t            layoutOption.height = groupRect.height;\n\t            var layoutRect = layout.getLayoutRect(layoutOption, {\n\t                    width: api.getWidth(),\n\t                    height: api.getHeight()\n\t                }, titleModel.get('padding'));\n\t            // Adjust text align based on position\n\t            if (!textAlign) {\n\t                // Align left if title is on the left. center and right is same\n\t                textAlign = titleModel.get('left') || titleModel.get('right');\n\t                if (textAlign === 'middle') {\n\t                    textAlign = 'center';\n\t                }\n\t                // Adjust layout by text align\n\t                if (textAlign === 'right') {\n\t                    layoutRect.x += layoutRect.width;\n\t                } else if (textAlign === 'center') {\n\t                    layoutRect.x += layoutRect.width / 2;\n\t                }\n\t            }\n\t            if (!textBaseline) {\n\t                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n\t                if (textBaseline === 'center') {\n\t                    textBaseline = 'middle';\n\t                }\n\t                if (textBaseline === 'bottom') {\n\t                    layoutRect.y += layoutRect.height;\n\t                } else if (textBaseline === 'middle') {\n\t                    layoutRect.y += layoutRect.height / 2;\n\t                }\n\t                textBaseline = textBaseline || 'top';\n\t            }\n\t            group.attr('position', [\n\t                layoutRect.x,\n\t                layoutRect.y\n\t            ]);\n\t            var alignStyle = {\n\t                    textAlign: textAlign,\n\t                    textVerticalAlign: textBaseline\n\t                };\n\t            textEl.setStyle(alignStyle);\n\t            subTextEl.setStyle(alignStyle);\n\t            // Render background\n\t            // Get groupRect again because textAlign has been changed\n\t            groupRect = group.getBoundingRect();\n\t            var padding = layoutRect.margin;\n\t            var style = titleModel.getItemStyle([\n\t                    'color',\n\t                    'opacity'\n\t                ]);\n\t            style.fill = titleModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                    shape: {\n\t                        x: groupRect.x - padding[3],\n\t                        y: groupRect.y - padding[0],\n\t                        width: groupRect.width + padding[1] + padding[3],\n\t                        height: groupRect.height + padding[0] + padding[2]\n\t                    },\n\t                    style: style,\n\t                    silent: true\n\t                });\n\t            graphic.subPixelOptimizeRect(rect);\n\t            group.add(rect);\n\t        }\n\t    });\n\t});\n\tdefine('echarts/component/grid', ['require', '../util/graphic', 'zrender/core/util', '../echarts', '../coord/cartesian/Grid', './axis'], function (require) {\n\t    'use strict';\n\t    var graphic = require('../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    var echarts = require('../echarts');\n\t    require('../coord/cartesian/Grid');\n\t    require('./axis');\n\t    // Grid view\n\t    echarts.extendComponentView({\n\t        type: 'grid',\n\t        render: function (gridModel, ecModel) {\n\t            this.group.removeAll();\n\t            if (gridModel.get('show')) {\n\t                this.group.add(new graphic.Rect({\n\t                    shape: gridModel.coordinateSystem.getRect(),\n\t                    style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()),\n\t                    silent: true\n\t                }));\n\t            }\n\t        }\n\t    });\n\t    echarts.registerPreprocessor(function (option) {\n\t        // Only create grid when need\n\t        if (option.xAxis && option.yAxis && !option.grid) {\n\t            option.grid = {};\n\t        }\n\t    });\n\t});\n\tdefine('echarts/scale/Time', ['require', 'zrender/core/util', '../util/number', '../util/format', './Interval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('../util/number');\n\t    var formatUtil = require('../util/format');\n\t    var IntervalScale = require('./Interval');\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t    var mathCeil = Math.ceil;\n\t    var mathFloor = Math.floor;\n\t    var ONE_SECOND = 1000;\n\t    var ONE_MINUTE = ONE_SECOND * 60;\n\t    var ONE_HOUR = ONE_MINUTE * 60;\n\t    var ONE_DAY = ONE_HOUR * 24;\n\t    // FIXME \n\t    var bisect = function (a, x, lo, hi) {\n\t        while (lo < hi) {\n\t            var mid = lo + hi >>> 1;\n\t            if (a[mid][2] < x) {\n\t                lo = mid + 1;\n\t            } else {\n\t                hi = mid;\n\t            }\n\t        }\n\t        return lo;\n\t    };\n\t    /**\n\t     * @alias module:echarts/coord/scale/Time\n\t     * @constructor\n\t     */\n\t    var TimeScale = IntervalScale.extend({\n\t            type: 'time',\n\t            getLabel: function (val) {\n\t                var stepLvl = this._stepLvl;\n\t                var date = new Date(val);\n\t                return formatUtil.formatTime(stepLvl[0], date);\n\t            },\n\t            niceExtent: function (approxTickNum, fixMin, fixMax) {\n\t                var extent = this._extent;\n\t                // If extent start and end are same, expand them\n\t                if (extent[0] === extent[1]) {\n\t                    // Expand extent\n\t                    extent[0] -= ONE_DAY;\n\t                    extent[1] += ONE_DAY;\n\t                }\n\t                // If there are no data and extent are [Infinity, -Infinity]\n\t                if (extent[1] === -Infinity && extent[0] === Infinity) {\n\t                    var d = new Date();\n\t                    extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\t                    extent[0] = extent[1] - ONE_DAY;\n\t                }\n\t                this.niceTicks(approxTickNum);\n\t                // var extent = this._extent;\n\t                var interval = this._interval;\n\t                if (!fixMin) {\n\t                    extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n\t                }\n\t                if (!fixMax) {\n\t                    extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n\t                }\n\t            },\n\t            niceTicks: function (approxTickNum) {\n\t                approxTickNum = approxTickNum || 10;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                var approxInterval = span / approxTickNum;\n\t                var scaleLevelsLen = scaleLevels.length;\n\t                var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\t                var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n\t                var interval = level[2];\n\t                // Same with interval scale if span is much larger than 1 year\n\t                if (level[0] === 'year') {\n\t                    var yearSpan = span / interval;\n\t                    // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                    // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\t                    var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\t                    interval *= yearStep;\n\t                }\n\t                var niceExtent = [\n\t                        mathCeil(extent[0] / interval) * interval,\n\t                        mathFloor(extent[1] / interval) * interval\n\t                    ];\n\t                this._stepLvl = level;\n\t                // Interval will be used in getTicks\n\t                this._interval = interval;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            parse: function (val) {\n\t                // val might be float.\n\t                return +numberUtil.parseDate(val);\n\t            }\n\t        });\n\t    zrUtil.each([\n\t        'contain',\n\t        'normalize'\n\t    ], function (methodName) {\n\t        TimeScale.prototype[methodName] = function (val) {\n\t            return intervalScaleProto[methodName].call(this, this.parse(val));\n\t        };\n\t    });\n\t    // Steps from d3\n\t    var scaleLevels = [\n\t            [\n\t                'hh:mm:ss',\n\t                1,\n\t                ONE_SECOND\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                5,\n\t                ONE_SECOND * 5\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                10,\n\t                ONE_SECOND * 10\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                15,\n\t                ONE_SECOND * 15\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                30,\n\t                ONE_SECOND * 30\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                1,\n\t                ONE_MINUTE\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                5,\n\t                ONE_MINUTE * 5\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                10,\n\t                ONE_MINUTE * 10\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                15,\n\t                ONE_MINUTE * 15\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                30,\n\t                ONE_MINUTE * 30\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                1,\n\t                ONE_HOUR\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                2,\n\t                ONE_HOUR * 2\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                6,\n\t                ONE_HOUR * 6\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                12,\n\t                ONE_HOUR * 12\n\t            ],\n\t            [\n\t                'MM-dd\\nyyyy',\n\t                1,\n\t                ONE_DAY\n\t            ],\n\t            [\n\t                'week',\n\t                7,\n\t                ONE_DAY * 7\n\t            ],\n\t            [\n\t                'month',\n\t                1,\n\t                ONE_DAY * 31\n\t            ],\n\t            [\n\t                'quarter',\n\t                3,\n\t                ONE_DAY * 380 / 4\n\t            ],\n\t            [\n\t                'half-year',\n\t                6,\n\t                ONE_DAY * 380 / 2\n\t            ],\n\t            [\n\t                'year',\n\t                1,\n\t                ONE_DAY * 380\n\t            ]\n\t        ];\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    TimeScale.create = function () {\n\t        return new TimeScale();\n\t    };\n\t    return TimeScale;\n\t});\n\tdefine('echarts/echarts', ['require', 'zrender/core/env', './model/Global', './ExtensionAPI', './CoordinateSystem', './model/OptionManager', './model/Component', './model/Series', './view/Component', './view/Chart', './util/graphic', 'zrender', 'zrender/core/util', 'zrender/tool/color', 'zrender/mixin/Eventful', 'zrender/core/timsort', './visual/seriesColor', './preprocessor/backwardCompat', './loading/default', './data/List', './model/Model', './util/number', './util/format', 'zrender/core/matrix', 'zrender/core/vector'], function (require) {\n\t    var env = require('zrender/core/env');\n\t    var GlobalModel = require('./model/Global');\n\t    var ExtensionAPI = require('./ExtensionAPI');\n\t    var CoordinateSystemManager = require('./CoordinateSystem');\n\t    var OptionManager = require('./model/OptionManager');\n\t    var ComponentModel = require('./model/Component');\n\t    var SeriesModel = require('./model/Series');\n\t    var ComponentView = require('./view/Component');\n\t    var ChartView = require('./view/Chart');\n\t    var graphic = require('./util/graphic');\n\t    var zrender = require('zrender');\n\t    var zrUtil = require('zrender/core/util');\n\t    var colorTool = require('zrender/tool/color');\n\t    var Eventful = require('zrender/mixin/Eventful');\n\t    var timsort = require('zrender/core/timsort');\n\t    var each = zrUtil.each;\n\t    var PRIORITY_PROCESSOR_FILTER = 1000;\n\t    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\t    var PRIORITY_VISUAL_LAYOUT = 1000;\n\t    var PRIORITY_VISUAL_GLOBAL = 2000;\n\t    var PRIORITY_VISUAL_CHART = 3000;\n\t    var PRIORITY_VISUAL_COMPONENT = 4000;\n\t    var PRIORITY_VISUAL_BRUSH = 5000;\n\t    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n\t    // where they must not be invoked nestedly, except the only case: invoke\n\t    // dispatchAction with updateMethod \"none\" in main process.\n\t    // This flag is used to carry out this rule.\n\t    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\t    var IN_MAIN_PROCESS = '__flag_in_main_process';\n\t    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n\t    var OPTION_UPDATED = '_optionUpdated';\n\t    function createRegisterEventWithLowercaseName(method) {\n\t        return function (eventName, handler, context) {\n\t            // Event name is all lowercase\n\t            eventName = eventName && eventName.toLowerCase();\n\t            Eventful.prototype[method].call(this, eventName, handler, context);\n\t        };\n\t    }\n\t    /**\n\t     * @module echarts~MessageCenter\n\t     */\n\t    function MessageCenter() {\n\t        Eventful.call(this);\n\t    }\n\t    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n\t    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n\t    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n\t    zrUtil.mixin(MessageCenter, Eventful);\n\t    /**\n\t     * @module echarts~ECharts\n\t     */\n\t    function ECharts(dom, theme, opts) {\n\t        opts = opts || {};\n\t        // Get theme by name\n\t        if (typeof theme === 'string') {\n\t            theme = themeStorage[theme];\n\t        }\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id;\n\t        /**\n\t         * Group id\n\t         * @type {string}\n\t         */\n\t        this.group;\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         * @private\n\t         */\n\t        this._dom = dom;\n\t        /**\n\t         * @type {module:zrender/ZRender}\n\t         * @private\n\t         */\n\t        this._zr = zrender.init(dom, {\n\t            renderer: opts.renderer || 'canvas',\n\t            devicePixelRatio: opts.devicePixelRatio\n\t        });\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._theme = zrUtil.clone(theme);\n\t        /**\n\t         * @type {Array.<module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsViews = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsViews = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t        /**\n\t         * @type {module:echarts/ExtensionAPI}\n\t         * @private\n\t         */\n\t        this._api = new ExtensionAPI(this);\n\t        /**\n\t         * @type {module:echarts/CoordinateSystem}\n\t         * @private\n\t         */\n\t        this._coordSysMgr = new CoordinateSystemManager();\n\t        Eventful.call(this);\n\t        /**\n\t         * @type {module:echarts~MessageCenter}\n\t         * @private\n\t         */\n\t        this._messageCenter = new MessageCenter();\n\t        // Init mouse events\n\t        this._initEvents();\n\t        // In case some people write `window.onresize = chart.resize`\n\t        this.resize = zrUtil.bind(this.resize, this);\n\t        // Can't dispatch action during rendering procedure\n\t        this._pendingActions = [];\n\t        // Sort on demand\n\t        function prioritySortFunc(a, b) {\n\t            return a.prio - b.prio;\n\t        }\n\t        timsort(visualFuncs, prioritySortFunc);\n\t        timsort(dataProcessorFuncs, prioritySortFunc);\n\t        this._zr.animation.on('frame', this._onframe, this);\n\t    }\n\t    var echartsProto = ECharts.prototype;\n\t    echartsProto._onframe = function () {\n\t        // Lazy update\n\t        if (this[OPTION_UPDATED]) {\n\t            this[IN_MAIN_PROCESS] = true;\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this[IN_MAIN_PROCESS] = false;\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t    };\n\t    /**\n\t     * @return {HTMLDomElement}\n\t     */\n\t    echartsProto.getDom = function () {\n\t        return this._dom;\n\t    };\n\t    /**\n\t     * @return {module:zrender~ZRender}\n\t     */\n\t    echartsProto.getZr = function () {\n\t        return this._zr;\n\t    };\n\t    /**\n\t     * @param {Object} option\n\t     * @param {boolean} notMerge\n\t     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n\t     */\n\t    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n\t        if (true) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        if (!this._model || notMerge) {\n\t            var optionManager = new OptionManager(this._api);\n\t            var theme = this._theme;\n\t            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n\t            ecModel.init(null, null, theme, optionManager);\n\t        }\n\t        this._model.setOption(option, optionPreprocessorFuncs);\n\t        if (lazyUpdate) {\n\t            this[OPTION_UPDATED] = true;\n\t        } else {\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this._zr.refreshImmediately();\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t        this[IN_MAIN_PROCESS] = false;\n\t        this._flushPendingActions();\n\t    };\n\t    /**\n\t     * @DEPRECATED\n\t     */\n\t    echartsProto.setTheme = function () {\n\t        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n\t    };\n\t    /**\n\t     * @return {module:echarts/model/Global}\n\t     */\n\t    echartsProto.getModel = function () {\n\t        return this._model;\n\t    };\n\t    /**\n\t     * @return {Object}\n\t     */\n\t    echartsProto.getOption = function () {\n\t        return this._model && this._model.getOption();\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getWidth = function () {\n\t        return this._zr.getWidth();\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getHeight = function () {\n\t        return this._zr.getHeight();\n\t    };\n\t    /**\n\t     * Get canvas which has all thing rendered\n\t     * @param {Object} opts\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getRenderedCanvas = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        opts = opts || {};\n\t        opts.pixelRatio = opts.pixelRatio || 1;\n\t        opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n\t        var zr = this._zr;\n\t        var list = zr.storage.getDisplayList();\n\t        // Stop animations\n\t        zrUtil.each(list, function (el) {\n\t            el.stopAnimation(true);\n\t        });\n\t        return zr.painter.getRenderedCanvas(opts);\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getDataURL = function (opts) {\n\t        opts = opts || {};\n\t        var excludeComponents = opts.excludeComponents;\n\t        var ecModel = this._model;\n\t        var excludesComponentViews = [];\n\t        var self = this;\n\t        each(excludeComponents, function (componentType) {\n\t            ecModel.eachComponent({ mainType: componentType }, function (component) {\n\t                var view = self._componentsMap[component.__viewId];\n\t                if (!view.group.ignore) {\n\t                    excludesComponentViews.push(view);\n\t                    view.group.ignore = true;\n\t                }\n\t            });\n\t        });\n\t        var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n\t        each(excludesComponentViews, function (view) {\n\t            view.group.ignore = false;\n\t        });\n\t        return url;\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getConnectedDataURL = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        var groupId = this.group;\n\t        var mathMin = Math.min;\n\t        var mathMax = Math.max;\n\t        var MAX_NUMBER = Infinity;\n\t        if (connectedGroups[groupId]) {\n\t            var left = MAX_NUMBER;\n\t            var top = MAX_NUMBER;\n\t            var right = -MAX_NUMBER;\n\t            var bottom = -MAX_NUMBER;\n\t            var canvasList = [];\n\t            var dpr = opts && opts.pixelRatio || 1;\n\t            for (var id in instances) {\n\t                var chart = instances[id];\n\t                if (chart.group === groupId) {\n\t                    var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n\t                    var boundingRect = chart.getDom().getBoundingClientRect();\n\t                    left = mathMin(boundingRect.left, left);\n\t                    top = mathMin(boundingRect.top, top);\n\t                    right = mathMax(boundingRect.right, right);\n\t                    bottom = mathMax(boundingRect.bottom, bottom);\n\t                    canvasList.push({\n\t                        dom: canvas,\n\t                        left: boundingRect.left,\n\t                        top: boundingRect.top\n\t                    });\n\t                }\n\t            }\n\t            left *= dpr;\n\t            top *= dpr;\n\t            right *= dpr;\n\t            bottom *= dpr;\n\t            var width = right - left;\n\t            var height = bottom - top;\n\t            var targetCanvas = zrUtil.createCanvas();\n\t            targetCanvas.width = width;\n\t            targetCanvas.height = height;\n\t            var zr = zrender.init(targetCanvas);\n\t            each(canvasList, function (item) {\n\t                var img = new graphic.Image({\n\t                        style: {\n\t                            x: item.left * dpr - left,\n\t                            y: item.top * dpr - top,\n\t                            image: item.dom\n\t                        }\n\t                    });\n\t                zr.add(img);\n\t            });\n\t            zr.refreshImmediately();\n\t            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n\t        } else {\n\t            return this.getDataURL(opts);\n\t        }\n\t    };\n\t    var updateMethods = {\n\t            update: function (payload) {\n\t                // console.time && console.time('update');\n\t                var ecModel = this._model;\n\t                var api = this._api;\n\t                var coordSysMgr = this._coordSysMgr;\n\t                var zr = this._zr;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                // Fixme First time update ?\n\t                ecModel.restoreData();\n\t                // TODO\n\t                // Save total ecModel here for undo/redo (after restoring data and before processing data).\n\t                // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\t                // Create new coordinate system each update\n\t                // In LineView may save the old coordinate system and use it to get the orignal point\n\t                coordSysMgr.create(this._model, this._api);\n\t                processData.call(this, ecModel, api);\n\t                stackSeriesData.call(this, ecModel);\n\t                coordSysMgr.update(ecModel, api);\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                doRender.call(this, ecModel, payload);\n\t                // Set background\n\t                var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\t                var painter = zr.painter;\n\t                // TODO all use clearColor ?\n\t                if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n\t                    zr.configLayer(0, { clearColor: backgroundColor });\n\t                } else {\n\t                    // In IE8\n\t                    if (!env.canvasSupported) {\n\t                        var colorArr = colorTool.parse(backgroundColor);\n\t                        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\t                        if (colorArr[3] === 0) {\n\t                            backgroundColor = 'transparent';\n\t                        }\n\t                    }\n\t                    if (backgroundColor.colorStops || backgroundColor.image) {\n\t                        // Gradient background\n\t                        // FIXME Fixed layer\n\t                        zr.configLayer(0, { clearColor: backgroundColor });\n\t                        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\t                        this._dom.style.background = 'transparent';\n\t                    } else {\n\t                        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n\t                            zr.configLayer(0, { clearColor: null });\n\t                        }\n\t                        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\t                        this._dom.style.background = backgroundColor;\n\t                    }\n\t                }    // console.time && console.timeEnd('update');\n\t            },\n\t            updateView: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                ecModel.eachSeries(function (seriesModel) {\n\t                    seriesModel.getData().clearAllVisual();\n\t                });\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n\t            },\n\t            updateVisual: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                ecModel.eachSeries(function (seriesModel) {\n\t                    seriesModel.getData().clearAllVisual();\n\t                });\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n\t            },\n\t            updateLayout: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                doLayout.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n\t            },\n\t            highlight: function (payload) {\n\t                toggleHighlight.call(this, 'highlight', payload);\n\t            },\n\t            downplay: function (payload) {\n\t                toggleHighlight.call(this, 'downplay', payload);\n\t            },\n\t            prepareAndUpdate: function (payload) {\n\t                var ecModel = this._model;\n\t                prepareView.call(this, 'component', ecModel);\n\t                prepareView.call(this, 'chart', ecModel);\n\t                updateMethods.update.call(this, payload);\n\t            }\n\t        };\n\t    /**\n\t     * @param {Object} payload\n\t     * @private\n\t     */\n\t    function toggleHighlight(method, payload) {\n\t        var ecModel = this._model;\n\t        // dispatchAction before setOption\n\t        if (!ecModel) {\n\t            return;\n\t        }\n\t        ecModel.eachComponent({\n\t            mainType: 'series',\n\t            query: payload\n\t        }, function (seriesModel, index) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            if (chartView && chartView.__alive) {\n\t                chartView[method](seriesModel, ecModel, this._api, payload);\n\t            }\n\t        }, this);\n\t    }\n\t    /**\n\t     * Resize the chart\n\t     */\n\t    echartsProto.resize = function () {\n\t        if (true) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        this._zr.resize();\n\t        var optionChanged = this._model && this._model.resetOption('media');\n\t        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\t        // Resize loading effect\n\t        this._loadingFX && this._loadingFX.resize();\n\t        this[IN_MAIN_PROCESS] = false;\n\t        this._flushPendingActions();\n\t    };\n\t    /**\n\t     * Show loading effect\n\t     * @param  {string} [name='default']\n\t     * @param  {Object} [cfg]\n\t     */\n\t    echartsProto.showLoading = function (name, cfg) {\n\t        if (zrUtil.isObject(name)) {\n\t            cfg = name;\n\t            name = '';\n\t        }\n\t        name = name || 'default';\n\t        this.hideLoading();\n\t        if (!loadingEffects[name]) {\n\t            if (true) {\n\t                console.warn('Loading effects ' + name + ' not exists.');\n\t            }\n\t            return;\n\t        }\n\t        var el = loadingEffects[name](this._api, cfg);\n\t        var zr = this._zr;\n\t        this._loadingFX = el;\n\t        zr.add(el);\n\t    };\n\t    /**\n\t     * Hide loading effect\n\t     */\n\t    echartsProto.hideLoading = function () {\n\t        this._loadingFX && this._zr.remove(this._loadingFX);\n\t        this._loadingFX = null;\n\t    };\n\t    /**\n\t     * @param {Object} eventObj\n\t     * @return {Object}\n\t     */\n\t    echartsProto.makeActionFromEvent = function (eventObj) {\n\t        var payload = zrUtil.extend({}, eventObj);\n\t        payload.type = eventActionMap[eventObj.type];\n\t        return payload;\n\t    };\n\t    /**\n\t     * @pubilc\n\t     * @param {Object} payload\n\t     * @param {string} [payload.type] Action type\n\t     * @param {boolean} [silent=false] Whether trigger event.\n\t     */\n\t    echartsProto.dispatchAction = function (payload, silent) {\n\t        var actionWrap = actions[payload.type];\n\t        if (!actionWrap) {\n\t            return;\n\t        }\n\t        var actionInfo = actionWrap.actionInfo;\n\t        var updateMethod = actionInfo.update || 'update';\n\t        // if (__DEV__) {\n\t        //     zrUtil.assert(\n\t        //         !this[IN_MAIN_PROCESS],\n\t        //         '`dispatchAction` should not be called during main process.'\n\t        //         + 'unless updateMathod is \"none\".'\n\t        //     );\n\t        // }\n\t        // May dispatchAction in rendering procedure\n\t        if (this[IN_MAIN_PROCESS]) {\n\t            this._pendingActions.push(payload);\n\t            return;\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        var payloads = [payload];\n\t        var batched = false;\n\t        // Batch action\n\t        if (payload.batch) {\n\t            batched = true;\n\t            payloads = zrUtil.map(payload.batch, function (item) {\n\t                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n\t                item.batch = null;\n\t                return item;\n\t            });\n\t        }\n\t        var eventObjBatch = [];\n\t        var eventObj;\n\t        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n\t        for (var i = 0; i < payloads.length; i++) {\n\t            var batchItem = payloads[i];\n\t            // Action can specify the event by return it.\n\t            eventObj = actionWrap.action(batchItem, this._model);\n\t            // Emit event outside\n\t            eventObj = eventObj || zrUtil.extend({}, batchItem);\n\t            // Convert type to eventType\n\t            eventObj.type = actionInfo.event || eventObj.type;\n\t            eventObjBatch.push(eventObj);\n\t            // Highlight and downplay are special.\n\t            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n\t        }\n\t        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n\t            // Still dirty\n\t            if (this[OPTION_UPDATED]) {\n\t                // FIXME Pass payload ?\n\t                updateMethods.prepareAndUpdate.call(this, payload);\n\t                this[OPTION_UPDATED] = false;\n\t            } else {\n\t                updateMethods[updateMethod].call(this, payload);\n\t            }\n\t        }\n\t        // Follow the rule of action batch\n\t        if (batched) {\n\t            eventObj = {\n\t                type: actionInfo.event || payload.type,\n\t                batch: eventObjBatch\n\t            };\n\t        } else {\n\t            eventObj = eventObjBatch[0];\n\t        }\n\t        this[IN_MAIN_PROCESS] = false;\n\t        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\t        this._flushPendingActions();\n\t    };\n\t    echartsProto._flushPendingActions = function () {\n\t        var pendingActions = this._pendingActions;\n\t        while (pendingActions.length) {\n\t            var payload = pendingActions.shift();\n\t            this.dispatchAction(payload);\n\t        }\n\t    };\n\t    /**\n\t     * Register event\n\t     * @method\n\t     */\n\t    echartsProto.on = createRegisterEventWithLowercaseName('on');\n\t    echartsProto.off = createRegisterEventWithLowercaseName('off');\n\t    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\t    /**\n\t     * @param {string} methodName\n\t     * @private\n\t     */\n\t    function invokeUpdateMethod(methodName, ecModel, payload) {\n\t        var api = this._api;\n\t        // Update all components\n\t        each(this._componentsViews, function (component) {\n\t            var componentModel = component.__model;\n\t            component[methodName](componentModel, ecModel, api, payload);\n\t            updateZ(componentModel, component);\n\t        }, this);\n\t        // Upate all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chart = this._chartsMap[seriesModel.__viewId];\n\t            chart[methodName](seriesModel, ecModel, api, payload);\n\t            updateZ(seriesModel, chart);\n\t            updateProgressiveAndBlend(seriesModel, chart);\n\t        }, this);\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t    }\n\t    /**\n\t     * Prepare view instances of charts and components\n\t     * @param  {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function prepareView(type, ecModel) {\n\t        var isComponent = type === 'component';\n\t        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n\t        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n\t        var zr = this._zr;\n\t        for (var i = 0; i < viewList.length; i++) {\n\t            viewList[i].__alive = false;\n\t        }\n\t        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n\t            if (isComponent) {\n\t                if (componentType === 'series') {\n\t                    return;\n\t                }\n\t            } else {\n\t                model = componentType;\n\t            }\n\t            // Consider: id same and type changed.\n\t            var viewId = model.id + '_' + model.type;\n\t            var view = viewMap[viewId];\n\t            if (!view) {\n\t                var classType = ComponentModel.parseClassType(model.type);\n\t                var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n\t                if (Clazz) {\n\t                    view = new Clazz();\n\t                    view.init(ecModel, this._api);\n\t                    viewMap[viewId] = view;\n\t                    viewList.push(view);\n\t                    zr.add(view.group);\n\t                } else {\n\t                    // Error\n\t                    return;\n\t                }\n\t            }\n\t            model.__viewId = viewId;\n\t            view.__alive = true;\n\t            view.__id = viewId;\n\t            view.__model = model;\n\t        }, this);\n\t        for (var i = 0; i < viewList.length;) {\n\t            var view = viewList[i];\n\t            if (!view.__alive) {\n\t                zr.remove(view.group);\n\t                view.dispose(ecModel, this._api);\n\t                viewList.splice(i, 1);\n\t                delete viewMap[view.__id];\n\t            } else {\n\t                i++;\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Processor data in each series\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function processData(ecModel, api) {\n\t        each(dataProcessorFuncs, function (process) {\n\t            process.func(ecModel, api);\n\t        });\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function stackSeriesData(ecModel) {\n\t        var stackedDataMap = {};\n\t        ecModel.eachSeries(function (series) {\n\t            var stack = series.get('stack');\n\t            var data = series.getData();\n\t            if (stack && data.type === 'list') {\n\t                var previousStack = stackedDataMap[stack];\n\t                if (previousStack) {\n\t                    data.stackedOn = previousStack;\n\t                }\n\t                stackedDataMap[stack] = data;\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Layout before each chart render there series, special visual encoding stage\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doLayout(ecModel, payload) {\n\t        var api = this._api;\n\t        each(visualFuncs, function (visual) {\n\t            if (visual.isLayout) {\n\t                visual.func(ecModel, api, payload);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Encode visual infomation from data after data processing\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doVisualEncoding(ecModel, payload) {\n\t        var api = this._api;\n\t        ecModel.clearColorPalette();\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            seriesModel.clearColorPalette();\n\t        });\n\t        each(visualFuncs, function (visual) {\n\t            visual.func(ecModel, api, payload);\n\t        });\n\t    }\n\t    /**\n\t     * Render each chart and component\n\t     * @private\n\t     */\n\t    function doRender(ecModel, payload) {\n\t        var api = this._api;\n\t        // Render all components\n\t        each(this._componentsViews, function (componentView) {\n\t            var componentModel = componentView.__model;\n\t            componentView.render(componentModel, ecModel, api, payload);\n\t            updateZ(componentModel, componentView);\n\t        }, this);\n\t        each(this._chartsViews, function (chart) {\n\t            chart.__alive = false;\n\t        }, this);\n\t        // Render all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            chartView.__alive = true;\n\t            chartView.render(seriesModel, ecModel, api, payload);\n\t            chartView.group.silent = !!seriesModel.get('silent');\n\t            updateZ(seriesModel, chartView);\n\t            updateProgressiveAndBlend(seriesModel, chartView);\n\t        }, this);\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t        // Remove groups of unrendered charts\n\t        each(this._chartsViews, function (chart) {\n\t            if (!chart.__alive) {\n\t                chart.remove(ecModel, api);\n\t            }\n\t        }, this);\n\t    }\n\t    var MOUSE_EVENT_NAMES = [\n\t            'click',\n\t            'dblclick',\n\t            'mouseover',\n\t            'mouseout',\n\t            'mousemove',\n\t            'mousedown',\n\t            'mouseup',\n\t            'globalout'\n\t        ];\n\t    /**\n\t     * @private\n\t     */\n\t    echartsProto._initEvents = function () {\n\t        each(MOUSE_EVENT_NAMES, function (eveName) {\n\t            this._zr.on(eveName, function (e) {\n\t                var ecModel = this.getModel();\n\t                var el = e.target;\n\t                if (el && el.dataIndex != null) {\n\t                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n\t                    params.event = e;\n\t                    params.type = eveName;\n\t                    this.trigger(eveName, params);\n\t                }    // If element has custom eventData of components\n\t                else if (el && el.eventData) {\n\t                    this.trigger(eveName, el.eventData);\n\t                }\n\t            }, this);\n\t        }, this);\n\t        each(eventActionMap, function (actionType, eventType) {\n\t            this._messageCenter.on(eventType, function (event) {\n\t                this.trigger(eventType, event);\n\t            }, this);\n\t        }, this);\n\t    };\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t    echartsProto.isDisposed = function () {\n\t        return this._disposed;\n\t    };\n\t    /**\n\t     * Clear\n\t     */\n\t    echartsProto.clear = function () {\n\t        this.setOption({ series: [] }, true);\n\t    };\n\t    /**\n\t     * Dispose instance\n\t     */\n\t    echartsProto.dispose = function () {\n\t        if (this._disposed) {\n\t            if (true) {\n\t                console.warn('Instance ' + this.id + ' has been disposed');\n\t            }\n\t            return;\n\t        }\n\t        this._disposed = true;\n\t        var api = this._api;\n\t        var ecModel = this._model;\n\t        each(this._componentsViews, function (component) {\n\t            component.dispose(ecModel, api);\n\t        });\n\t        each(this._chartsViews, function (chart) {\n\t            chart.dispose(ecModel, api);\n\t        });\n\t        // Dispose after all views disposed\n\t        this._zr.dispose();\n\t        delete instances[this.id];\n\t    };\n\t    zrUtil.mixin(ECharts, Eventful);\n\t    function updateHoverLayerStatus(zr, ecModel) {\n\t        var storage = zr.storage;\n\t        var elCount = 0;\n\t        storage.traverse(function (el) {\n\t            if (!el.isGroup) {\n\t                elCount++;\n\t            }\n\t        });\n\t        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n\t            storage.traverse(function (el) {\n\t                if (!el.isGroup) {\n\t                    el.useHoverLayer = true;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Update chart progressive and blend.\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateProgressiveAndBlend(seriesModel, chartView) {\n\t        // Progressive configuration\n\t        var elCount = 0;\n\t        chartView.group.traverse(function (el) {\n\t            if (el.type !== 'group' && !el.ignore) {\n\t                elCount++;\n\t            }\n\t        });\n\t        var frameDrawNum = +seriesModel.get('progressive');\n\t        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\t        if (needProgressive) {\n\t            chartView.group.traverse(function (el) {\n\t                // FIXME marker and other components\n\t                if (!el.isGroup) {\n\t                    el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n\t                    if (needProgressive) {\n\t                        el.stopAnimation(true);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        // Blend configration\n\t        var blendMode = seriesModel.get('blendMode') || null;\n\t        if (true) {\n\t            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n\t                console.warn('Only canvas support blendMode');\n\t            }\n\t        }\n\t        chartView.group.traverse(function (el) {\n\t            // FIXME marker and other components\n\t            if (!el.isGroup) {\n\t                el.setStyle('blend', blendMode);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateZ(model, view) {\n\t        var z = model.get('z');\n\t        var zlevel = model.get('zlevel');\n\t        // Set z and zlevel\n\t        view.group.traverse(function (el) {\n\t            if (el.type !== 'group') {\n\t                z != null && (el.z = z);\n\t                zlevel != null && (el.zlevel = zlevel);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var actions = [];\n\t    /**\n\t     * Map eventType to actionType\n\t     * @type {Object}\n\t     */\n\t    var eventActionMap = {};\n\t    /**\n\t     * Data processor functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var dataProcessorFuncs = [];\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var optionPreprocessorFuncs = [];\n\t    /**\n\t     * Visual encoding functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var visualFuncs = [];\n\t    /**\n\t     * Theme storage\n\t     * @type {Object.<key, Object>}\n\t     */\n\t    var themeStorage = {};\n\t    /**\n\t     * Loading effects\n\t     */\n\t    var loadingEffects = {};\n\t    var instances = {};\n\t    var connectedGroups = {};\n\t    var idBase = new Date() - 0;\n\t    var groupIdBase = new Date() - 0;\n\t    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\t    /**\n\t     * @alias module:echarts\n\t     */\n\t    var echarts = {\n\t            version: '3.2.3',\n\t            dependencies: { zrender: '3.1.3' }\n\t        };\n\t    function enableConnect(chart) {\n\t        var STATUS_PENDING = 0;\n\t        var STATUS_UPDATING = 1;\n\t        var STATUS_UPDATED = 2;\n\t        var STATUS_KEY = '__connectUpdateStatus';\n\t        function updateConnectedChartsStatus(charts, status) {\n\t            for (var i = 0; i < charts.length; i++) {\n\t                var otherChart = charts[i];\n\t                otherChart[STATUS_KEY] = status;\n\t            }\n\t        }\n\t        zrUtil.each(eventActionMap, function (actionType, eventType) {\n\t            chart._messageCenter.on(eventType, function (event) {\n\t                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n\t                    var action = chart.makeActionFromEvent(event);\n\t                    var otherCharts = [];\n\t                    for (var id in instances) {\n\t                        var otherChart = instances[id];\n\t                        if (otherChart !== chart && otherChart.group === chart.group) {\n\t                            otherCharts.push(otherChart);\n\t                        }\n\t                    }\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n\t                    each(otherCharts, function (otherChart) {\n\t                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n\t                            otherChart.dispatchAction(action);\n\t                        }\n\t                    });\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n\t                }\n\t            });\n\t        });\n\t    }\n\t    /**\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} [theme]\n\t     * @param {Object} opts\n\t     */\n\t    echarts.init = function (dom, theme, opts) {\n\t        if (true) {\n\t            // Check version\n\t            if (zrender.version.replace('.', '') - 0 < echarts.dependencies.zrender.replace('.', '') - 0) {\n\t                throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');\n\t            }\n\t            if (!dom) {\n\t                throw new Error('Initialize failed: invalid dom.');\n\t            }\n\t            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n\t                console.warn('Can\\'t get dom width or height');\n\t            }\n\t        }\n\t        var chart = new ECharts(dom, theme, opts);\n\t        chart.id = 'ec_' + idBase++;\n\t        instances[chart.id] = chart;\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\t        enableConnect(chart);\n\t        return chart;\n\t    };\n\t    /**\n\t     * @return {string|Array.<module:echarts~ECharts>} groupId\n\t     */\n\t    echarts.connect = function (groupId) {\n\t        // Is array of charts\n\t        if (zrUtil.isArray(groupId)) {\n\t            var charts = groupId;\n\t            groupId = null;\n\t            // If any chart has group\n\t            zrUtil.each(charts, function (chart) {\n\t                if (chart.group != null) {\n\t                    groupId = chart.group;\n\t                }\n\t            });\n\t            groupId = groupId || 'g_' + groupIdBase++;\n\t            zrUtil.each(charts, function (chart) {\n\t                chart.group = groupId;\n\t            });\n\t        }\n\t        connectedGroups[groupId] = true;\n\t        return groupId;\n\t    };\n\t    /**\n\t     * @return {string} groupId\n\t     */\n\t    echarts.disConnect = function (groupId) {\n\t        connectedGroups[groupId] = false;\n\t    };\n\t    /**\n\t     * Dispose a chart instance\n\t     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n\t     */\n\t    echarts.dispose = function (chart) {\n\t        if (zrUtil.isDom(chart)) {\n\t            chart = echarts.getInstanceByDom(chart);\n\t        } else if (typeof chart === 'string') {\n\t            chart = instances[chart];\n\t        }\n\t        if (chart instanceof ECharts && !chart.isDisposed()) {\n\t            chart.dispose();\n\t        }\n\t    };\n\t    /**\n\t     * @param  {HTMLDomElement} dom\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceByDom = function (dom) {\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * @param {string} key\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceById = function (key) {\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * Register theme\n\t     */\n\t    echarts.registerTheme = function (name, theme) {\n\t        themeStorage[name] = theme;\n\t    };\n\t    /**\n\t     * Register option preprocessor\n\t     * @param {Function} preprocessorFunc\n\t     */\n\t    echarts.registerPreprocessor = function (preprocessorFunc) {\n\t        optionPreprocessorFuncs.push(preprocessorFunc);\n\t    };\n\t    /**\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} processorFunc\n\t     */\n\t    echarts.registerProcessor = function (priority, processorFunc) {\n\t        if (typeof priority === 'function') {\n\t            processorFunc = priority;\n\t            priority = PRIORITY_PROCESSOR_FILTER;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown processor priority');\n\t            }\n\t        }\n\t        dataProcessorFuncs.push({\n\t            prio: priority,\n\t            func: processorFunc\n\t        });\n\t    };\n\t    /**\n\t     * Usage:\n\t     * registerAction('someAction', 'someEvent', function () { ... });\n\t     * registerAction('someAction', function () { ... });\n\t     * registerAction(\n\t     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n\t     *     function () { ... }\n\t     * );\n\t     *\n\t     * @param {(string|Object)} actionInfo\n\t     * @param {string} actionInfo.type\n\t     * @param {string} [actionInfo.event]\n\t     * @param {string} [actionInfo.update]\n\t     * @param {string} [eventName]\n\t     * @param {Function} action\n\t     */\n\t    echarts.registerAction = function (actionInfo, eventName, action) {\n\t        if (typeof eventName === 'function') {\n\t            action = eventName;\n\t            eventName = '';\n\t        }\n\t        var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [\n\t                actionInfo,\n\t                actionInfo = { event: eventName }\n\t            ][0];\n\t        // Event name is all lowercase\n\t        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n\t        eventName = actionInfo.event;\n\t        if (!actions[actionType]) {\n\t            actions[actionType] = {\n\t                action: action,\n\t                actionInfo: actionInfo\n\t            };\n\t        }\n\t        eventActionMap[eventName] = actionType;\n\t    };\n\t    /**\n\t     * @param {string} type\n\t     * @param {*} CoordinateSystem\n\t     */\n\t    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n\t        CoordinateSystemManager.register(type, CoordinateSystem);\n\t    };\n\t    /**\n\t     * Layout is a special stage of visual encoding\n\t     * Most visual encoding like color are common for different chart\n\t     * But each chart has it's own layout algorithm\n\t     *\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} layoutFunc\n\t     */\n\t    echarts.registerLayout = function (priority, layoutFunc) {\n\t        if (typeof priority === 'function') {\n\t            layoutFunc = priority;\n\t            priority = PRIORITY_VISUAL_LAYOUT;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown layout priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: layoutFunc,\n\t            isLayout: true\n\t        });\n\t    };\n\t    /**\n\t     * @param {number} [priority=3000]\n\t     * @param {Function} visualFunc\n\t     */\n\t    echarts.registerVisual = function (priority, visualFunc) {\n\t        if (typeof priority === 'function') {\n\t            visualFunc = priority;\n\t            priority = PRIORITY_VISUAL_CHART;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown visual priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: visualFunc\n\t        });\n\t    };\n\t    /**\n\t     * @param {string} name\n\t     */\n\t    echarts.registerLoading = function (name, loadingFx) {\n\t        loadingEffects[name] = loadingFx;\n\t    };\n\t    var parseClassType = ComponentModel.parseClassType;\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentModel = function (opts, superClass) {\n\t        var Clazz = ComponentModel;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentView = function (opts, superClass) {\n\t        var Clazz = ComponentView;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendSeriesModel = function (opts, superClass) {\n\t        var Clazz = SeriesModel;\n\t        if (superClass) {\n\t            superClass = 'series.' + superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendChartView = function (opts, superClass) {\n\t        var Clazz = ChartView;\n\t        if (superClass) {\n\t            superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ChartView.getClass(classType.main, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * ZRender need a canvas context to do measureText.\n\t     * But in node environment canvas may be created by node-canvas.\n\t     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n\t     *\n\t     * Be careful of using it in the browser.\n\t     *\n\t     * @param {Function} creator\n\t     * @example\n\t     *     var Canvas = require('canvas');\n\t     *     var echarts = require('echarts');\n\t     *     echarts.setCanvasCreator(function () {\n\t     *         // Small size is enough.\n\t     *         return new Canvas(32, 32);\n\t     *     });\n\t     */\n\t    echarts.setCanvasCreator = function (creator) {\n\t        zrUtil.createCanvas = creator;\n\t    };\n\t    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n\t    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n\t    echarts.registerLoading('default', require('./loading/default'));\n\t    // Default action\n\t    echarts.registerAction({\n\t        type: 'highlight',\n\t        event: 'highlight',\n\t        update: 'highlight'\n\t    }, zrUtil.noop);\n\t    echarts.registerAction({\n\t        type: 'downplay',\n\t        event: 'downplay',\n\t        update: 'downplay'\n\t    }, zrUtil.noop);\n\t    // --------\n\t    // Exports\n\t    // --------\n\t    //\n\t    echarts.List = require('./data/List');\n\t    echarts.Model = require('./model/Model');\n\t    echarts.graphic = require('./util/graphic');\n\t    echarts.number = require('./util/number');\n\t    echarts.format = require('./util/format');\n\t    echarts.matrix = require('zrender/core/matrix');\n\t    echarts.vector = require('zrender/core/vector');\n\t    echarts.color = require('zrender/tool/color');\n\t    echarts.util = {};\n\t    each([\n\t        'map',\n\t        'each',\n\t        'filter',\n\t        'indexOf',\n\t        'inherits',\n\t        'reduce',\n\t        'filter',\n\t        'bind',\n\t        'curry',\n\t        'isArray',\n\t        'isString',\n\t        'isObject',\n\t        'isFunction',\n\t        'extend',\n\t        'defaults'\n\t    ], function (name) {\n\t        echarts.util[name] = zrUtil[name];\n\t    });\n\t    // PRIORITY\n\t    echarts.PRIORITY = {\n\t        PROCESSOR: {\n\t            FILTER: PRIORITY_PROCESSOR_FILTER,\n\t            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n\t        },\n\t        VISUAL: {\n\t            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n\t            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n\t            CHART: PRIORITY_VISUAL_CHART,\n\t            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n\t            BRUSH: PRIORITY_VISUAL_BRUSH\n\t        }\n\t    };\n\t    return echarts;\n\t});\n\tdefine('echarts/scale/Log', ['require', 'zrender/core/util', './Scale', '../util/number', './Interval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Scale = require('./Scale');\n\t    var numberUtil = require('../util/number');\n\t    // Use some method of IntervalScale\n\t    var IntervalScale = require('./Interval');\n\t    var scaleProto = Scale.prototype;\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var mathPow = Math.pow;\n\t    var mathLog = Math.log;\n\t    var LogScale = Scale.extend({\n\t            type: 'log',\n\t            base: 10,\n\t            getTicks: function () {\n\t                return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n\t                    return numberUtil.round(mathPow(this.base, val));\n\t                }, this);\n\t            },\n\t            getLabel: intervalScaleProto.getLabel,\n\t            scale: function (val) {\n\t                val = scaleProto.scale.call(this, val);\n\t                return mathPow(this.base, val);\n\t            },\n\t            setExtent: function (start, end) {\n\t                var base = this.base;\n\t                start = mathLog(start) / mathLog(base);\n\t                end = mathLog(end) / mathLog(base);\n\t                intervalScaleProto.setExtent.call(this, start, end);\n\t            },\n\t            getExtent: function () {\n\t                var base = this.base;\n\t                var extent = scaleProto.getExtent.call(this);\n\t                extent[0] = mathPow(base, extent[0]);\n\t                extent[1] = mathPow(base, extent[1]);\n\t                return extent;\n\t            },\n\t            unionExtent: function (extent) {\n\t                var base = this.base;\n\t                extent[0] = mathLog(extent[0]) / mathLog(base);\n\t                extent[1] = mathLog(extent[1]) / mathLog(base);\n\t                scaleProto.unionExtent.call(this, extent);\n\t            },\n\t            niceTicks: function (approxTickNum) {\n\t                approxTickNum = approxTickNum || 10;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                if (span === Infinity || span <= 0) {\n\t                    return;\n\t                }\n\t                var interval = numberUtil.quantity(span);\n\t                var err = approxTickNum / span * interval;\n\t                // Filter ticks to get closer to the desired count.\n\t                if (err <= 0.5) {\n\t                    interval *= 10;\n\t                }\n\t                // Interval should be integer\n\t                while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n\t                    interval *= 10;\n\t                }\n\t                var niceExtent = [\n\t                        numberUtil.round(mathCeil(extent[0] / interval) * interval),\n\t                        numberUtil.round(mathFloor(extent[1] / interval) * interval)\n\t                    ];\n\t                this._interval = interval;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            niceExtent: intervalScaleProto.niceExtent\n\t        });\n\t    zrUtil.each([\n\t        'contain',\n\t        'normalize'\n\t    ], function (methodName) {\n\t        LogScale.prototype[methodName] = function (val) {\n\t            val = mathLog(val) / mathLog(this.base);\n\t            return scaleProto[methodName].call(this, val);\n\t        };\n\t    });\n\t    LogScale.create = function () {\n\t        return new LogScale();\n\t    };\n\t    return LogScale;\n\t});\n\tdefine('echarts/chart/pie/PieView', ['require', '../../util/graphic', 'zrender/core/util', '../../view/Chart'], function (require) {\n\t    var graphic = require('../../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    /**\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n\t        var data = seriesModel.getData();\n\t        var dataIndex = this.dataIndex;\n\t        var name = data.getName(dataIndex);\n\t        var selectedOffset = seriesModel.get('selectedOffset');\n\t        api.dispatchAction({\n\t            type: 'pieToggleSelect',\n\t            from: uid,\n\t            name: name,\n\t            seriesId: seriesModel.id\n\t        });\n\t        data.each(function (idx) {\n\t            toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:zrender/graphic/Sector} el\n\t     * @param {Object} layout\n\t     * @param {boolean} isSelected\n\t     * @param {number} selectedOffset\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n\t        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t        var dx = Math.cos(midAngle);\n\t        var dy = Math.sin(midAngle);\n\t        var offset = isSelected ? selectedOffset : 0;\n\t        var position = [\n\t                dx * offset,\n\t                dy * offset\n\t            ];\n\t        hasAnimation ? el.animate().when(200, { position: position }).start('bounceOut') : el.attr('position', position);\n\t    }\n\t    /**\n\t     * Piece of pie including Sector, Label, LabelLine\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function PiePiece(data, idx) {\n\t        graphic.Group.call(this);\n\t        var sector = new graphic.Sector({ z2: 2 });\n\t        var polyline = new graphic.Polyline();\n\t        var text = new graphic.Text();\n\t        this.add(sector);\n\t        this.add(polyline);\n\t        this.add(text);\n\t        this.updateData(data, idx, true);\n\t        // Hover to change label and labelLine\n\t        function onEmphasis() {\n\t            polyline.ignore = polyline.hoverIgnore;\n\t            text.ignore = text.hoverIgnore;\n\t        }\n\t        function onNormal() {\n\t            polyline.ignore = polyline.normalIgnore;\n\t            text.ignore = text.normalIgnore;\n\t        }\n\t        this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n\t    }\n\t    var piePieceProto = PiePiece.prototype;\n\t    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t        return {\n\t            fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n\t            opacity: data.getItemVisual(idx, 'opacity'),\n\t            textFont: textStyleModel.getFont(),\n\t            text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))\n\t        };\n\t    }\n\t    piePieceProto.updateData = function (data, idx, firstCreate) {\n\t        var sector = this.childAt(0);\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var sectorShape = zrUtil.extend({}, layout);\n\t        sectorShape.label = null;\n\t        if (firstCreate) {\n\t            sector.setShape(sectorShape);\n\t            sector.shape.endAngle = layout.startAngle;\n\t            graphic.updateProps(sector, { shape: { endAngle: layout.endAngle } }, seriesModel, idx);\n\t        } else {\n\t            graphic.updateProps(sector, { shape: sectorShape }, seriesModel, idx);\n\t        }\n\t        // Update common style\n\t        var itemStyleModel = itemModel.getModel('itemStyle');\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t        sector.useStyle(zrUtil.defaults({\n\t            lineJoin: 'bevel',\n\t            fill: visualColor\n\t        }, itemStyleModel.getModel('normal').getItemStyle()));\n\t        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\t        // Toggle selected\n\t        toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\t        function onEmphasis() {\n\t            // Sector may has animation of updating data. Force to move to the last frame\n\t            // Or it may stopped on the wrong shape\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({ shape: { r: layout.r + 10 } }, 300, 'elasticOut');\n\t        }\n\t        function onNormal() {\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({ shape: { r: layout.r } }, 300, 'elasticOut');\n\t        }\n\t        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\t        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n\t            sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n\t        }\n\t        this._updateLabel(data, idx);\n\t        graphic.setHoverStyle(this);\n\t    };\n\t    piePieceProto._updateLabel = function (data, idx) {\n\t        var labelLine = this.childAt(1);\n\t        var labelText = this.childAt(2);\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var labelLayout = layout.label;\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t        graphic.updateProps(labelLine, {\n\t            shape: {\n\t                points: labelLayout.linePoints || [\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ],\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ],\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ]\n\t                ]\n\t            }\n\t        }, seriesModel, idx);\n\t        graphic.updateProps(labelText, {\n\t            style: {\n\t                x: labelLayout.x,\n\t                y: labelLayout.y\n\t            }\n\t        }, seriesModel, idx);\n\t        labelText.attr({\n\t            style: {\n\t                textVerticalAlign: labelLayout.verticalAlign,\n\t                textAlign: labelLayout.textAlign,\n\t                textFont: labelLayout.font\n\t            },\n\t            rotation: labelLayout.rotation,\n\t            origin: [\n\t                labelLayout.x,\n\t                labelLayout.y\n\t            ],\n\t            z2: 10\n\t        });\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var labelHoverModel = itemModel.getModel('label.emphasis');\n\t        var labelLineModel = itemModel.getModel('labelLine.normal');\n\t        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\t        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\t        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\t        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n\t        labelText.hoverIgnore = !labelHoverModel.get('show');\n\t        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n\t        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\t        // Default use item visual color\n\t        labelLine.setStyle({\n\t            stroke: visualColor,\n\t            opacity: data.getItemVisual(idx, 'opacity')\n\t        });\n\t        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\t        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n\t        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\t        var smooth = labelLineModel.get('smooth');\n\t        if (smooth && smooth === true) {\n\t            smooth = 0.4;\n\t        }\n\t        labelLine.setShape({ smooth: smooth });\n\t    };\n\t    zrUtil.inherits(PiePiece, graphic.Group);\n\t    // Pie view\n\t    var Pie = require('../../view/Chart').extend({\n\t            type: 'pie',\n\t            init: function () {\n\t                var sectorGroup = new graphic.Group();\n\t                this._sectorGroup = sectorGroup;\n\t            },\n\t            render: function (seriesModel, ecModel, api, payload) {\n\t                if (payload && payload.from === this.uid) {\n\t                    return;\n\t                }\n\t                var data = seriesModel.getData();\n\t                var oldData = this._data;\n\t                var group = this.group;\n\t                var hasAnimation = ecModel.get('animation');\n\t                var isFirstRender = !oldData;\n\t                var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n\t                var selectedMode = seriesModel.get('selectedMode');\n\t                data.diff(oldData).add(function (idx) {\n\t                    var piePiece = new PiePiece(data, idx);\n\t                    if (isFirstRender) {\n\t                        piePiece.eachChild(function (child) {\n\t                            child.stopAnimation(true);\n\t                        });\n\t                    }\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    data.setItemGraphicEl(idx, piePiece);\n\t                    group.add(piePiece);\n\t                }).update(function (newIdx, oldIdx) {\n\t                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\t                    piePiece.updateData(data, newIdx);\n\t                    piePiece.off('click');\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    group.add(piePiece);\n\t                    data.setItemGraphicEl(newIdx, piePiece);\n\t                }).remove(function (idx) {\n\t                    var piePiece = oldData.getItemGraphicEl(idx);\n\t                    group.remove(piePiece);\n\t                }).execute();\n\t                if (hasAnimation && isFirstRender && data.count() > 0) {\n\t                    var shape = data.getItemLayout(0);\n\t                    var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\t                    var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n\t                    group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n\t                }\n\t                this._data = data;\n\t            },\n\t            _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n\t                var clipPath = new graphic.Sector({\n\t                        shape: {\n\t                            cx: cx,\n\t                            cy: cy,\n\t                            r0: 0,\n\t                            r: r,\n\t                            startAngle: startAngle,\n\t                            endAngle: startAngle,\n\t                            clockwise: clockwise\n\t                        }\n\t                    });\n\t                graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb);\n\t                return clipPath;\n\t            }\n\t        });\n\t    return Pie;\n\t});\n\tdefine('echarts/chart/pie/PieSeries', ['require', '../../data/List', 'zrender/core/util', '../../util/model', '../../data/helper/completeDimensions', '../../component/helper/selectableMixin', '../../echarts'], function (require) {\n\t    'use strict';\n\t    var List = require('../../data/List');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../../util/model');\n\t    var completeDimensions = require('../../data/helper/completeDimensions');\n\t    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\t    var PieSeries = require('../../echarts').extendSeriesModel({\n\t            type: 'series.pie',\n\t            init: function (option) {\n\t                PieSeries.superApply(this, 'init', arguments);\n\t                // Enable legend selection for each data item\n\t                // Use a function instead of direct access because data reference may changed\n\t                this.legendDataProvider = function () {\n\t                    return this._dataBeforeProcessed;\n\t                };\n\t                this.updateSelectedMap(option.data);\n\t                this._defaultLabelLine(option);\n\t            },\n\t            mergeOption: function (newOption) {\n\t                PieSeries.superCall(this, 'mergeOption', newOption);\n\t                this.updateSelectedMap(this.option.data);\n\t            },\n\t            getInitialData: function (option, ecModel) {\n\t                var dimensions = completeDimensions(['value'], option.data);\n\t                var list = new List(dimensions, this);\n\t                list.initData(option.data);\n\t                return list;\n\t            },\n\t            getDataParams: function (dataIndex) {\n\t                var data = this._data;\n\t                var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n\t                var sum = data.getSum('value');\n\t                // FIXME toFixed?\n\t                //\n\t                // Percent is 0 if sum is 0\n\t                params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\t                params.$vars.push('percent');\n\t                return params;\n\t            },\n\t            _defaultLabelLine: function (option) {\n\t                // Extend labelLine emphasis\n\t                modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\t                var labelLineNormalOpt = option.labelLine.normal;\n\t                var labelLineEmphasisOpt = option.labelLine.emphasis;\n\t                // Not show label line if `label.normal.show = false`\n\t                labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;\n\t                labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;\n\t            },\n\t            defaultOption: {\n\t                zlevel: 0,\n\t                z: 2,\n\t                legendHoverLink: true,\n\t                hoverAnimation: true,\n\t                center: [\n\t                    '50%',\n\t                    '50%'\n\t                ],\n\t                radius: [\n\t                    0,\n\t                    '75%'\n\t                ],\n\t                clockwise: true,\n\t                startAngle: 90,\n\t                minAngle: 0,\n\t                selectedOffset: 10,\n\t                avoidLabelOverlap: true,\n\t                label: {\n\t                    normal: {\n\t                        rotate: false,\n\t                        show: true,\n\t                        position: 'outer'\n\t                    },\n\t                    emphasis: {}\n\t                },\n\t                labelLine: {\n\t                    normal: {\n\t                        show: true,\n\t                        length: 15,\n\t                        length2: 15,\n\t                        smooth: false,\n\t                        lineStyle: {\n\t                            width: 1,\n\t                            type: 'solid'\n\t                        }\n\t                    }\n\t                },\n\t                itemStyle: {\n\t                    normal: { borderWidth: 1 },\n\t                    emphasis: {}\n\t                },\n\t                animationEasing: 'cubicOut',\n\t                data: []\n\t            }\n\t        });\n\t    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\t    return PieSeries;\n\t});\n\tdefine('echarts/action/createDataSelectAction', ['require', '../echarts', 'zrender/core/util'], function (require) {\n\t    var echarts = require('../echarts');\n\t    var zrUtil = require('zrender/core/util');\n\t    return function (seriesType, actionInfos) {\n\t        zrUtil.each(actionInfos, function (actionInfo) {\n\t            actionInfo.update = 'updateView';\n\t            /**\n\t             * @payload\n\t             * @property {string} seriesName\n\t             * @property {string} name\n\t             */\n\t            echarts.registerAction(actionInfo, function (payload, ecModel) {\n\t                var selected = {};\n\t                ecModel.eachComponent({\n\t                    mainType: 'series',\n\t                    subType: seriesType,\n\t                    query: payload\n\t                }, function (seriesModel) {\n\t                    if (seriesModel[actionInfo.method]) {\n\t                        seriesModel[actionInfo.method](payload.name);\n\t                    }\n\t                    var data = seriesModel.getData();\n\t                    // Create selected map\n\t                    data.each(function (idx) {\n\t                        var name = data.getName(idx);\n\t                        selected[name] = seriesModel.isSelected(name) || false;\n\t                    });\n\t                });\n\t                return {\n\t                    name: payload.name,\n\t                    selected: selected\n\t                };\n\t            });\n\t        });\n\t    };\n\t});\n\tdefine('zrender/core/util', ['require'], function (require) {\n\t    // mergeDate\n\t    var BUILTIN_OBJECT = {\n\t            '[object Function]': 1,\n\t            '[object RegExp]': 1,\n\t            '[object Date]': 1,\n\t            '[object Error]': 1,\n\t            '[object CanvasGradient]': 1,\n\t            '[object CanvasPattern]': 1,\n\t            '[object Image]': 1\n\t        };\n\t    var objToString = Object.prototype.toString;\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t    /**\n\t     * @param {*} source\n\t     * @return {*} \n\t     */\n\t    function clone(source) {\n\t        if (typeof source == 'object' && source !== null) {\n\t            var result = source;\n\t            if (source instanceof Array) {\n\t                result = [];\n\t                for (var i = 0, len = source.length; i < len; i++) {\n\t                    result[i] = clone(source[i]);\n\t                }\n\t            } else if (!isBuildInObject(source) && !isDom(source)) {\n\t                result = {};\n\t                for (var key in source) {\n\t                    if (source.hasOwnProperty(key)) {\n\t                        result[key] = clone(source[key]);\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t        return source;\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t                if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {\n\t                    // merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                } else if (overwrite || !(key in target)) {\n\t                    // overwritetrue\n\t                    // NOTE target[key] \n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t    /**\n\t     * index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t    /**\n\t     * \n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz \n\t     * @param {Function} baseClazz \n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {\n\t        }\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t        defaults(target, source, overlay);\n\t    }\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (!data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        } else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        } else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        } else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        } else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        } else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || !!value && type == 'object';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return value && value.nodeType === 1 && typeof value.nodeName == 'string';\n\t    }\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t    var util = {\n\t            inherits: inherits,\n\t            mixin: mixin,\n\t            clone: clone,\n\t            merge: merge,\n\t            mergeAll: mergeAll,\n\t            extend: extend,\n\t            defaults: defaults,\n\t            getContext: getContext,\n\t            createCanvas: createCanvas,\n\t            indexOf: indexOf,\n\t            slice: slice,\n\t            find: find,\n\t            isArrayLike: isArrayLike,\n\t            each: each,\n\t            map: map,\n\t            reduce: reduce,\n\t            filter: filter,\n\t            bind: bind,\n\t            curry: curry,\n\t            isArray: isArray,\n\t            isString: isString,\n\t            isObject: isObject,\n\t            isFunction: isFunction,\n\t            isBuildInObject: isBuildInObject,\n\t            isDom: isDom,\n\t            retrieve: retrieve,\n\t            assert: assert,\n\t            noop: function () {\n\t            }\n\t        };\n\t    return util;\n\t});\n\tdefine('echarts/visual/dataColor', ['require'], function (require) {\n\t    return function (seriesType, ecModel) {\n\t        // Pie and funnel may use diferrent scope\n\t        var paletteScope = {};\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var dataAll = seriesModel.getRawData();\n\t            var idxMap = {};\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                var data = seriesModel.getData();\n\t                data.each(function (idx) {\n\t                    var rawIdx = data.getRawIndex(idx);\n\t                    idxMap[rawIdx] = idx;\n\t                });\n\t                dataAll.each(function (rawIdx) {\n\t                    // FIXME Performance\n\t                    var itemModel = dataAll.getItemModel(rawIdx);\n\t                    var filteredIdx = idxMap[rawIdx];\n\t                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\t                    var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\t                    if (!singleDataColor) {\n\t                        var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n\t                        // Legend may use the visual info in data before processed\n\t                        dataAll.setItemVisual(rawIdx, 'color', color);\n\t                        // Data is not filtered\n\t                        if (filteredIdx != null) {\n\t                            data.setItemVisual(filteredIdx, 'color', color);\n\t                        }\n\t                    } else {\n\t                        // Set data all color for legend\n\t                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\t});\n\tdefine('echarts/chart/pie/pieLayout', ['require', '../../util/number', './labelLayout', 'zrender/core/util'], function (require) {\n\t    var numberUtil = require('../../util/number');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var labelLayout = require('./labelLayout');\n\t    var zrUtil = require('zrender/core/util');\n\t    var PI2 = Math.PI * 2;\n\t    var RADIAN = Math.PI / 180;\n\t    return function (seriesType, ecModel, api, payload) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var center = seriesModel.get('center');\n\t            var radius = seriesModel.get('radius');\n\t            if (!zrUtil.isArray(radius)) {\n\t                radius = [\n\t                    0,\n\t                    radius\n\t                ];\n\t            }\n\t            if (!zrUtil.isArray(center)) {\n\t                center = [\n\t                    center,\n\t                    center\n\t                ];\n\t            }\n\t            var width = api.getWidth();\n\t            var height = api.getHeight();\n\t            var size = Math.min(width, height);\n\t            var cx = parsePercent(center[0], width);\n\t            var cy = parsePercent(center[1], height);\n\t            var r0 = parsePercent(radius[0], size / 2);\n\t            var r = parsePercent(radius[1], size / 2);\n\t            var data = seriesModel.getData();\n\t            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\t            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\t            var sum = data.getSum('value');\n\t            // Sum may be 0\n\t            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\t            var clockwise = seriesModel.get('clockwise');\n\t            var roseType = seriesModel.get('roseType');\n\t            // [0...max]\n\t            var extent = data.getDataExtent('value');\n\t            extent[0] = 0;\n\t            // In the case some sector angle is smaller than minAngle\n\t            var restAngle = PI2;\n\t            var valueSumLargerThanMinAngle = 0;\n\t            var currentAngle = startAngle;\n\t            var dir = clockwise ? 1 : -1;\n\t            data.each('value', function (value, idx) {\n\t                var angle;\n\t                // FIXME  2.0  roseType  area \n\t                if (roseType !== 'area') {\n\t                    angle = sum === 0 ? unitRadian : value * unitRadian;\n\t                } else {\n\t                    angle = PI2 / (data.count() || 1);\n\t                }\n\t                if (angle < minAngle) {\n\t                    angle = minAngle;\n\t                    restAngle -= minAngle;\n\t                } else {\n\t                    valueSumLargerThanMinAngle += value;\n\t                }\n\t                var endAngle = currentAngle + dir * angle;\n\t                data.setItemLayout(idx, {\n\t                    angle: angle,\n\t                    startAngle: currentAngle,\n\t                    endAngle: endAngle,\n\t                    clockwise: clockwise,\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: r0,\n\t                    r: roseType ? numberUtil.linearMap(value, extent, [\n\t                        r0,\n\t                        r\n\t                    ]) : r\n\t                });\n\t                currentAngle = endAngle;\n\t            }, true);\n\t            // Some sector is constrained by minAngle\n\t            // Rest sectors needs recalculate angle\n\t            if (restAngle < PI2) {\n\t                // Average the angle if rest angle is not enough after all angles is\n\t                // Constrained by minAngle\n\t                if (restAngle <= 0.001) {\n\t                    var angle = PI2 / data.count();\n\t                    data.each(function (idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        layout.startAngle = startAngle + dir * idx * angle;\n\t                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n\t                    });\n\t                } else {\n\t                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n\t                    currentAngle = startAngle;\n\t                    data.each('value', function (value, idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n\t                        layout.startAngle = currentAngle;\n\t                        layout.endAngle = currentAngle + dir * angle;\n\t                        currentAngle += angle;\n\t                    });\n\t                }\n\t            }\n\t            labelLayout(seriesModel, r, width, height);\n\t        });\n\t    };\n\t});\n\tdefine('echarts/processor/dataFilter', [], function () {\n\t    return function (seriesType, ecModel) {\n\t        var legendModels = ecModel.findComponents({ mainType: 'legend' });\n\t        if (!legendModels || !legendModels.length) {\n\t            return;\n\t        }\n\t        ecModel.eachSeriesByType(seriesType, function (series) {\n\t            var data = series.getData();\n\t            data.filterSelf(function (idx) {\n\t                var name = data.getName(idx);\n\t                // If in any legend component the status is not selected.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }, this);\n\t        }, this);\n\t    };\n\t});\n\tdefine('echarts/coord/cartesian/Grid', ['require', 'exports', '../../util/layout', '../../coord/axisHelper', 'zrender/core/util', './Cartesian2D', './Axis2D', './GridModel', '../../CoordinateSystem'], function (require, factory) {\n\t    var layout = require('../../util/layout');\n\t    var axisHelper = require('../../coord/axisHelper');\n\t    var zrUtil = require('zrender/core/util');\n\t    var Cartesian2D = require('./Cartesian2D');\n\t    var Axis2D = require('./Axis2D');\n\t    var each = zrUtil.each;\n\t    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n\t    var niceScaleExtent = axisHelper.niceScaleExtent;\n\t    //  GridModel, AxisModel \n\t    require('./GridModel');\n\t    /**\n\t     * Check if the axis is used in the specified grid\n\t     * @inner\n\t     */\n\t    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n\t        return axisModel.findGridModel() === gridModel;\n\t    }\n\t    function getLabelUnionRect(axis) {\n\t        var axisModel = axis.model;\n\t        var labels = axisModel.getFormattedLabels();\n\t        var rect;\n\t        var step = 1;\n\t        var labelCount = labels.length;\n\t        if (labelCount > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.ceil(labelCount / 40);\n\t        }\n\t        for (var i = 0; i < labelCount; i += step) {\n\t            if (!axis.isLabelIgnored(i)) {\n\t                var singleRect = axisModel.getTextRect(labels[i]);\n\t                // FIXME consider label rotate\n\t                rect ? rect.union(singleRect) : rect = singleRect;\n\t            }\n\t        }\n\t        return rect;\n\t    }\n\t    function Grid(gridModel, ecModel, api) {\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n\t         * @private\n\t         */\n\t        this._coordsMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n\t         * @private\n\t         */\n\t        this._coordsList = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesList = [];\n\t        this._initCartesian(gridModel, ecModel, api);\n\t        this._model = gridModel;\n\t    }\n\t    var gridProto = Grid.prototype;\n\t    gridProto.type = 'grid';\n\t    gridProto.getRect = function () {\n\t        return this._rect;\n\t    };\n\t    gridProto.update = function (ecModel, api) {\n\t        var axesMap = this._axesMap;\n\t        this._updateScale(ecModel, this._model);\n\t        function ifAxisCanNotOnZero(otherAxisDim) {\n\t            var axes = axesMap[otherAxisDim];\n\t            for (var idx in axes) {\n\t                var axis = axes[idx];\n\t                if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t        each(axesMap.x, function (xAxis) {\n\t            niceScaleExtent(xAxis, xAxis.model);\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            niceScaleExtent(yAxis, yAxis.model);\n\t        });\n\t        // Fix configuration\n\t        each(axesMap.x, function (xAxis) {\n\t            // onZero can not be enabled in these two situations\n\t            // 1. When any other axis is a category axis\n\t            // 2. When any other axis not across 0 point\n\t            if (ifAxisCanNotOnZero('y')) {\n\t                xAxis.onZero = false;\n\t            }\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            if (ifAxisCanNotOnZero('x')) {\n\t                yAxis.onZero = false;\n\t            }\n\t        });\n\t        // Resize again if containLabel is enabled\n\t        // FIXME It may cause getting wrong grid size in data processing stage\n\t        this.resize(this._model, api);\n\t    };\n\t    /**\n\t     * Resize the grid\n\t     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    gridProto.resize = function (gridModel, api) {\n\t        var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        this._rect = gridRect;\n\t        var axesList = this._axesList;\n\t        adjustAxes();\n\t        // Minus label size\n\t        if (gridModel.get('containLabel')) {\n\t            each(axesList, function (axis) {\n\t                if (!axis.model.get('axisLabel.inside')) {\n\t                    var labelUnionRect = getLabelUnionRect(axis);\n\t                    if (labelUnionRect) {\n\t                        var dim = axis.isHorizontal() ? 'height' : 'width';\n\t                        var margin = axis.model.get('axisLabel.margin');\n\t                        gridRect[dim] -= labelUnionRect[dim] + margin;\n\t                        if (axis.position === 'top') {\n\t                            gridRect.y += labelUnionRect.height + margin;\n\t                        } else if (axis.position === 'left') {\n\t                            gridRect.x += labelUnionRect.width + margin;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t            adjustAxes();\n\t        }\n\t        function adjustAxes() {\n\t            each(axesList, function (axis) {\n\t                var isHorizontal = axis.isHorizontal();\n\t                var extent = isHorizontal ? [\n\t                        0,\n\t                        gridRect.width\n\t                    ] : [\n\t                        0,\n\t                        gridRect.height\n\t                    ];\n\t                var idx = axis.inverse ? 1 : 0;\n\t                axis.setExtent(extent[idx], extent[1 - idx]);\n\t                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * @param {string} axisType\n\t     * @param {ndumber} [axisIndex]\n\t     */\n\t    gridProto.getAxis = function (axisType, axisIndex) {\n\t        var axesMapOnDim = this._axesMap[axisType];\n\t        if (axesMapOnDim != null) {\n\t            if (axisIndex == null) {\n\t                // Find first axis\n\t                for (var name in axesMapOnDim) {\n\t                    return axesMapOnDim[name];\n\t                }\n\t            }\n\t            return axesMapOnDim[axisIndex];\n\t        }\n\t    };\n\t    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n\t        if (xAxisIndex != null && yAxisIndex != null) {\n\t            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t            return this._coordsMap[key];\n\t        } else {\n\t            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\t            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n\t                if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n\t                    return coordList[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Initialize cartesian coordinate systems\n\t     * @private\n\t     */\n\t    gridProto._initCartesian = function (gridModel, ecModel, api) {\n\t        var axisPositionUsed = {\n\t                left: false,\n\t                right: false,\n\t                top: false,\n\t                bottom: false\n\t            };\n\t        var axesMap = {\n\t                x: {},\n\t                y: {}\n\t            };\n\t        var axesCount = {\n\t                x: 0,\n\t                y: 0\n\t            };\n\t        /// Create axis\n\t        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n\t        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\t        if (!axesCount.x || !axesCount.y) {\n\t            // Roll back when there no either x or y axis\n\t            this._axesMap = {};\n\t            this._axesList = [];\n\t            return;\n\t        }\n\t        this._axesMap = axesMap;\n\t        /// Create cartesian2d\n\t        each(axesMap.x, function (xAxis, xAxisIndex) {\n\t            each(axesMap.y, function (yAxis, yAxisIndex) {\n\t                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t                var cartesian = new Cartesian2D(key);\n\t                cartesian.grid = this;\n\t                this._coordsMap[key] = cartesian;\n\t                this._coordsList.push(cartesian);\n\t                cartesian.addAxis(xAxis);\n\t                cartesian.addAxis(yAxis);\n\t            }, this);\n\t        }, this);\n\t        function createAxisCreator(axisType) {\n\t            return function (axisModel, idx) {\n\t                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t                var axisPosition = axisModel.get('position');\n\t                if (axisType === 'x') {\n\t                    // Fix position\n\t                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n\t                        // Default bottom of X\n\t                        axisPosition = 'bottom';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n\t                        }\n\t                    }\n\t                } else {\n\t                    // Fix position\n\t                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n\t                        // Default left of Y\n\t                        axisPosition = 'left';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n\t                        }\n\t                    }\n\t                }\n\t                axisPositionUsed[axisPosition] = true;\n\t                var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [\n\t                        0,\n\t                        0\n\t                    ], axisModel.get('type'), axisPosition);\n\t                var isCategory = axis.type === 'category';\n\t                axis.onBand = isCategory && axisModel.get('boundaryGap');\n\t                axis.inverse = axisModel.get('inverse');\n\t                axis.onZero = axisModel.get('axisLine.onZero');\n\t                // Inject axis into axisModel\n\t                axisModel.axis = axis;\n\t                // Inject axisModel into axis\n\t                axis.model = axisModel;\n\t                // Inject grid info axis\n\t                axis.grid = this;\n\t                // Index of axis, can be used as key\n\t                axis.index = idx;\n\t                this._axesList.push(axis);\n\t                axesMap[axisType][idx] = axis;\n\t                axesCount[axisType]++;\n\t            };\n\t        }\n\t    };\n\t    /**\n\t     * Update cartesian properties from series\n\t     * @param  {module:echarts/model/Option} option\n\t     * @private\n\t     */\n\t    gridProto._updateScale = function (ecModel, gridModel) {\n\t        // Reset scale\n\t        zrUtil.each(this._axesList, function (axis) {\n\t            axis.scale.setExtent(Infinity, -Infinity);\n\t        });\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (isCartesian2D(seriesModel)) {\n\t                var axesModels = findAxesModels(seriesModel, ecModel);\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t                var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t                var data = seriesModel.getData();\n\t                var xAxis = cartesian.getAxis('x');\n\t                var yAxis = cartesian.getAxis('y');\n\t                if (data.type === 'list') {\n\t                    unionExtent(data, xAxis, seriesModel);\n\t                    unionExtent(data, yAxis, seriesModel);\n\t                }\n\t            }\n\t        }, this);\n\t        function unionExtent(data, axis, seriesModel) {\n\t            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n\t                axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * @inner\n\t     */\n\t    function updateAxisTransfrom(axis, coordBase) {\n\t        var axisExtent = axis.getExtent();\n\t        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\t        // Fast transform\n\t        axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n\t            return coord + coordBase;\n\t        } : function (coord) {\n\t            return axisExtentSum - coord + coordBase;\n\t        };\n\t        axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n\t            return coord - coordBase;\n\t        } : function (coord) {\n\t            return axisExtentSum - coord + coordBase;\n\t        };\n\t    }\n\t    var axesTypes = [\n\t            'xAxis',\n\t            'yAxis'\n\t        ];\n\t    /**\n\t     * @inner\n\t     */\n\t    function findAxesModels(seriesModel, ecModel) {\n\t        return zrUtil.map(axesTypes, function (axisType) {\n\t            var axisModel = ecModel.queryComponents({\n\t                    mainType: axisType,\n\t                    index: seriesModel.get(axisType + 'Index'),\n\t                    id: seriesModel.get(axisType + 'Id')\n\t                })[0];\n\t            if (true) {\n\t                if (!axisModel) {\n\t                    throw new Error(axisType + ' \"' + zrUtil.retrieve(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '\" not found');\n\t                }\n\t            }\n\t            return axisModel;\n\t        });\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function isCartesian2D(seriesModel) {\n\t        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n\t    }\n\t    Grid.create = function (ecModel, api) {\n\t        var grids = [];\n\t        ecModel.eachComponent('grid', function (gridModel, idx) {\n\t            var grid = new Grid(gridModel, ecModel, api);\n\t            grid.name = 'grid_' + idx;\n\t            grid.resize(gridModel, api);\n\t            gridModel.coordinateSystem = grid;\n\t            grids.push(grid);\n\t        });\n\t        // Inject the coordinateSystems into seriesModel\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (!isCartesian2D(seriesModel)) {\n\t                return;\n\t            }\n\t            var axesModels = findAxesModels(seriesModel, ecModel);\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t            var gridModel = xAxisModel.findGridModel();\n\t            if (true) {\n\t                if (!gridModel) {\n\t                    throw new Error('Grid \"' + zrUtil.retrieve(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n\t                }\n\t                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n\t                    throw new Error('xAxis and yAxis must use the same grid');\n\t                }\n\t            }\n\t            var grid = gridModel.coordinateSystem;\n\t            seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t        });\n\t        return grids;\n\t    };\n\t    // For deciding which dimensions to use when creating list data\n\t    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\t    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\t    return Grid;\n\t});\n\tdefine('echarts/chart/bar/BarSeries', ['require', '../../model/Series', '../helper/createListFromArray'], function (require) {\n\t    'use strict';\n\t    var SeriesModel = require('../../model/Series');\n\t    var createListFromArray = require('../helper/createListFromArray');\n\t    return SeriesModel.extend({\n\t        type: 'series.bar',\n\t        dependencies: [\n\t            'grid',\n\t            'polar'\n\t        ],\n\t        getInitialData: function (option, ecModel) {\n\t            if (true) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'cartesian2d') {\n\t                    throw new Error('Bar only support cartesian2d coordinateSystem');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t        getMarkerPosition: function (value) {\n\t            var coordSys = this.coordinateSystem;\n\t            if (coordSys) {\n\t                // PENDING if clamp ?\n\t                var pt = coordSys.dataToPoint(value, true);\n\t                var data = this.getData();\n\t                var offset = data.getLayout('offset');\n\t                var size = data.getLayout('size');\n\t                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n\t                pt[offsetIndex] += offset + size / 2;\n\t                return pt;\n\t            }\n\t            return [\n\t                NaN,\n\t                NaN\n\t            ];\n\t        },\n\t        brushSelector: 'rect',\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t            barMinHeight: 0,\n\t            itemStyle: {\n\t                normal: {},\n\t                emphasis: {}\n\t            }\n\t        }\n\t    });\n\t});\n\tdefine('echarts/chart/bar/BarView', ['require', 'zrender/core/util', '../../util/graphic', '../../model/Model', './barItemStyle', '../../echarts'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var graphic = require('../../util/graphic');\n\t    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\t    function fixLayoutWithLineWidth(layout, lineWidth) {\n\t        var signX = layout.width > 0 ? 1 : -1;\n\t        var signY = layout.height > 0 ? 1 : -1;\n\t        // In case width or height are too small.\n\t        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n\t        layout.x += signX * lineWidth / 2;\n\t        layout.y += signY * lineWidth / 2;\n\t        layout.width -= signX * lineWidth;\n\t        layout.height -= signY * lineWidth;\n\t    }\n\t    return require('../../echarts').extendChartView({\n\t        type: 'bar',\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\t            if (coordinateSystemType === 'cartesian2d') {\n\t                this._renderOnCartesian(seriesModel, ecModel, api);\n\t            }\n\t            return this.group;\n\t        },\n\t        _renderOnCartesian: function (seriesModel, ecModel, api) {\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var isHorizontal = baseAxis.isHorizontal();\n\t            var enableAnimation = seriesModel.get('animation');\n\t            var barBorderWidthQuery = [\n\t                    'itemStyle',\n\t                    'normal',\n\t                    'barBorderWidth'\n\t                ];\n\t            function createRect(dataIndex, isUpdate) {\n\t                var layout = data.getItemLayout(dataIndex);\n\t                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t                var rect = new graphic.Rect({ shape: zrUtil.extend({}, layout) });\n\t                // Animation\n\t                if (enableAnimation) {\n\t                    var rectShape = rect.shape;\n\t                    var animateProperty = isHorizontal ? 'height' : 'width';\n\t                    var animateTarget = {};\n\t                    rectShape[animateProperty] = 0;\n\t                    animateTarget[animateProperty] = layout[animateProperty];\n\t                    graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, seriesModel, dataIndex);\n\t                }\n\t                return rect;\n\t            }\n\t            data.diff(oldData).add(function (dataIndex) {\n\t                // \n\t                if (!data.hasValue(dataIndex)) {\n\t                    return;\n\t                }\n\t                var rect = createRect(dataIndex);\n\t                data.setItemGraphicEl(dataIndex, rect);\n\t                group.add(rect);\n\t            }).update(function (newIndex, oldIndex) {\n\t                var rect = oldData.getItemGraphicEl(oldIndex);\n\t                // \n\t                if (!data.hasValue(newIndex)) {\n\t                    group.remove(rect);\n\t                    return;\n\t                }\n\t                if (!rect) {\n\t                    rect = createRect(newIndex, true);\n\t                }\n\t                var layout = data.getItemLayout(newIndex);\n\t                var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t                graphic.updateProps(rect, { shape: layout }, seriesModel, newIndex);\n\t                data.setItemGraphicEl(newIndex, rect);\n\t                // Add back\n\t                group.add(rect);\n\t            }).remove(function (idx) {\n\t                var rect = oldData.getItemGraphicEl(idx);\n\t                if (rect) {\n\t                    // Not show text when animating\n\t                    rect.style.text = '';\n\t                    graphic.updateProps(rect, { shape: { width: 0 } }, seriesModel, idx, function () {\n\t                        group.remove(rect);\n\t                    });\n\t                }\n\t            }).execute();\n\t            this._updateStyle(seriesModel, data, isHorizontal);\n\t            this._data = data;\n\t        },\n\t        _updateStyle: function (seriesModel, data, isHorizontal) {\n\t            function setLabel(style, model, color, labelText, labelPositionOutside) {\n\t                graphic.setText(style, model, color);\n\t                style.text = labelText;\n\t                if (style.textPosition === 'outside') {\n\t                    style.textPosition = labelPositionOutside;\n\t                }\n\t            }\n\t            data.eachItemGraphicEl(function (rect, idx) {\n\t                var itemModel = data.getItemModel(idx);\n\t                var color = data.getItemVisual(idx, 'color');\n\t                var opacity = data.getItemVisual(idx, 'opacity');\n\t                var layout = data.getItemLayout(idx);\n\t                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\t                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\t                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\t                rect.useStyle(zrUtil.defaults({\n\t                    fill: color,\n\t                    opacity: opacity\n\t                }, itemStyleModel.getBarItemStyle()));\n\t                var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\t                var labelModel = itemModel.getModel('label.normal');\n\t                var hoverLabelModel = itemModel.getModel('label.emphasis');\n\t                var rectStyle = rect.style;\n\t                if (labelModel.get('show')) {\n\t                    setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);\n\t                } else {\n\t                    rectStyle.text = '';\n\t                }\n\t                if (hoverLabelModel.get('show')) {\n\t                    setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);\n\t                } else {\n\t                    hoverStyle.text = '';\n\t                }\n\t                graphic.setHoverStyle(rect, hoverStyle);\n\t            });\n\t        },\n\t        remove: function (ecModel, api) {\n\t            var group = this.group;\n\t            if (ecModel.get('animation')) {\n\t                if (this._data) {\n\t                    this._data.eachItemGraphicEl(function (el) {\n\t                        // Not show text when animating\n\t                        el.style.text = '';\n\t                        graphic.updateProps(el, { shape: { width: 0 } }, ecModel, el.dataIndex, function () {\n\t                            group.remove(el);\n\t                        });\n\t                    });\n\t                }\n\t            } else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    });\n\t});\n\tdefine('echarts/layout/barGrid', ['require', 'zrender/core/util', '../util/number'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('../util/number');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    function getSeriesStackId(seriesModel) {\n\t        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n\t    }\n\t    function getAxisKey(axis) {\n\t        return axis.dim + axis.index;\n\t    }\n\t    function calBarWidthAndOffset(barSeries, api) {\n\t        // Columns info on each category axis. Key is cartesian name\n\t        var columnsMap = {};\n\t        zrUtil.each(barSeries, function (seriesModel, idx) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var axisExtent = baseAxis.getExtent();\n\t            var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n\t            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n\t                    bandWidth: bandWidth,\n\t                    remainedWidth: bandWidth,\n\t                    autoWidthCount: 0,\n\t                    categoryGap: '20%',\n\t                    gap: '30%',\n\t                    stacks: {}\n\t                };\n\t            var stacks = columnsOnAxis.stacks;\n\t            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            if (!stacks[stackId]) {\n\t                columnsOnAxis.autoWidthCount++;\n\t            }\n\t            stacks[stackId] = stacks[stackId] || {\n\t                width: 0,\n\t                maxWidth: 0\n\t            };\n\t            var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n\t            var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n\t            var barGap = seriesModel.get('barGap');\n\t            var barCategoryGap = seriesModel.get('barCategoryGap');\n\t            // TODO\n\t            if (barWidth && !stacks[stackId].width) {\n\t                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n\t                stacks[stackId].width = barWidth;\n\t                columnsOnAxis.remainedWidth -= barWidth;\n\t            }\n\t            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n\t            barGap != null && (columnsOnAxis.gap = barGap);\n\t            barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n\t        });\n\t        var result = {};\n\t        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\t            result[coordSysName] = {};\n\t            var stacks = columnsOnAxis.stacks;\n\t            var bandWidth = columnsOnAxis.bandWidth;\n\t            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n\t            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\t            var remainedWidth = columnsOnAxis.remainedWidth;\n\t            var autoWidthCount = columnsOnAxis.autoWidthCount;\n\t            var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t            // Find if any auto calculated bar exceeded maxBarWidth\n\t            zrUtil.each(stacks, function (column, stack) {\n\t                var maxWidth = column.maxWidth;\n\t                if (!column.width && maxWidth && maxWidth < autoWidth) {\n\t                    maxWidth = Math.min(maxWidth, remainedWidth);\n\t                    remainedWidth -= maxWidth;\n\t                    column.width = maxWidth;\n\t                    autoWidthCount--;\n\t                }\n\t            });\n\t            // Recalculate width again\n\t            autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t            var widthSum = 0;\n\t            var lastColumn;\n\t            zrUtil.each(stacks, function (column, idx) {\n\t                if (!column.width) {\n\t                    column.width = autoWidth;\n\t                }\n\t                lastColumn = column;\n\t                widthSum += column.width * (1 + barGapPercent);\n\t            });\n\t            if (lastColumn) {\n\t                widthSum -= lastColumn.width * barGapPercent;\n\t            }\n\t            var offset = -widthSum / 2;\n\t            zrUtil.each(stacks, function (column, stackId) {\n\t                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n\t                    offset: offset,\n\t                    width: column.width\n\t                };\n\t                offset += column.width * (1 + barGapPercent);\n\t            });\n\t        });\n\t        return result;\n\t    }\n\t    /**\n\t     * @param {string} seriesType\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function barLayoutGrid(seriesType, ecModel, api) {\n\t        var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n\t                return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n\t            }));\n\t        var lastStackCoords = {};\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n\t            var columnOffset = columnLayoutInfo.offset;\n\t            var columnWidth = columnLayoutInfo.width;\n\t            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\t            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\t            var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n\t            var coords = cartesian.dataToPoints(data, true);\n\t            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n\t            data.setLayout({\n\t                offset: columnOffset,\n\t                size: columnWidth\n\t            });\n\t            data.each(valueAxis.dim, function (value, idx) {\n\t                // \n\t                if (isNaN(value)) {\n\t                    return;\n\t                }\n\t                if (!lastStackCoords[stackId][idx]) {\n\t                    lastStackCoords[stackId][idx] = {\n\t                        p: valueAxisStart,\n\t                        n: valueAxisStart\n\t                    };\n\t                }\n\t                var sign = value >= 0 ? 'p' : 'n';\n\t                var coord = coords[idx];\n\t                var lastCoord = lastStackCoords[stackId][idx][sign];\n\t                var x, y, width, height;\n\t                if (valueAxis.isHorizontal()) {\n\t                    x = lastCoord;\n\t                    y = coord[1] + columnOffset;\n\t                    width = coord[0] - lastCoord;\n\t                    height = columnWidth;\n\t                    if (Math.abs(width) < barMinHeight) {\n\t                        width = (width < 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += width;\n\t                } else {\n\t                    x = coord[0] + columnOffset;\n\t                    y = lastCoord;\n\t                    width = columnWidth;\n\t                    height = coord[1] - lastCoord;\n\t                    if (Math.abs(height) < barMinHeight) {\n\t                        // Include zero to has a positive bar\n\t                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += height;\n\t                }\n\t                data.setItemLayout(idx, {\n\t                    x: x,\n\t                    y: y,\n\t                    width: width,\n\t                    height: height\n\t                });\n\t            }, true);\n\t        }, this);\n\t    }\n\t    return barLayoutGrid;\n\t});\n\tdefine('echarts/util/graphic', ['require', 'zrender/core/util', 'zrender/tool/path', 'zrender/graphic/Path', 'zrender/tool/color', 'zrender/core/matrix', 'zrender/core/vector', 'zrender/graphic/Gradient', 'zrender/container/Group', 'zrender/graphic/Image', 'zrender/graphic/Text', 'zrender/graphic/shape/Circle', 'zrender/graphic/shape/Sector', 'zrender/graphic/shape/Ring', 'zrender/graphic/shape/Polygon', 'zrender/graphic/shape/Polyline', 'zrender/graphic/shape/Rect', 'zrender/graphic/shape/Line', 'zrender/graphic/shape/BezierCurve', 'zrender/graphic/shape/Arc', 'zrender/graphic/CompoundPath', 'zrender/graphic/LinearGradient', 'zrender/graphic/RadialGradient', 'zrender/core/BoundingRect'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var pathTool = require('zrender/tool/path');\n\t    var round = Math.round;\n\t    var Path = require('zrender/graphic/Path');\n\t    var colorTool = require('zrender/tool/color');\n\t    var matrix = require('zrender/core/matrix');\n\t    var vector = require('zrender/core/vector');\n\t    var Gradient = require('zrender/graphic/Gradient');\n\t    var graphic = {};\n\t    graphic.Group = require('zrender/container/Group');\n\t    graphic.Image = require('zrender/graphic/Image');\n\t    graphic.Text = require('zrender/graphic/Text');\n\t    graphic.Circle = require('zrender/graphic/shape/Circle');\n\t    graphic.Sector = require('zrender/graphic/shape/Sector');\n\t    graphic.Ring = require('zrender/graphic/shape/Ring');\n\t    graphic.Polygon = require('zrender/graphic/shape/Polygon');\n\t    graphic.Polyline = require('zrender/graphic/shape/Polyline');\n\t    graphic.Rect = require('zrender/graphic/shape/Rect');\n\t    graphic.Line = require('zrender/graphic/shape/Line');\n\t    graphic.BezierCurve = require('zrender/graphic/shape/BezierCurve');\n\t    graphic.Arc = require('zrender/graphic/shape/Arc');\n\t    graphic.CompoundPath = require('zrender/graphic/CompoundPath');\n\t    graphic.LinearGradient = require('zrender/graphic/LinearGradient');\n\t    graphic.RadialGradient = require('zrender/graphic/RadialGradient');\n\t    graphic.BoundingRect = require('zrender/core/BoundingRect');\n\t    /**\n\t     * Extend shape with parameters\n\t     */\n\t    graphic.extendShape = function (opts) {\n\t        return Path.extend(opts);\n\t    };\n\t    /**\n\t     * Extend path\n\t     */\n\t    graphic.extendPath = function (pathData, opts) {\n\t        return pathTool.extendFromString(pathData, opts);\n\t    };\n\t    /**\n\t     * Create a path element from path data string\n\t     * @param {string} pathData\n\t     * @param {Object} opts\n\t     * @param {module:zrender/core/BoundingRect} rect\n\t     * @param {string} [layout=cover] 'center' or 'cover'\n\t     */\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\n\t        var path = pathTool.createFromString(pathData, opts);\n\t        var boundingRect = path.getBoundingRect();\n\t        if (rect) {\n\t            var aspect = boundingRect.width / boundingRect.height;\n\t            if (layout === 'center') {\n\t                // Set rect to center, keep width / height ratio.\n\t                var width = rect.height * aspect;\n\t                var height;\n\t                if (width <= rect.width) {\n\t                    height = rect.height;\n\t                } else {\n\t                    width = rect.width;\n\t                    height = width / aspect;\n\t                }\n\t                var cx = rect.x + rect.width / 2;\n\t                var cy = rect.y + rect.height / 2;\n\t                rect.x = cx - width / 2;\n\t                rect.y = cy - height / 2;\n\t                rect.width = width;\n\t                rect.height = height;\n\t            }\n\t            this.resizePath(path, rect);\n\t        }\n\t        return path;\n\t    };\n\t    graphic.mergePath = pathTool.mergePath, graphic.resizePath = function (path, rect) {\n\t        if (!path.applyTransform) {\n\t            return;\n\t        }\n\t        var pathRect = path.getBoundingRect();\n\t        var m = pathRect.calculateTransform(rect);\n\t        path.applyTransform(m);\n\t    };\n\t    /**\n\t     * Sub pixel optimize line for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x1]\n\t     * @param {number} [param.shape.y1]\n\t     * @param {number} [param.shape.x2]\n\t     * @param {number} [param.shape.y2]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeLine = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n\t        }\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n\t        }\n\t        return param;\n\t    };\n\t    /**\n\t     * Sub pixel optimize rect for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x]\n\t     * @param {number} [param.shape.y]\n\t     * @param {number} [param.shape.width]\n\t     * @param {number} [param.shape.height]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeRect = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        var originX = shape.x;\n\t        var originY = shape.y;\n\t        var originWidth = shape.width;\n\t        var originHeight = shape.height;\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n\t        shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n\t        shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n\t        return param;\n\t    };\n\t    /**\n\t     * Sub pixel optimize for canvas\n\t     *\n\t     * @param {number} position Coordinate, such as x, y\n\t     * @param {number} lineWidth Should be nonnegative integer.\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\n\t     * @return {number} Optimized position.\n\t     */\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\n\t        // otherwise line will be fuzzy in canvas.\n\t        var doubledPosition = round(position * 2);\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n\t    };\n\t    function hasFillOrStroke(fillOrStroke) {\n\t        return fillOrStroke != null && fillOrStroke != 'none';\n\t    }\n\t    function liftColor(color) {\n\t        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function cacheElementStl(el) {\n\t        if (el.__hoverStlDirty) {\n\t            var stroke = el.style.stroke;\n\t            var fill = el.style.fill;\n\t            // Create hoverStyle on mouseover\n\t            var hoverStyle = el.__hoverStl;\n\t            hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n\t            hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\t            var normalStyle = {};\n\t            for (var name in hoverStyle) {\n\t                if (hoverStyle.hasOwnProperty(name)) {\n\t                    normalStyle[name] = el.style[name];\n\t                }\n\t            }\n\t            el.__normalStl = normalStyle;\n\t            el.__hoverStlDirty = false;\n\t        }\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function doSingleEnterHover(el) {\n\t        if (el.__isHover) {\n\t            return;\n\t        }\n\t        cacheElementStl(el);\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n\t        } else {\n\t            el.setStyle(el.__hoverStl);\n\t            el.z2 += 1;\n\t        }\n\t        el.__isHover = true;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function doSingleLeaveHover(el) {\n\t        if (!el.__isHover) {\n\t            return;\n\t        }\n\t        var normalStl = el.__normalStl;\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.removeHover(el);\n\t        } else {\n\t            normalStl && el.setStyle(normalStl);\n\t            el.z2 -= 1;\n\t        }\n\t        el.__isHover = false;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function doEnterHover(el) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                doSingleEnterHover(child);\n\t            }\n\t        }) : doSingleEnterHover(el);\n\t    }\n\t    function doLeaveHover(el) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                doSingleLeaveHover(child);\n\t            }\n\t        }) : doSingleLeaveHover(el);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function setElementHoverStl(el, hoverStl) {\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n\t        // Often used when item group has a label element and it's hoverStyle is different\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\n\t        el.__hoverStlDirty = true;\n\t        if (el.__isHover) {\n\t            cacheElementStl(el);\n\t        }\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOver() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doEnterHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOut() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doLeaveHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function enterEmphasis() {\n\t        this.__isEmphasis = true;\n\t        doEnterHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function leaveEmphasis() {\n\t        this.__isEmphasis = false;\n\t        doLeaveHover(this);\n\t    }\n\t    /**\n\t     * Set hover style of element\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} [hoverStyle]\n\t     */\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                setElementHoverStl(child, hoverStyle);\n\t            }\n\t        }) : setElementHoverStl(el, hoverStyle);\n\t        // Remove previous bound handlers\n\t        el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);\n\t        // Emphasis, normal can be triggered manually\n\t        el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n\t    };\n\t    /**\n\t     * Set text option in the style\n\t     * @param {Object} textStyle\n\t     * @param {module:echarts/model/Model} labelModel\n\t     * @param {string} color\n\t     */\n\t    graphic.setText = function (textStyle, labelModel, color) {\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        zrUtil.extend(textStyle, {\n\t            textDistance: labelModel.getShallow('distance') || 5,\n\t            textFont: textStyleModel.getFont(),\n\t            textPosition: labelPosition,\n\t            textFill: textStyleModel.getTextColor() || labelColor\n\t        });\n\t    };\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n\t        if (typeof dataIndex === 'function') {\n\t            cb = dataIndex;\n\t            dataIndex = null;\n\t        }\n\t        var animationEnabled = animatableModel && (animatableModel.ifEnableAnimation ? animatableModel.ifEnableAnimation() : animatableModel.getShallow('animation'));\n\t        if (animationEnabled) {\n\t            var postfix = isUpdate ? 'Update' : '';\n\t            var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);\n\t            var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);\n\t            var animationDelay = animatableModel && animatableModel.getShallow('animationDelay' + postfix);\n\t            if (typeof animationDelay === 'function') {\n\t                animationDelay = animationDelay(dataIndex);\n\t            }\n\t            duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb) : (el.attr(props), cb && cb());\n\t        } else {\n\t            el.attr(props);\n\t            cb && cb();\n\t        }\n\t    }\n\t    /**\n\t     * Update graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} [cb]\n\t     * @example\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n\t     *     // Or\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, function () { console.log('Animation done!'); });\n\t     */\n\t    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t    /**\n\t     * Init graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} cb\n\t     */\n\t    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t    /**\n\t     * Get transform matrix of target (param target),\n\t     * in coordinate of its ancestor (param ancestor)\n\t     *\n\t     * @param {module:zrender/mixin/Transformable} target\n\t     * @param {module:zrender/mixin/Transformable} [ancestor]\n\t     */\n\t    graphic.getTransform = function (target, ancestor) {\n\t        var mat = matrix.identity([]);\n\t        while (target && target !== ancestor) {\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\n\t            target = target.parent;\n\t        }\n\t        return mat;\n\t    };\n\t    /**\n\t     * Apply transform to an vertex.\n\t     * @param {Array.<number>} vertex [x, y]\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {Array.<number>} [x, y]\n\t     */\n\t    graphic.applyTransform = function (vertex, transform, invert) {\n\t        if (invert) {\n\t            transform = matrix.invert([], transform);\n\t        }\n\t        return vector.applyTransform([], vertex, transform);\n\t    };\n\t    /**\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n\t     */\n\t    graphic.transformDirection = function (direction, transform, invert) {\n\t        // Pick a base, ensure that transform result will not be (0, 0).\n\t        var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n\t        var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\t        var vertex = [\n\t                direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n\t                direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n\t            ];\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n\t    };\n\t    /**\n\t     * Apply group transition animation from g1 to g2\n\t     */\n\t    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n\t        if (!g1 || !g2) {\n\t            return;\n\t        }\n\t        function getElMap(g) {\n\t            var elMap = {};\n\t            g.traverse(function (el) {\n\t                if (!el.isGroup && el.anid) {\n\t                    elMap[el.anid] = el;\n\t                }\n\t            });\n\t            return elMap;\n\t        }\n\t        function getAnimatableProps(el) {\n\t            var obj = {\n\t                    position: vector.clone(el.position),\n\t                    rotation: el.rotation\n\t                };\n\t            if (el.shape) {\n\t                obj.shape = zrUtil.extend({}, el.shape);\n\t            }\n\t            return obj;\n\t        }\n\t        var elMap1 = getElMap(g1);\n\t        g2.traverse(function (el) {\n\t            if (!el.isGroup && el.anid) {\n\t                var oldEl = elMap1[el.anid];\n\t                if (oldEl) {\n\t                    var newProp = getAnimatableProps(el);\n\t                    el.attr(getAnimatableProps(oldEl));\n\t                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n\t                }    // else {\n\t                     //     if (el.previousProps) {\n\t                     //         graphic.updateProps\n\t                     //     }\n\t                     // }\n\t            }\n\t        });\n\t    };\n\t    return graphic;\n\t});\n\tdefine('echarts/component/axis', ['require', '../coord/cartesian/AxisModel', './axis/AxisView'], function (require) {\n\t    'use strict';\n\t    require('../coord/cartesian/AxisModel');\n\t    require('./axis/AxisView');\n\t});\n\tdefine('echarts/util/layout', ['require', 'zrender/core/util', 'zrender/core/BoundingRect', './number', './format'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var BoundingRect = require('zrender/core/BoundingRect');\n\t    var numberUtil = require('./number');\n\t    var formatUtil = require('./format');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var each = zrUtil.each;\n\t    var layout = {};\n\t    var LOCATION_PARAMS = [\n\t            'left',\n\t            'right',\n\t            'top',\n\t            'bottom',\n\t            'width',\n\t            'height'\n\t        ];\n\t    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n\t        var x = 0;\n\t        var y = 0;\n\t        if (maxWidth == null) {\n\t            maxWidth = Infinity;\n\t        }\n\t        if (maxHeight == null) {\n\t            maxHeight = Infinity;\n\t        }\n\t        var currentLineMaxSize = 0;\n\t        group.eachChild(function (child, idx) {\n\t            var position = child.position;\n\t            var rect = child.getBoundingRect();\n\t            var nextChild = group.childAt(idx + 1);\n\t            var nextChildRect = nextChild && nextChild.getBoundingRect();\n\t            var nextX;\n\t            var nextY;\n\t            if (orient === 'horizontal') {\n\t                var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n\t                nextX = x + moveX;\n\t                // Wrap when width exceeds maxWidth or meet a `newline` group\n\t                if (nextX > maxWidth || child.newline) {\n\t                    x = 0;\n\t                    nextX = moveX;\n\t                    y += currentLineMaxSize + gap;\n\t                    currentLineMaxSize = rect.height;\n\t                } else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n\t                }\n\t            } else {\n\t                var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n\t                nextY = y + moveY;\n\t                // Wrap when width exceeds maxHeight or meet a `newline` group\n\t                if (nextY > maxHeight || child.newline) {\n\t                    x += currentLineMaxSize + gap;\n\t                    y = 0;\n\t                    nextY = moveY;\n\t                    currentLineMaxSize = rect.width;\n\t                } else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n\t                }\n\t            }\n\t            if (child.newline) {\n\t                return;\n\t            }\n\t            position[0] = x;\n\t            position[1] = y;\n\t            orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n\t        });\n\t    }\n\t    /**\n\t     * VBox or HBox layouting\n\t     * @param {string} orient\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.box = boxLayout;\n\t    /**\n\t     * VBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\t    /**\n\t     * HBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\t    /**\n\t     * If x or x2 is not specified or 'center' 'left' 'right',\n\t     * the width would be as long as possible.\n\t     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n\t     * the height would be as long as possible.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.x]\n\t     * @param {number|string} [positionInfo.y]\n\t     * @param {number|string} [positionInfo.x2]\n\t     * @param {number|string} [positionInfo.y2]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @return {Object} {width, height}\n\t     */\n\t    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t        var x = parsePercent(positionInfo.x, containerWidth);\n\t        var y = parsePercent(positionInfo.y, containerHeight);\n\t        var x2 = parsePercent(positionInfo.x2, containerWidth);\n\t        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\t        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n\t        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n\t        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n\t        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t        return {\n\t            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n\t            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n\t        };\n\t    };\n\t    /**\n\t     * Parse position info.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {number|string} [positionInfo.width]\n\t     * @param {number|string} [positionInfo.height]\n\t     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n\t     * @param {Object} containerRect\n\t     * @param {string|number} [margin]\n\t     *\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t        var left = parsePercent(positionInfo.left, containerWidth);\n\t        var top = parsePercent(positionInfo.top, containerHeight);\n\t        var right = parsePercent(positionInfo.right, containerWidth);\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n\t        var width = parsePercent(positionInfo.width, containerWidth);\n\t        var height = parsePercent(positionInfo.height, containerHeight);\n\t        var verticalMargin = margin[2] + margin[0];\n\t        var horizontalMargin = margin[1] + margin[3];\n\t        var aspect = positionInfo.aspect;\n\t        // If width is not specified, calculate width from left and right\n\t        if (isNaN(width)) {\n\t            width = containerWidth - right - horizontalMargin - left;\n\t        }\n\t        if (isNaN(height)) {\n\t            height = containerHeight - bottom - verticalMargin - top;\n\t        }\n\t        // If width and height are not given\n\t        // 1. Graph should not exceeds the container\n\t        // 2. Aspect must be keeped\n\t        // 3. Graph should take the space as more as possible\n\t        if (isNaN(width) && isNaN(height)) {\n\t            if (aspect > containerWidth / containerHeight) {\n\t                width = containerWidth * 0.8;\n\t            } else {\n\t                height = containerHeight * 0.8;\n\t            }\n\t        }\n\t        if (aspect != null) {\n\t            // Calculate width or height with given aspect\n\t            if (isNaN(width)) {\n\t                width = aspect * height;\n\t            }\n\t            if (isNaN(height)) {\n\t                height = width / aspect;\n\t            }\n\t        }\n\t        // If left is not specified, calculate left from right and width\n\t        if (isNaN(left)) {\n\t            left = containerWidth - right - width - horizontalMargin;\n\t        }\n\t        if (isNaN(top)) {\n\t            top = containerHeight - bottom - height - verticalMargin;\n\t        }\n\t        // Align left and top\n\t        switch (positionInfo.left || positionInfo.right) {\n\t        case 'center':\n\t            left = containerWidth / 2 - width / 2 - margin[3];\n\t            break;\n\t        case 'right':\n\t            left = containerWidth - width - horizontalMargin;\n\t            break;\n\t        }\n\t        switch (positionInfo.top || positionInfo.bottom) {\n\t        case 'middle':\n\t        case 'center':\n\t            top = containerHeight / 2 - height / 2 - margin[0];\n\t            break;\n\t        case 'bottom':\n\t            top = containerHeight - height - verticalMargin;\n\t            break;\n\t        }\n\t        // If something is wrong and left, top, width, height are calculated as NaN\n\t        left = left || 0;\n\t        top = top || 0;\n\t        if (isNaN(width)) {\n\t            // Width may be NaN if only one value is given except width\n\t            width = containerWidth - left - (right || 0);\n\t        }\n\t        if (isNaN(height)) {\n\t            // Height may be NaN if only one value is given except height\n\t            height = containerHeight - top - (bottom || 0);\n\t        }\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n\t        rect.margin = margin;\n\t        return rect;\n\t    };\n\t    /**\n\t     * Position group of component in viewport\n\t     *  Group position is specified by either\n\t     *  {left, top}, {right, bottom}\n\t     *  If all properties exists, right and bottom will be igonred.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     */\n\t    layout.positionGroup = function (group, positionInfo, containerRect, margin) {\n\t        var groupRect = group.getBoundingRect();\n\t        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n\t            width: groupRect.width,\n\t            height: groupRect.height\n\t        });\n\t        positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);\n\t        group.attr('position', [\n\t            positionInfo.x - groupRect.x,\n\t            positionInfo.y - groupRect.y\n\t        ]);\n\t    };\n\t    /**\n\t     * Consider Case:\n\t     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n\t     * through setOption or media query, using normal zrUtil.merge will cause\n\t     * {right: 0} does not take effect.\n\t     *\n\t     * @example\n\t     * ComponentModel.extend({\n\t     *     init: function () {\n\t     *         ...\n\t     *         var inputPositionParams = layout.getLayoutParams(option);\n\t     *         this.mergeOption(inputPositionParams);\n\t     *     },\n\t     *     mergeOption: function (newOption) {\n\t     *         newOption && zrUtil.merge(thisOption, newOption, true);\n\t     *         layout.mergeLayoutParam(thisOption, newOption);\n\t     *     }\n\t     * });\n\t     *\n\t     * @param {Object} targetOption\n\t     * @param {Object} newOption\n\t     * @param {Object|string} [opt]\n\t     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n\t     */\n\t    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n\t        !zrUtil.isObject(opt) && (opt = {});\n\t        var hNames = [\n\t                'width',\n\t                'left',\n\t                'right'\n\t            ];\n\t        // Order by priority.\n\t        var vNames = [\n\t                'height',\n\t                'top',\n\t                'bottom'\n\t            ];\n\t        // Order by priority.\n\t        var hResult = merge(hNames);\n\t        var vResult = merge(vNames);\n\t        copy(hNames, targetOption, hResult);\n\t        copy(vNames, targetOption, vResult);\n\t        function merge(names) {\n\t            var newParams = {};\n\t            var newValueCount = 0;\n\t            var merged = {};\n\t            var mergedValueCount = 0;\n\t            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\t            each(names, function (name) {\n\t                merged[name] = targetOption[name];\n\t            });\n\t            each(names, function (name) {\n\t                // Consider case: newOption.width is null, which is\n\t                // set by user for removing width setting.\n\t                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n\t                hasValue(newParams, name) && newValueCount++;\n\t                hasValue(merged, name) && mergedValueCount++;\n\t            });\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // or targetOption: {right: ...} and newOption: {width: ...},\n\t            // There is no conflict when merged only has params count\n\t            // little than enoughParamNumber.\n\t            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n\t                return merged;\n\t            }    // Case: newOption: {width: ..., right: ...},\n\t                 // Than we can make sure user only want those two, and ignore\n\t                 // all origin params in targetOption.\n\t            else if (newValueCount >= enoughParamNumber) {\n\t                return newParams;\n\t            } else {\n\t                // Chose another param from targetOption by priority.\n\t                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n\t                for (var i = 0; i < names.length; i++) {\n\t                    var name = names[i];\n\t                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n\t                        newParams[name] = targetOption[name];\n\t                        break;\n\t                    }\n\t                }\n\t                return newParams;\n\t            }\n\t        }\n\t        function hasProp(obj, name) {\n\t            return obj.hasOwnProperty(name);\n\t        }\n\t        function hasValue(obj, name) {\n\t            return obj[name] != null && obj[name] !== 'auto';\n\t        }\n\t        function copy(names, target, source) {\n\t            each(names, function (name) {\n\t                target[name] = source[name];\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.getLayoutParams = function (source) {\n\t        return layout.copyLayoutParams({}, source);\n\t    };\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.copyLayoutParams = function (target, source) {\n\t        source && target && each(LOCATION_PARAMS, function (name) {\n\t            source.hasOwnProperty(name) && (target[name] = source[name]);\n\t        });\n\t        return target;\n\t    };\n\t    return layout;\n\t});\n\tdefine('echarts/util/number', ['require'], function (require) {\n\t    var number = {};\n\t    var RADIAN_EPSILON = 0.0001;\n\t    function _trim(str) {\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t    }\n\t    /**\n\t     * Linear mapping a value from domain to range\n\t     * @memberOf module:echarts/util/number\n\t     * @param  {(number|Array.<number>)} val\n\t     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n\t     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n\t     * @param  {boolean} clamp\n\t     * @return {(number|Array.<number>}\n\t     */\n\t    number.linearMap = function (val, domain, range, clamp) {\n\t        var subDomain = domain[1] - domain[0];\n\t        var subRange = range[1] - range[0];\n\t        if (subDomain === 0) {\n\t            return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n\t        }\n\t        // Avoid accuracy problem in edge, such as\n\t        // 146.39 - 62.83 === 83.55999999999999.\n\t        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n\t        // It is a little verbose for efficiency considering this method\n\t        // is a hotspot.\n\t        if (clamp) {\n\t            if (subDomain > 0) {\n\t                if (val <= domain[0]) {\n\t                    return range[0];\n\t                } else if (val >= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            } else {\n\t                if (val >= domain[0]) {\n\t                    return range[0];\n\t                } else if (val <= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t        } else {\n\t            if (val === domain[0]) {\n\t                return range[0];\n\t            }\n\t            if (val === domain[1]) {\n\t                return range[1];\n\t            }\n\t        }\n\t        return (val - domain[0]) / subDomain * subRange + range[0];\n\t    };\n\t    /**\n\t     * Convert a percent string to absolute number.\n\t     * Returns NaN if percent is not a valid string or number\n\t     * @memberOf module:echarts/util/number\n\t     * @param {string|number} percent\n\t     * @param {number} all\n\t     * @return {number}\n\t     */\n\t    number.parsePercent = function (percent, all) {\n\t        switch (percent) {\n\t        case 'center':\n\t        case 'middle':\n\t            percent = '50%';\n\t            break;\n\t        case 'left':\n\t        case 'top':\n\t            percent = '0%';\n\t            break;\n\t        case 'right':\n\t        case 'bottom':\n\t            percent = '100%';\n\t            break;\n\t        }\n\t        if (typeof percent === 'string') {\n\t            if (_trim(percent).match(/%$/)) {\n\t                return parseFloat(percent) / 100 * all;\n\t            }\n\t            return parseFloat(percent);\n\t        }\n\t        return percent == null ? NaN : +percent;\n\t    };\n\t    /**\n\t     * Fix rounding error of float numbers\n\t     * @param {number} x\n\t     * @return {number}\n\t     */\n\t    number.round = function (x, precision) {\n\t        if (precision == null) {\n\t            precision = 10;\n\t        }\n\t        // PENDING\n\t        return +(+x).toFixed(precision);\n\t    };\n\t    number.asc = function (arr) {\n\t        arr.sort(function (a, b) {\n\t            return a - b;\n\t        });\n\t        return arr;\n\t    };\n\t    /**\n\t     * Get precision\n\t     * @param {number} val\n\t     */\n\t    number.getPrecision = function (val) {\n\t        val = +val;\n\t        if (isNaN(val)) {\n\t            return 0;\n\t        }\n\t        // It is much faster than methods converting number to string as follows\n\t        //      var tmp = val.toString();\n\t        //      return tmp.length - 1 - tmp.indexOf('.');\n\t        // especially when precision is low\n\t        var e = 1;\n\t        var count = 0;\n\t        while (Math.round(val * e) / e !== val) {\n\t            e *= 10;\n\t            count++;\n\t        }\n\t        return count;\n\t    };\n\t    number.getPrecisionSafe = function (val) {\n\t        var str = val.toString();\n\t        var dotIndex = str.indexOf('.');\n\t        if (dotIndex < 0) {\n\t            return 0;\n\t        }\n\t        return str.length - 1 - dotIndex;\n\t    };\n\t    /**\n\t     * @param {Array.<number>} dataExtent\n\t     * @param {Array.<number>} pixelExtent\n\t     * @return {number}  precision\n\t     */\n\t    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n\t        var log = Math.log;\n\t        var LN10 = Math.LN10;\n\t        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n\t        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n\t        return Math.max(-dataQuantity + sizeQuantity, 0);\n\t    };\n\t    // Number.MAX_SAFE_INTEGER, ie do not support.\n\t    number.MAX_SAFE_INTEGER = 9007199254740991;\n\t    /**\n\t     * To 0 - 2 * PI, considering negative radian.\n\t     * @param {number} radian\n\t     * @return {number}\n\t     */\n\t    number.remRadian = function (radian) {\n\t        var pi2 = Math.PI * 2;\n\t        return (radian % pi2 + pi2) % pi2;\n\t    };\n\t    /**\n\t     * @param {type} radian\n\t     * @return {boolean}\n\t     */\n\t    number.isRadianAroundZero = function (val) {\n\t        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n\t    };\n\t    /**\n\t     * @param {string|Date|number} value\n\t     * @return {Date} date\n\t     */\n\t    number.parseDate = function (value) {\n\t        if (value instanceof Date) {\n\t            return value;\n\t        } else if (typeof value === 'string') {\n\t            // Treat as ISO format. See issue #3623\n\t            var ret = new Date(value);\n\t            if (isNaN(+ret)) {\n\t                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n\t                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n\t            }\n\t            return ret;\n\t        }\n\t        return new Date(Math.round(value));\n\t    };\n\t    /**\n\t     * Quantity of a number. e.g. 0.1, 1, 10, 100\n\t     * @param  {number} val\n\t     * @return {number}\n\t     */\n\t    number.quantity = function (val) {\n\t        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n\t    };\n\t    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t    /**\n\t     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n\t     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n\t     * @param  {number} val\n\t     * @param  {boolean} round\n\t     * @return {number}\n\t     */\n\t    number.nice = function (val, round) {\n\t        var exp10 = number.quantity(val);\n\t        var f = val / exp10;\n\t        // between 1 and 10\n\t        var nf;\n\t        if (round) {\n\t            if (f < 1.5) {\n\t                nf = 1;\n\t            } else if (f < 2.5) {\n\t                nf = 2;\n\t            } else if (f < 4) {\n\t                nf = 3;\n\t            } else if (f < 7) {\n\t                nf = 5;\n\t            } else {\n\t                nf = 10;\n\t            }\n\t        } else {\n\t            if (f < 1) {\n\t                nf = 1;\n\t            } else if (f < 2) {\n\t                nf = 2;\n\t            } else if (f < 3) {\n\t                nf = 3;\n\t            } else if (f < 5) {\n\t                nf = 5;\n\t            } else {\n\t                nf = 10;\n\t            }\n\t        }\n\t        return nf * exp10;\n\t    };\n\t    return number;\n\t});\n\tdefine('echarts/util/format', ['require', 'zrender/core/util', './number', 'zrender/contain/text'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('./number');\n\t    var textContain = require('zrender/contain/text');\n\t    var formatUtil = {};\n\t    /**\n\t     * ,\n\t     * @type {string|number} x\n\t     */\n\t    formatUtil.addCommas = function (x) {\n\t        if (isNaN(x)) {\n\t            return '-';\n\t        }\n\t        x = (x + '').split('.');\n\t        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n\t    };\n\t    /**\n\t     * @param {string} str\n\t     * @return {string} str\n\t     */\n\t    formatUtil.toCamelCase = function (str) {\n\t        return str.toLowerCase().replace(/-(.)/g, function (match, group1) {\n\t            return group1.toUpperCase();\n\t        });\n\t    };\n\t    /**\n\t     * Normalize css liked array configuration\n\t     * e.g.\n\t     *  3 => [3, 3, 3, 3]\n\t     *  [4, 2] => [4, 2, 4, 2]\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\n\t     * @param {number|Array.<number>} val\n\t     */\n\t    formatUtil.normalizeCssArray = function (val) {\n\t        var len = val.length;\n\t        if (typeof val === 'number') {\n\t            return [\n\t                val,\n\t                val,\n\t                val,\n\t                val\n\t            ];\n\t        } else if (len === 2) {\n\t            // vertical | horizontal\n\t            return [\n\t                val[0],\n\t                val[1],\n\t                val[0],\n\t                val[1]\n\t            ];\n\t        } else if (len === 3) {\n\t            // top | horizontal | bottom\n\t            return [\n\t                val[0],\n\t                val[1],\n\t                val[2],\n\t                val[1]\n\t            ];\n\t        }\n\t        return val;\n\t    };\n\t    formatUtil.encodeHTML = function (source) {\n\t        return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n\t    };\n\t    var TPL_VAR_ALIAS = [\n\t            'a',\n\t            'b',\n\t            'c',\n\t            'd',\n\t            'e',\n\t            'f',\n\t            'g'\n\t        ];\n\t    var wrapVar = function (varName, seriesIdx) {\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n\t    };\n\t    /**\n\t     * Template formatter\n\t     * @param  {string} tpl\n\t     * @param  {Array.<Object>|Object} paramsList\n\t     * @return {string}\n\t     */\n\t    formatUtil.formatTpl = function (tpl, paramsList) {\n\t        if (!zrUtil.isArray(paramsList)) {\n\t            paramsList = [paramsList];\n\t        }\n\t        var seriesLen = paramsList.length;\n\t        if (!seriesLen) {\n\t            return '';\n\t        }\n\t        var $vars = paramsList[0].$vars || [];\n\t        for (var i = 0; i < $vars.length; i++) {\n\t            var alias = TPL_VAR_ALIAS[i];\n\t            tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n\t        }\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n\t            for (var k = 0; k < $vars.length; k++) {\n\t                tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);\n\t            }\n\t        }\n\t        return tpl;\n\t    };\n\t    /**\n\t     * @param {string} str\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    var s2d = function (str) {\n\t        return str < 10 ? '0' + str : str;\n\t    };\n\t    /**\n\t     * ISO Date format\n\t     * @param {string} tpl\n\t     * @param {number} value\n\t     * @inner\n\t     */\n\t    formatUtil.formatTime = function (tpl, value) {\n\t        if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n\t            tpl = 'MM-dd\\nyyyy';\n\t        }\n\t        var date = numberUtil.parseDate(value);\n\t        var y = date.getFullYear();\n\t        var M = date.getMonth() + 1;\n\t        var d = date.getDate();\n\t        var h = date.getHours();\n\t        var m = date.getMinutes();\n\t        var s = date.getSeconds();\n\t        tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n\t        return tpl;\n\t    };\n\t    /**\n\t     * Capital first\n\t     * @param {string} str\n\t     * @return {string}\n\t     */\n\t    formatUtil.capitalFirst = function (str) {\n\t        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n\t    };\n\t    formatUtil.truncateText = textContain.truncateText;\n\t    return formatUtil;\n\t});\n\tdefine('echarts/scale/Interval', ['require', '../util/number', '../util/format', './Scale'], function (require) {\n\t    var numberUtil = require('../util/number');\n\t    var formatUtil = require('../util/format');\n\t    var Scale = require('./Scale');\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t    /**\n\t     * @alias module:echarts/coord/scale/Interval\n\t     * @constructor\n\t     */\n\t    var IntervalScale = Scale.extend({\n\t            type: 'interval',\n\t            _interval: 0,\n\t            setExtent: function (start, end) {\n\t                var thisExtent = this._extent;\n\t                //start,end may be a Number like '25',so...\n\t                if (!isNaN(start)) {\n\t                    thisExtent[0] = parseFloat(start);\n\t                }\n\t                if (!isNaN(end)) {\n\t                    thisExtent[1] = parseFloat(end);\n\t                }\n\t            },\n\t            unionExtent: function (other) {\n\t                var extent = this._extent;\n\t                other[0] < extent[0] && (extent[0] = other[0]);\n\t                other[1] > extent[1] && (extent[1] = other[1]);\n\t                // unionExtent may called by it's sub classes\n\t                IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n\t            },\n\t            getInterval: function () {\n\t                if (!this._interval) {\n\t                    this.niceTicks();\n\t                }\n\t                return this._interval;\n\t            },\n\t            setInterval: function (interval) {\n\t                this._interval = interval;\n\t                // Dropped auto calculated niceExtent and use user setted extent\n\t                // We assume user wan't to set both interval, min, max to get a better result\n\t                this._niceExtent = this._extent.slice();\n\t            },\n\t            getTicks: function () {\n\t                if (!this._interval) {\n\t                    this.niceTicks();\n\t                }\n\t                var interval = this._interval;\n\t                var extent = this._extent;\n\t                var ticks = [];\n\t                // Consider this case: using dataZoom toolbox, zoom and zoom.\n\t                var safeLimit = 10000;\n\t                if (interval) {\n\t                    var niceExtent = this._niceExtent;\n\t                    var precision = getPrecisionSafe(interval) + 2;\n\t                    if (extent[0] < niceExtent[0]) {\n\t                        ticks.push(extent[0]);\n\t                    }\n\t                    var tick = niceExtent[0];\n\t                    while (tick <= niceExtent[1]) {\n\t                        ticks.push(tick);\n\t                        // Avoid rounding error\n\t                        tick = roundingErrorFix(tick + interval, precision);\n\t                        if (ticks.length > safeLimit) {\n\t                            return [];\n\t                        }\n\t                    }\n\t                    if (extent[1] > niceExtent[1]) {\n\t                        ticks.push(extent[1]);\n\t                    }\n\t                }\n\t                return ticks;\n\t            },\n\t            getTicksLabels: function () {\n\t                var labels = [];\n\t                var ticks = this.getTicks();\n\t                for (var i = 0; i < ticks.length; i++) {\n\t                    labels.push(this.getLabel(ticks[i]));\n\t                }\n\t                return labels;\n\t            },\n\t            getLabel: function (data) {\n\t                return formatUtil.addCommas(data);\n\t            },\n\t            niceTicks: function (splitNumber) {\n\t                splitNumber = splitNumber || 5;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                if (!isFinite(span)) {\n\t                    return;\n\t                }\n\t                // User may set axis min 0 and data are all negative\n\t                // FIXME If it needs to reverse ?\n\t                if (span < 0) {\n\t                    span = -span;\n\t                    extent.reverse();\n\t                }\n\t                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                // var niceSpan = numberUtil.nice(span, false);\n\t                var step = roundingErrorFix(numberUtil.nice(span / splitNumber, true), Math.max(getPrecisionSafe(extent[0]), getPrecisionSafe(extent[1])) + 2);\n\t                var precision = getPrecisionSafe(step) + 2;\n\t                // Niced extent inside original extent\n\t                var niceExtent = [\n\t                        roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n\t                        roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n\t                    ];\n\t                this._interval = step;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            niceExtent: function (splitNumber, fixMin, fixMax) {\n\t                var extent = this._extent;\n\t                // If extent start and end are same, expand them\n\t                if (extent[0] === extent[1]) {\n\t                    if (extent[0] !== 0) {\n\t                        // Expand extent\n\t                        var expandSize = extent[0];\n\t                        // In the fowllowing case\n\t                        //      Axis has been fixed max 100\n\t                        //      Plus data are all 100 and axis extent are [100, 100].\n\t                        // Extend to the both side will cause expanded max is larger than fixed max.\n\t                        // So only expand to the smaller side.\n\t                        if (!fixMax) {\n\t                            extent[1] += expandSize / 2;\n\t                            extent[0] -= expandSize / 2;\n\t                        } else {\n\t                            extent[0] -= expandSize / 2;\n\t                        }\n\t                    } else {\n\t                        extent[1] = 1;\n\t                    }\n\t                }\n\t                var span = extent[1] - extent[0];\n\t                // If there are no data and extent are [Infinity, -Infinity]\n\t                if (!isFinite(span)) {\n\t                    extent[0] = 0;\n\t                    extent[1] = 1;\n\t                }\n\t                this.niceTicks(splitNumber);\n\t                // var extent = this._extent;\n\t                var interval = this._interval;\n\t                if (!fixMin) {\n\t                    extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n\t                }\n\t                if (!fixMax) {\n\t                    extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n\t                }\n\t            }\n\t        });\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    IntervalScale.create = function () {\n\t        return new IntervalScale();\n\t    };\n\t    return IntervalScale;\n\t});\n\tdefine('zrender/core/env', [], function () {\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            canvasSupported: true\n\t        };\n\t    } else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t    return env;\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/) || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/);\n\t        // IE 12 and 12+\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox)\n\t            browser.firefox = true, browser.version = firefox[1];\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            canvasSupported: document.createElement('canvas').getContext ? true : false,\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 10)\n\t        };\n\t    }\n\t});\n\tdefine('echarts/ExtensionAPI', ['require', 'zrender/core/util'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var echartsAPIList = [\n\t            'getDom',\n\t            'getZr',\n\t            'getWidth',\n\t            'getHeight',\n\t            'dispatchAction',\n\t            'isDisposed',\n\t            'on',\n\t            'off',\n\t            'getDataURL',\n\t            'getConnectedDataURL',\n\t            'getModel',\n\t            'getOption'\n\t        ];\n\t    function ExtensionAPI(chartInstance) {\n\t        zrUtil.each(echartsAPIList, function (name) {\n\t            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n\t        }, this);\n\t    }\n\t    return ExtensionAPI;\n\t});\n\tdefine('echarts/model/Global', ['require', 'zrender/core/util', '../util/model', './Model', './Component', './globalDefault', './mixin/colorPalette'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var Model = require('./Model');\n\t    var each = zrUtil.each;\n\t    var filter = zrUtil.filter;\n\t    var map = zrUtil.map;\n\t    var isArray = zrUtil.isArray;\n\t    var indexOf = zrUtil.indexOf;\n\t    var isObject = zrUtil.isObject;\n\t    var ComponentModel = require('./Component');\n\t    var globalDefault = require('./globalDefault');\n\t    var OPTION_INNER_KEY = '\u0000_ec_inner';\n\t    /**\n\t     * @alias module:echarts/model/Global\n\t     *\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {Object} theme\n\t     */\n\t    var GlobalModel = Model.extend({\n\t            constructor: GlobalModel,\n\t            init: function (option, parentModel, theme, optionManager) {\n\t                theme = theme || {};\n\t                this.option = null;\n\t                // Mark as not initialized.\n\t                /**\n\t             * @type {module:echarts/model/Model}\n\t             * @private\n\t             */\n\t                this._theme = new Model(theme);\n\t                /**\n\t             * @type {module:echarts/model/OptionManager}\n\t             */\n\t                this._optionManager = optionManager;\n\t            },\n\t            setOption: function (option, optionPreprocessorFuncs) {\n\t                zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\t                this._optionManager.setOption(option, optionPreprocessorFuncs);\n\t                this.resetOption();\n\t            },\n\t            resetOption: function (type) {\n\t                var optionChanged = false;\n\t                var optionManager = this._optionManager;\n\t                if (!type || type === 'recreate') {\n\t                    var baseOption = optionManager.mountOption(type === 'recreate');\n\t                    if (!this.option || type === 'recreate') {\n\t                        initBase.call(this, baseOption);\n\t                    } else {\n\t                        this.restoreData();\n\t                        this.mergeOption(baseOption);\n\t                    }\n\t                    optionChanged = true;\n\t                }\n\t                if (type === 'timeline' || type === 'media') {\n\t                    this.restoreData();\n\t                }\n\t                if (!type || type === 'recreate' || type === 'timeline') {\n\t                    var timelineOption = optionManager.getTimelineOption(this);\n\t                    timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n\t                }\n\t                if (!type || type === 'recreate' || type === 'media') {\n\t                    var mediaOptions = optionManager.getMediaOption(this, this._api);\n\t                    if (mediaOptions.length) {\n\t                        each(mediaOptions, function (mediaOption) {\n\t                            this.mergeOption(mediaOption, optionChanged = true);\n\t                        }, this);\n\t                    }\n\t                }\n\t                return optionChanged;\n\t            },\n\t            mergeOption: function (newOption) {\n\t                var option = this.option;\n\t                var componentsMap = this._componentsMap;\n\t                var newCptTypes = [];\n\t                //  component model  merge\n\t                each(newOption, function (componentOption, mainType) {\n\t                    if (componentOption == null) {\n\t                        return;\n\t                    }\n\t                    if (!ComponentModel.hasClass(mainType)) {\n\t                        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n\t                    } else {\n\t                        newCptTypes.push(mainType);\n\t                    }\n\t                });\n\t                // FIXME OPTION \n\t                ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\t                this._seriesIndices = this._seriesIndices || [];\n\t                function visitComponent(mainType, dependencies) {\n\t                    var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\t                    var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);\n\t                    makeKeyInfo(mainType, mapResult);\n\t                    var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n\t                    option[mainType] = [];\n\t                    componentsMap[mainType] = [];\n\t                    each(mapResult, function (resultItem, index) {\n\t                        var componentModel = resultItem.exist;\n\t                        var newCptOption = resultItem.option;\n\t                        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');\n\t                        // Consider where is no new option and should be merged using {},\n\t                        // see removeEdgeAndAdd in topologicalTravel and\n\t                        // ComponentModel.getAllClassMainTypes.\n\t                        if (!newCptOption) {\n\t                            componentModel.mergeOption({}, this);\n\t                            componentModel.optionUpdated({}, false);\n\t                        } else {\n\t                            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\t                            if (componentModel && componentModel instanceof ComponentModelClass) {\n\t                                componentModel.mergeOption(newCptOption, this);\n\t                                componentModel.optionUpdated(newCptOption, false);\n\t                            } else {\n\t                                // PENDING Global as parent ?\n\t                                var extraOpt = zrUtil.extend({\n\t                                        dependentModels: dependentModels,\n\t                                        componentIndex: index\n\t                                    }, resultItem.keyInfo);\n\t                                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n\t                                componentModel.init(newCptOption, this, this, extraOpt);\n\t                                // Call optionUpdated after init.\n\t                                // newCptOption has been used as componentModel.option\n\t                                // and may be merged with theme and default, so pass null\n\t                                // to avoid confusion.\n\t                                componentModel.optionUpdated(null, true);\n\t                            }\n\t                        }\n\t                        componentsMap[mainType][index] = componentModel;\n\t                        option[mainType][index] = componentModel.option;\n\t                    }, this);\n\t                    // Backup series for filtering.\n\t                    if (mainType === 'series') {\n\t                        this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                    }\n\t                }\n\t            },\n\t            getOption: function () {\n\t                var option = zrUtil.clone(this.option);\n\t                each(option, function (opts, mainType) {\n\t                    if (ComponentModel.hasClass(mainType)) {\n\t                        var opts = modelUtil.normalizeToArray(opts);\n\t                        for (var i = opts.length - 1; i >= 0; i--) {\n\t                            // Remove options with inner id.\n\t                            if (modelUtil.isIdInner(opts[i])) {\n\t                                opts.splice(i, 1);\n\t                            }\n\t                        }\n\t                        option[mainType] = opts;\n\t                    }\n\t                });\n\t                delete option[OPTION_INNER_KEY];\n\t                return option;\n\t            },\n\t            getTheme: function () {\n\t                return this._theme;\n\t            },\n\t            getComponent: function (mainType, idx) {\n\t                var list = this._componentsMap[mainType];\n\t                if (list) {\n\t                    return list[idx || 0];\n\t                }\n\t            },\n\t            queryComponents: function (condition) {\n\t                var mainType = condition.mainType;\n\t                if (!mainType) {\n\t                    return [];\n\t                }\n\t                var index = condition.index;\n\t                var id = condition.id;\n\t                var name = condition.name;\n\t                var cpts = this._componentsMap[mainType];\n\t                if (!cpts || !cpts.length) {\n\t                    return [];\n\t                }\n\t                var result;\n\t                if (index != null) {\n\t                    if (!isArray(index)) {\n\t                        index = [index];\n\t                    }\n\t                    result = filter(map(index, function (idx) {\n\t                        return cpts[idx];\n\t                    }), function (val) {\n\t                        return !!val;\n\t                    });\n\t                } else if (id != null) {\n\t                    var isIdArray = isArray(id);\n\t                    result = filter(cpts, function (cpt) {\n\t                        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n\t                    });\n\t                } else if (name != null) {\n\t                    var isNameArray = isArray(name);\n\t                    result = filter(cpts, function (cpt) {\n\t                        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n\t                    });\n\t                } else {\n\t                    // Return all components with mainType\n\t                    result = cpts;\n\t                }\n\t                return filterBySubType(result, condition);\n\t            },\n\t            findComponents: function (condition) {\n\t                var query = condition.query;\n\t                var mainType = condition.mainType;\n\t                var queryCond = getQueryCond(query);\n\t                var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];\n\t                return doFilter(filterBySubType(result, condition));\n\t                function getQueryCond(q) {\n\t                    var indexAttr = mainType + 'Index';\n\t                    var idAttr = mainType + 'Id';\n\t                    var nameAttr = mainType + 'Name';\n\t                    return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {\n\t                        mainType: mainType,\n\t                        index: q[indexAttr],\n\t                        id: q[idAttr],\n\t                        name: q[nameAttr]\n\t                    } : null;\n\t                }\n\t                function doFilter(res) {\n\t                    return condition.filter ? filter(res, condition.filter) : res;\n\t                }\n\t            },\n\t            eachComponent: function (mainType, cb, context) {\n\t                var componentsMap = this._componentsMap;\n\t                if (typeof mainType === 'function') {\n\t                    context = cb;\n\t                    cb = mainType;\n\t                    each(componentsMap, function (components, componentType) {\n\t                        each(components, function (component, index) {\n\t                            cb.call(context, componentType, component, index);\n\t                        });\n\t                    });\n\t                } else if (zrUtil.isString(mainType)) {\n\t                    each(componentsMap[mainType], cb, context);\n\t                } else if (isObject(mainType)) {\n\t                    var queryResult = this.findComponents(mainType);\n\t                    each(queryResult, cb, context);\n\t                }\n\t            },\n\t            getSeriesByName: function (name) {\n\t                var series = this._componentsMap.series;\n\t                return filter(series, function (oneSeries) {\n\t                    return oneSeries.name === name;\n\t                });\n\t            },\n\t            getSeriesByIndex: function (seriesIndex) {\n\t                return this._componentsMap.series[seriesIndex];\n\t            },\n\t            getSeriesByType: function (subType) {\n\t                var series = this._componentsMap.series;\n\t                return filter(series, function (oneSeries) {\n\t                    return oneSeries.subType === subType;\n\t                });\n\t            },\n\t            getSeries: function () {\n\t                return this._componentsMap.series.slice();\n\t            },\n\t            eachSeries: function (cb, context) {\n\t                assertSeriesInitialized(this);\n\t                each(this._seriesIndices, function (rawSeriesIndex) {\n\t                    var series = this._componentsMap.series[rawSeriesIndex];\n\t                    cb.call(context, series, rawSeriesIndex);\n\t                }, this);\n\t            },\n\t            eachRawSeries: function (cb, context) {\n\t                each(this._componentsMap.series, cb, context);\n\t            },\n\t            eachSeriesByType: function (subType, cb, context) {\n\t                assertSeriesInitialized(this);\n\t                each(this._seriesIndices, function (rawSeriesIndex) {\n\t                    var series = this._componentsMap.series[rawSeriesIndex];\n\t                    if (series.subType === subType) {\n\t                        cb.call(context, series, rawSeriesIndex);\n\t                    }\n\t                }, this);\n\t            },\n\t            eachRawSeriesByType: function (subType, cb, context) {\n\t                return each(this.getSeriesByType(subType), cb, context);\n\t            },\n\t            isSeriesFiltered: function (seriesModel) {\n\t                assertSeriesInitialized(this);\n\t                return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n\t            },\n\t            filterSeries: function (cb, context) {\n\t                assertSeriesInitialized(this);\n\t                var filteredSeries = filter(this._componentsMap.series, cb, context);\n\t                this._seriesIndices = createSeriesIndices(filteredSeries);\n\t            },\n\t            restoreData: function () {\n\t                var componentsMap = this._componentsMap;\n\t                this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                var componentTypes = [];\n\t                each(componentsMap, function (components, componentType) {\n\t                    componentTypes.push(componentType);\n\t                });\n\t                ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n\t                    each(componentsMap[componentType], function (component) {\n\t                        component.restoreData();\n\t                    });\n\t                });\n\t            }\n\t        });\n\t    /**\n\t     * @inner\n\t     */\n\t    function mergeTheme(option, theme) {\n\t        for (var name in theme) {\n\t            //  component model  merge  model \n\t            if (!ComponentModel.hasClass(name)) {\n\t                if (typeof theme[name] === 'object') {\n\t                    option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);\n\t                } else {\n\t                    if (option[name] == null) {\n\t                        option[name] = theme[name];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    function initBase(baseOption) {\n\t        baseOption = baseOption;\n\t        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n\t        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\t        this.option = {};\n\t        this.option[OPTION_INNER_KEY] = 1;\n\t        /**\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t        /**\n\t         * Mapping between filtered series list and raw series list.\n\t         * key: filtered series indices, value: raw series indices.\n\t         * @type {Array.<nubmer>}\n\t         * @private\n\t         */\n\t        this._seriesIndices = null;\n\t        mergeTheme(baseOption, this._theme.option);\n\t        // TODO Needs clone when merging to the unexisted property\n\t        zrUtil.merge(baseOption, globalDefault, false);\n\t        this.mergeOption(baseOption);\n\t    }\n\t    /**\n\t     * @inner\n\t     * @param {Array.<string>|string} types model types\n\t     * @return {Object} key: {string} type, value: {Array.<Object>} models\n\t     */\n\t    function getComponentsByTypes(componentsMap, types) {\n\t        if (!zrUtil.isArray(types)) {\n\t            types = types ? [types] : [];\n\t        }\n\t        var ret = {};\n\t        each(types, function (type) {\n\t            ret[type] = (componentsMap[type] || []).slice();\n\t        });\n\t        return ret;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeKeyInfo(mainType, mapResult) {\n\t        // We use this id to hash component models and view instances\n\t        // in echarts. id can be specified by user, or auto generated.\n\t        // The id generation rule ensures new view instance are able\n\t        // to mapped to old instance when setOption are called in\n\t        // no-merge mode. So we generate model id by name and plus\n\t        // type in view id.\n\t        // name can be duplicated among components, which is convenient\n\t        // to specify multi components (like series) by one name.\n\t        // Ensure that each id is distinct.\n\t        var idMap = {};\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            existCpt && (idMap[existCpt.id] = item);\n\t        });\n\t        each(mapResult, function (item, index) {\n\t            var opt = item.option;\n\t            zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));\n\t            opt && opt.id != null && (idMap[opt.id] = item);\n\t            // Complete subType\n\t            if (isObject(opt)) {\n\t                var subType = determineSubType(mainType, opt, item.exist);\n\t                item.keyInfo = {\n\t                    mainType: mainType,\n\t                    subType: subType\n\t                };\n\t            }\n\t        });\n\t        // Make name and id.\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            var opt = item.option;\n\t            var keyInfo = item.keyInfo;\n\t            if (!isObject(opt)) {\n\t                return;\n\t            }\n\t            // name can be overwitten. Consider case: axis.name = '20km'.\n\t            // But id generated by name will not be changed, which affect\n\t            // only in that case: setOption with 'not merge mode' and view\n\t            // instance will be recreated, which can be accepted.\n\t            keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\u0000-';\n\t            if (existCpt) {\n\t                keyInfo.id = existCpt.id;\n\t            } else if (opt.id != null) {\n\t                keyInfo.id = opt.id + '';\n\t            } else {\n\t                // Consider this situatoin:\n\t                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n\t                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n\t                // Series with the same name between optionA and optionB\n\t                // should be mapped.\n\t                var idNum = 0;\n\t                do {\n\t                    keyInfo.id = '\u0000' + keyInfo.name + '\u0000' + idNum++;\n\t                } while (idMap[keyInfo.id]);\n\t            }\n\t            idMap[keyInfo.id] = item;\n\t        });\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function determineSubType(mainType, newCptOption, existComponent) {\n\t        var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);\n\t        // tooltip, markline, markpoint may always has no subType\n\t        return subType;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function createSeriesIndices(seriesModels) {\n\t        return map(seriesModels, function (series) {\n\t            return series.componentIndex;\n\t        }) || [];\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function filterBySubType(components, condition) {\n\t        // Using hasOwnProperty for restrict. Consider\n\t        // subType is undefined in user payload.\n\t        return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n\t            return cpt.subType === condition.subType;\n\t        }) : components;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function assertSeriesInitialized(ecModel) {\n\t        // Components that use _seriesIndices should depends on series component,\n\t        // which make sure that their initialization is after series.\n\t        if (true) {\n\t            if (!ecModel._seriesIndices) {\n\t                throw new Error('Series has not been initialized yet.');\n\t            }\n\t        }\n\t    }\n\t    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\t    return GlobalModel;\n\t});\n\tdefine('echarts/model/OptionManager', ['require', 'zrender/core/util', '../util/model', './Component'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var ComponentModel = require('./Component');\n\t    var each = zrUtil.each;\n\t    var clone = zrUtil.clone;\n\t    var map = zrUtil.map;\n\t    var merge = zrUtil.merge;\n\t    var QUERY_REG = /^(min|max)?(.+)$/;\n\t    /**\n\t     * TERM EXPLANATIONS:\n\t     *\n\t     * [option]:\n\t     *\n\t     *     An object that contains definitions of components. For example:\n\t     *     var option = {\n\t     *         title: {...},\n\t     *         legend: {...},\n\t     *         visualMap: {...},\n\t     *         series: [\n\t     *             {data: [...]},\n\t     *             {data: [...]},\n\t     *             ...\n\t     *         ]\n\t     *     };\n\t     *\n\t     * [rawOption]:\n\t     *\n\t     *     An object input to echarts.setOption. 'rawOption' may be an\n\t     *     'option', or may be an object contains multi-options. For example:\n\t     *     var option = {\n\t     *         baseOption: {\n\t     *             title: {...},\n\t     *             legend: {...},\n\t     *             series: [\n\t     *                 {data: [...]},\n\t     *                 {data: [...]},\n\t     *                 ...\n\t     *             ]\n\t     *         },\n\t     *         timeline: {...},\n\t     *         options: [\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             ...\n\t     *         ],\n\t     *         media: [\n\t     *             {\n\t     *                 query: {maxWidth: 320},\n\t     *                 option: {series: {x: 20}, visualMap: {show: false}}\n\t     *             },\n\t     *             {\n\t     *                 query: {minWidth: 320, maxWidth: 720},\n\t     *                 option: {series: {x: 500}, visualMap: {show: true}}\n\t     *             },\n\t     *             {\n\t     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n\t     *             }\n\t     *         ]\n\t     *     };\n\t     *\n\t     * @alias module:echarts/model/OptionManager\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function OptionManager(api) {\n\t        /**\n\t         * @private\n\t         * @type {module:echarts/ExtensionAPI}\n\t         */\n\t        this._api = api;\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._timelineOptions = [];\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._mediaList = [];\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._mediaDefault;\n\t        /**\n\t         * -1, means default.\n\t         * empty means no media.\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._currentMediaIndices = [];\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._optionBackup;\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._newBaseOption;\n\t    }\n\t    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n\t    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n\t    // rawOption cloned and backuped when timeline changed, which does no\n\t    // good to performance. What's more, that both timeline and setOption\n\t    // method supply 'notMerge' brings complex and some problems.\n\t    // Consider this case:\n\t    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n\t    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\t    OptionManager.prototype = {\n\t        constructor: OptionManager,\n\t        setOption: function (rawOption, optionPreprocessorFuncs) {\n\t            rawOption = clone(rawOption, true);\n\t            // FIXME\n\t            //  timeline options  media baseOption\n\t            var oldOptionBackup = this._optionBackup;\n\t            var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n\t            this._newBaseOption = newParsedOption.baseOption;\n\t            // For setOption at second time (using merge mode);\n\t            if (oldOptionBackup) {\n\t                // Only baseOption can be merged.\n\t                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\t                // For simplicity, timeline options and media options do not support merge,\n\t                // that is, if you `setOption` twice and both has timeline options, the latter\n\t                // timeline opitons will not be merged to the formers, but just substitude them.\n\t                if (newParsedOption.timelineOptions.length) {\n\t                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n\t                }\n\t                if (newParsedOption.mediaList.length) {\n\t                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n\t                }\n\t                if (newParsedOption.mediaDefault) {\n\t                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n\t                }\n\t            } else {\n\t                this._optionBackup = newParsedOption;\n\t            }\n\t        },\n\t        mountOption: function (isRecreate) {\n\t            var optionBackup = this._optionBackup;\n\t            // TODO\n\t            // resetclone\n\t            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n\t            this._mediaList = map(optionBackup.mediaList, clone);\n\t            this._mediaDefault = clone(optionBackup.mediaDefault);\n\t            this._currentMediaIndices = [];\n\t            return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);\n\t        },\n\t        getTimelineOption: function (ecModel) {\n\t            var option;\n\t            var timelineOptions = this._timelineOptions;\n\t            if (timelineOptions.length) {\n\t                // getTimelineOption can only be called after ecModel inited,\n\t                // so we can get currentIndex from timelineModel.\n\t                var timelineModel = ecModel.getComponent('timeline');\n\t                if (timelineModel) {\n\t                    option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n\t                }\n\t            }\n\t            return option;\n\t        },\n\t        getMediaOption: function (ecModel) {\n\t            var ecWidth = this._api.getWidth();\n\t            var ecHeight = this._api.getHeight();\n\t            var mediaList = this._mediaList;\n\t            var mediaDefault = this._mediaDefault;\n\t            var indices = [];\n\t            var result = [];\n\t            // No media defined.\n\t            if (!mediaList.length && !mediaDefault) {\n\t                return result;\n\t            }\n\t            // Multi media may be applied, the latter defined media has higher priority.\n\t            for (var i = 0, len = mediaList.length; i < len; i++) {\n\t                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n\t                    indices.push(i);\n\t                }\n\t            }\n\t            // FIXME\n\t            // mediaDefault\n\t            if (!indices.length && mediaDefault) {\n\t                indices = [-1];\n\t            }\n\t            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n\t                result = map(indices, function (index) {\n\t                    return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n\t                });\n\t            }\n\t            // Otherwise return nothing.\n\t            this._currentMediaIndices = indices;\n\t            return result;\n\t        }\n\t    };\n\t    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n\t        var timelineOptions = [];\n\t        var mediaList = [];\n\t        var mediaDefault;\n\t        var baseOption;\n\t        // Compatible with ec2.\n\t        var timelineOpt = rawOption.timeline;\n\t        if (rawOption.baseOption) {\n\t            baseOption = rawOption.baseOption;\n\t        }\n\t        // For timeline\n\t        if (timelineOpt || rawOption.options) {\n\t            baseOption = baseOption || {};\n\t            timelineOptions = (rawOption.options || []).slice();\n\t        }\n\t        // For media query\n\t        if (rawOption.media) {\n\t            baseOption = baseOption || {};\n\t            var media = rawOption.media;\n\t            each(media, function (singleMedia) {\n\t                if (singleMedia && singleMedia.option) {\n\t                    if (singleMedia.query) {\n\t                        mediaList.push(singleMedia);\n\t                    } else if (!mediaDefault) {\n\t                        // Use the first media default.\n\t                        mediaDefault = singleMedia;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        // For normal option\n\t        if (!baseOption) {\n\t            baseOption = rawOption;\n\t        }\n\t        // Set timelineOpt to baseOption in ec3,\n\t        // which is convenient for merge option.\n\t        if (!baseOption.timeline) {\n\t            baseOption.timeline = timelineOpt;\n\t        }\n\t        // Preprocess.\n\t        each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n\t            return media.option;\n\t        })), function (option) {\n\t            each(optionPreprocessorFuncs, function (preProcess) {\n\t                preProcess(option, isNew);\n\t            });\n\t        });\n\t        return {\n\t            baseOption: baseOption,\n\t            timelineOptions: timelineOptions,\n\t            mediaDefault: mediaDefault,\n\t            mediaList: mediaList\n\t        };\n\t    }\n\t    /**\n\t     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n\t     * Support: width, height, aspectRatio\n\t     * Can use max or min as prefix.\n\t     */\n\t    function applyMediaQuery(query, ecWidth, ecHeight) {\n\t        var realMap = {\n\t                width: ecWidth,\n\t                height: ecHeight,\n\t                aspectratio: ecWidth / ecHeight\n\t            };\n\t        var applicatable = true;\n\t        zrUtil.each(query, function (value, attr) {\n\t            var matched = attr.match(QUERY_REG);\n\t            if (!matched || !matched[1] || !matched[2]) {\n\t                return;\n\t            }\n\t            var operator = matched[1];\n\t            var realAttr = matched[2].toLowerCase();\n\t            if (!compare(realMap[realAttr], value, operator)) {\n\t                applicatable = false;\n\t            }\n\t        });\n\t        return applicatable;\n\t    }\n\t    function compare(real, expect, operator) {\n\t        if (operator === 'min') {\n\t            return real >= expect;\n\t        } else if (operator === 'max') {\n\t            return real <= expect;\n\t        } else {\n\t            // Equals\n\t            return real === expect;\n\t        }\n\t    }\n\t    function indicesEquals(indices1, indices2) {\n\t        // indices is always order by asc and has only finite number.\n\t        return indices1.join(',') === indices2.join(',');\n\t    }\n\t    /**\n\t     * Consider case:\n\t     * `chart.setOption(opt1);`\n\t     * Then user do some interaction like dataZoom, dataView changing.\n\t     * `chart.setOption(opt2);`\n\t     * Then user press 'reset button' in toolbox.\n\t     *\n\t     * After doing that all of the interaction effects should be reset, the\n\t     * chart should be the same as the result of invoke\n\t     * `chart.setOption(opt1); chart.setOption(opt2);`.\n\t     *\n\t     * Although it is not able ensure that\n\t     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n\t     * `chart.setOption(merge(opt1, opt2));` exactly,\n\t     * this might be the only simple way to implement that feature.\n\t     *\n\t     * MEMO: We've considered some other approaches:\n\t     * 1. Each model handle its self restoration but not uniform treatment.\n\t     *     (Too complex in logic and error-prone)\n\t     * 2. Use a shadow ecModel. (Performace expensive)\n\t     */\n\t    function mergeOption(oldOption, newOption) {\n\t        newOption = newOption || {};\n\t        each(newOption, function (newCptOpt, mainType) {\n\t            if (newCptOpt == null) {\n\t                return;\n\t            }\n\t            var oldCptOpt = oldOption[mainType];\n\t            if (!ComponentModel.hasClass(mainType)) {\n\t                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n\t            } else {\n\t                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n\t                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\t                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\t                oldOption[mainType] = map(mapResult, function (item) {\n\t                    return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n\t                });\n\t            }\n\t        });\n\t    }\n\t    return OptionManager;\n\t});\n\tdefine('echarts/CoordinateSystem', ['require'], function (require) {\n\t    'use strict';\n\t    var coordinateSystemCreators = {};\n\t    function CoordinateSystemManager() {\n\t        this._coordinateSystems = [];\n\t    }\n\t    CoordinateSystemManager.prototype = {\n\t        constructor: CoordinateSystemManager,\n\t        create: function (ecModel, api) {\n\t            var coordinateSystems = [];\n\t            for (var type in coordinateSystemCreators) {\n\t                var list = coordinateSystemCreators[type].create(ecModel, api);\n\t                list && (coordinateSystems = coordinateSystems.concat(list));\n\t            }\n\t            this._coordinateSystems = coordinateSystems;\n\t        },\n\t        update: function (ecModel, api) {\n\t            var coordinateSystems = this._coordinateSystems;\n\t            for (var i = 0; i < coordinateSystems.length; i++) {\n\t                // FIXME MUST have\n\t                coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);\n\t            }\n\t        }\n\t    };\n\t    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n\t        coordinateSystemCreators[type] = coordinateSystemCreator;\n\t    };\n\t    CoordinateSystemManager.get = function (type) {\n\t        return coordinateSystemCreators[type];\n\t    };\n\t    return CoordinateSystemManager;\n\t});\n\tdefine('echarts/model/Series', ['require', 'zrender/core/util', '../util/format', '../util/model', './Component', './mixin/colorPalette', 'zrender/core/env'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var formatUtil = require('../util/format');\n\t    var modelUtil = require('../util/model');\n\t    var ComponentModel = require('./Component');\n\t    var colorPaletteMixin = require('./mixin/colorPalette');\n\t    var env = require('zrender/core/env');\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t    var addCommas = formatUtil.addCommas;\n\t    var SeriesModel = ComponentModel.extend({\n\t            type: 'series.__base__',\n\t            seriesIndex: 0,\n\t            coordinateSystem: null,\n\t            defaultOption: null,\n\t            legendDataProvider: null,\n\t            visualColorAccessPath: 'itemStyle.normal.color',\n\t            init: function (option, parentModel, ecModel, extraOpt) {\n\t                /**\n\t             * @type {number}\n\t             * @readOnly\n\t             */\n\t                this.seriesIndex = this.componentIndex;\n\t                this.mergeDefaultAndTheme(option, ecModel);\n\t                /**\n\t             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n\t             * @private\n\t             */\n\t                this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\t                // If we reverse the order (make this._data firstly, and then make\n\t                // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n\t                // cause this._data.graph.data !== this._data when using\n\t                // module:echarts/data/Graph or module:echarts/data/Tree.\n\t                // See module:echarts/data/helper/linkList\n\t                this._data = this._dataBeforeProcessed.cloneShallow();\n\t            },\n\t            mergeDefaultAndTheme: function (option, ecModel) {\n\t                zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n\t                zrUtil.merge(option, this.getDefaultOption());\n\t                // Default label emphasis `position` and `show`\n\t                // FIXME Set label in mergeOption\n\t                modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\t                this.fillDataTextStyle(option.data);\n\t            },\n\t            mergeOption: function (newSeriesOption, ecModel) {\n\t                newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n\t                this.fillDataTextStyle(newSeriesOption.data);\n\t                var data = this.getInitialData(newSeriesOption, ecModel);\n\t                // TODO Merge data?\n\t                if (data) {\n\t                    this._data = data;\n\t                    this._dataBeforeProcessed = data.cloneShallow();\n\t                }\n\t            },\n\t            fillDataTextStyle: function (data) {\n\t                // Default data label emphasis `position` and `show`\n\t                // FIXME Tree structure data ?\n\t                // FIXME Performance ?\n\t                if (data) {\n\t                    for (var i = 0; i < data.length; i++) {\n\t                        if (data[i] && data[i].label) {\n\t                            modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            getInitialData: function () {\n\t            },\n\t            getData: function (dataType) {\n\t                return dataType == null ? this._data : this._data.getLinkedData(dataType);\n\t            },\n\t            setData: function (data) {\n\t                this._data = data;\n\t            },\n\t            getRawData: function () {\n\t                return this._dataBeforeProcessed;\n\t            },\n\t            coordDimToDataDim: function (coordDim) {\n\t                return [coordDim];\n\t            },\n\t            dataDimToCoordDim: function (dataDim) {\n\t                return dataDim;\n\t            },\n\t            getBaseAxis: function () {\n\t                var coordSys = this.coordinateSystem;\n\t                return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n\t            },\n\t            formatTooltip: function (dataIndex, multipleSeries, dataType) {\n\t                function formatArrayValue(value) {\n\t                    return zrUtil.map(value, function (val, idx) {\n\t                        var dimInfo = data.getDimensionInfo(idx);\n\t                        var dimType = dimInfo && dimInfo.type;\n\t                        if (dimType === 'ordinal') {\n\t                            return val;\n\t                        } else if (dimType === 'time') {\n\t                            return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n\t                        } else {\n\t                            return addCommas(val);\n\t                        }\n\t                    }).filter(function (val) {\n\t                        return !!val;\n\t                    }).join(', ');\n\t                }\n\t                var data = this._data;\n\t                var value = this.getRawValue(dataIndex);\n\t                var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value);\n\t                var name = data.getName(dataIndex);\n\t                var color = data.getItemVisual(dataIndex, 'color');\n\t                var colorEl = '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\t                var seriesName = this.name;\n\t                // FIXME\n\t                if (seriesName === '\u0000-') {\n\t                    // Not show '-'\n\t                    seriesName = '';\n\t                }\n\t                return !multipleSeries ? (seriesName && encodeHTML(seriesName) + '<br />') + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue) : colorEl + encodeHTML(this.name) + ' : ' + formattedValue;\n\t            },\n\t            ifEnableAnimation: function () {\n\t                if (env.node) {\n\t                    return false;\n\t                }\n\t                var animationEnabled = this.getShallow('animation');\n\t                if (animationEnabled) {\n\t                    if (this.getData().count() > this.getShallow('animationThreshold')) {\n\t                        animationEnabled = false;\n\t                    }\n\t                }\n\t                return animationEnabled;\n\t            },\n\t            restoreData: function () {\n\t                this._data = this._dataBeforeProcessed.cloneShallow();\n\t            },\n\t            getColorFromPalette: function (name, scope) {\n\t                var ecModel = this.ecModel;\n\t                // PENDING\n\t                var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\t                if (!color) {\n\t                    color = ecModel.getColorFromPalette(name, scope);\n\t                }\n\t                return color;\n\t            },\n\t            getAxisTooltipDataIndex: null\n\t        });\n\t    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n\t    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\t    return SeriesModel;\n\t});\n\tdefine('echarts/model/Component', ['require', './Model', 'zrender/core/util', '../util/component', '../util/clazz', '../util/layout', './mixin/boxLayout'], function (require) {\n\t    var Model = require('./Model');\n\t    var zrUtil = require('zrender/core/util');\n\t    var arrayPush = Array.prototype.push;\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    var layout = require('../util/layout');\n\t    /**\n\t     * @alias module:echarts/model/Component\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {module:echarts/model/Model} ecModel\n\t     */\n\t    var ComponentModel = Model.extend({\n\t            type: 'component',\n\t            id: '',\n\t            name: '',\n\t            mainType: '',\n\t            subType: '',\n\t            componentIndex: 0,\n\t            defaultOption: null,\n\t            ecModel: null,\n\t            dependentModels: [],\n\t            uid: null,\n\t            layoutMode: null,\n\t            $constructor: function (option, parentModel, ecModel, extraOpt) {\n\t                Model.call(this, option, parentModel, ecModel, extraOpt);\n\t                // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t                zrUtil.extend(this, extraOpt);\n\t                this.uid = componentUtil.getUID('componentModel');\n\t            },\n\t            init: function (option, parentModel, ecModel, extraOpt) {\n\t                this.mergeDefaultAndTheme(option, ecModel);\n\t            },\n\t            mergeDefaultAndTheme: function (option, ecModel) {\n\t                var layoutMode = this.layoutMode;\n\t                var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n\t                var themeModel = ecModel.getTheme();\n\t                zrUtil.merge(option, themeModel.get(this.mainType));\n\t                zrUtil.merge(option, this.getDefaultOption());\n\t                if (layoutMode) {\n\t                    layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                }\n\t            },\n\t            mergeOption: function (option) {\n\t                zrUtil.merge(this.option, option, true);\n\t                var layoutMode = this.layoutMode;\n\t                if (layoutMode) {\n\t                    layout.mergeLayoutParam(this.option, option, layoutMode);\n\t                }\n\t            },\n\t            optionUpdated: function (newCptOption, isInit) {\n\t            },\n\t            getDefaultOption: function () {\n\t                if (!this.hasOwnProperty('__defaultOption')) {\n\t                    var optList = [];\n\t                    var Class = this.constructor;\n\t                    while (Class) {\n\t                        var opt = Class.prototype.defaultOption;\n\t                        opt && optList.push(opt);\n\t                        Class = Class.superClass;\n\t                    }\n\t                    var defaultOption = {};\n\t                    for (var i = optList.length - 1; i >= 0; i--) {\n\t                        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n\t                    }\n\t                    this.__defaultOption = defaultOption;\n\t                }\n\t                return this.__defaultOption;\n\t            }\n\t        });\n\t    // Reset ComponentModel.extend, add preConstruct.\n\t    // clazzUtil.enableClassExtend(\n\t    //     ComponentModel,\n\t    //     function (option, parentModel, ecModel, extraOpt) {\n\t    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t    //         zrUtil.extend(this, extraOpt);\n\t    //         this.uid = componentUtil.getUID('componentModel');\n\t    //         // this.setReadOnly([\n\t    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n\t    //         //     'dependentModels', 'componentIndex'\n\t    //         // ]);\n\t    //     }\n\t    // );\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(ComponentModel, { registerWhenExtend: true });\n\t    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\t    // Add capability of ComponentModel.topologicalTravel.\n\t    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\t    function getDependencies(componentType) {\n\t        var deps = [];\n\t        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n\t            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n\t        });\n\t        // Ensure main type\n\t        return zrUtil.map(deps, function (type) {\n\t            return clazzUtil.parseClassType(type).main;\n\t        });\n\t    }\n\t    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\t    return ComponentModel;\n\t});\n\tdefine('echarts/view/Component', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n\t    var Group = require('zrender/container/Group');\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    var Component = function () {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewComponent');\n\t    };\n\t    Component.prototype = {\n\t        constructor: Component,\n\t        init: function (ecModel, api) {\n\t        },\n\t        render: function (componentModel, ecModel, api, payload) {\n\t        },\n\t        dispose: function () {\n\t        }\n\t    };\n\t    var componentProto = Component.prototype;\n\t    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n\t    };\n\t    // Enable Component.extend.\n\t    clazzUtil.enableClassExtend(Component);\n\t    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Component, { registerWhenExtend: true });\n\t    return Component;\n\t});\n\tdefine('echarts/view/Chart', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n\t    var Group = require('zrender/container/Group');\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    function Chart() {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewChart');\n\t    }\n\t    Chart.prototype = {\n\t        type: 'chart',\n\t        init: function (ecModel, api) {\n\t        },\n\t        render: function (seriesModel, ecModel, api, payload) {\n\t        },\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n\t        },\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'normal');\n\t        },\n\t        remove: function (ecModel, api) {\n\t            this.group.removeAll();\n\t        },\n\t        dispose: function () {\n\t        }\n\t    };\n\t    var chartProto = Chart.prototype;\n\t    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n\t        this.render(seriesModel, ecModel, api, payload);\n\t    };\n\t    /**\n\t     * Set state of single element\n\t     * @param  {module:zrender/Element} el\n\t     * @param  {string} state\n\t     */\n\t    function elSetState(el, state) {\n\t        if (el) {\n\t            el.trigger(state);\n\t            if (el.type === 'group') {\n\t                for (var i = 0; i < el.childCount(); i++) {\n\t                    elSetState(el.childAt(i), state);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {Object} payload\n\t     * @param  {string} state 'normal'|'emphasis'\n\t     * @inner\n\t     */\n\t    function toggleHighlight(data, payload, state) {\n\t        var dataIndex = payload && payload.dataIndex;\n\t        var name = payload && payload.name;\n\t        if (dataIndex != null) {\n\t            var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];\n\t            for (var i = 0, len = dataIndices.length; i < len; i++) {\n\t                elSetState(data.getItemGraphicEl(dataIndices[i]), state);\n\t            }\n\t        } else if (name) {\n\t            var names = name instanceof Array ? name : [name];\n\t            for (var i = 0, len = names.length; i < len; i++) {\n\t                var dataIndex = data.indexOfName(names[i]);\n\t                elSetState(data.getItemGraphicEl(dataIndex), state);\n\t            }\n\t        } else {\n\t            data.eachItemGraphicEl(function (el) {\n\t                elSetState(el, state);\n\t            });\n\t        }\n\t    }\n\t    // Enable Chart.extend.\n\t    clazzUtil.enableClassExtend(Chart);\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Chart, { registerWhenExtend: true });\n\t    return Chart;\n\t});\n\tdefine('zrender/zrender', ['require', './core/guid', './core/env', './Handler', './Storage', './animation/Animation', './dom/HandlerProxy', './Painter'], function (require) {\n\t    var guid = require('./core/guid');\n\t    var env = require('./core/env');\n\t    var Handler = require('./Handler');\n\t    var Storage = require('./Storage');\n\t    var Animation = require('./animation/Animation');\n\t    var HandlerProxy = require('./dom/HandlerProxy');\n\t    var useVML = !env.canvasSupported;\n\t    var painterCtors = { canvas: require('./Painter') };\n\t    var instances = {};\n\t    // ZRendermap\n\t    var zrender = {};\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.1.3';\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function (dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        } else {\n\t            for (var key in instances) {\n\t                instances[key].dispose();\n\t            }\n\t            instances = {};\n\t        }\n\t        return zrender;\n\t    };\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     */\n\t    var ZRender = function (id, dom, opts) {\n\t        opts = opts || {};\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t        var self = this;\n\t        var storage = new Storage();\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        } else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy);\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: function () {\n\t                    if (self._needsRefresh) {\n\t                        self.refreshImmediately();\n\t                    }\n\t                    if (self._needsRefreshHover) {\n\t                        self.refreshHoverImmediately();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        this.animation.start();\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t        //  storage.delFromMap, \n\t        // FIXME ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t            oldDelFromMap.call(storage, elId);\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t    ZRender.prototype = {\n\t        constructor: ZRender,\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t        refresh: function () {\n\t            this._needsRefresh = true;\n\t        },\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t        resize: function () {\n\t            this.painter.resize();\n\t            this.handler.resize();\n\t        },\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t        getWidth: function () {\n\t            return this.painter.getWidth();\n\t        },\n\t        getHeight: function () {\n\t            return this.painter.getHeight();\n\t        },\n\t        pathToImage: function (e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t        on: function (eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t        off: function (eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t        dispose: function () {\n\t            this.animation.stop();\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t            this.animation = this.storage = this.painter = this.handler = null;\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t    return zrender;\n\t});\n\tdefine('zrender/mixin/Eventful', ['require'], function (require) {\n\t    var arrySlice = Array.prototype.slice;\n\t    /**\n\t     * \n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t    Eventful.prototype = {\n\t        constructor: Eventful,\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t            return this;\n\t        },\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t            return this;\n\t        },\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            } else {\n\t                delete _h[event];\n\t            }\n\t            return this;\n\t        },\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                    case 1:\n\t                        _h[i]['h'].call(_h[i]['ctx']);\n\t                        break;\n\t                    case 2:\n\t                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                        break;\n\t                    case 3:\n\t                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                        break;\n\t                    default:\n\t                        // have more than 2 given arguments\n\t                        _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                        break;\n\t                    }\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    } else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                    case 1:\n\t                        _h[i]['h'].call(ctx);\n\t                        break;\n\t                    case 2:\n\t                        _h[i]['h'].call(ctx, args[1]);\n\t                        break;\n\t                    case 3:\n\t                        _h[i]['h'].call(ctx, args[1], args[2]);\n\t                        break;\n\t                    default:\n\t                        // have more than 2 given arguments\n\t                        _h[i]['h'].apply(ctx, args);\n\t                        break;\n\t                    }\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    } else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    };\n\t    //  onxxxx \n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    return Eventful;\n\t});\n\tdefine('zrender/tool/color', ['require'], function (require) {\n\t    var kCSSColorTable = {\n\t            'transparent': [\n\t                0,\n\t                0,\n\t                0,\n\t                0\n\t            ],\n\t            'aliceblue': [\n\t                240,\n\t                248,\n\t                255,\n\t                1\n\t            ],\n\t            'antiquewhite': [\n\t                250,\n\t                235,\n\t                215,\n\t                1\n\t            ],\n\t            'aqua': [\n\t                0,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'aquamarine': [\n\t                127,\n\t                255,\n\t                212,\n\t                1\n\t            ],\n\t            'azure': [\n\t                240,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'beige': [\n\t                245,\n\t                245,\n\t                220,\n\t                1\n\t            ],\n\t            'bisque': [\n\t                255,\n\t                228,\n\t                196,\n\t                1\n\t            ],\n\t            'black': [\n\t                0,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'blanchedalmond': [\n\t                255,\n\t                235,\n\t                205,\n\t                1\n\t            ],\n\t            'blue': [\n\t                0,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'blueviolet': [\n\t                138,\n\t                43,\n\t                226,\n\t                1\n\t            ],\n\t            'brown': [\n\t                165,\n\t                42,\n\t                42,\n\t                1\n\t            ],\n\t            'burlywood': [\n\t                222,\n\t                184,\n\t                135,\n\t                1\n\t            ],\n\t            'cadetblue': [\n\t                95,\n\t                158,\n\t                160,\n\t                1\n\t            ],\n\t            'chartreuse': [\n\t                127,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'chocolate': [\n\t                210,\n\t                105,\n\t                30,\n\t                1\n\t            ],\n\t            'coral': [\n\t                255,\n\t                127,\n\t                80,\n\t                1\n\t            ],\n\t            'cornflowerblue': [\n\t                100,\n\t                149,\n\t                237,\n\t                1\n\t            ],\n\t            'cornsilk': [\n\t                255,\n\t                248,\n\t                220,\n\t                1\n\t            ],\n\t            'crimson': [\n\t                220,\n\t                20,\n\t                60,\n\t                1\n\t            ],\n\t            'cyan': [\n\t                0,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'darkblue': [\n\t                0,\n\t                0,\n\t                139,\n\t                1\n\t            ],\n\t            'darkcyan': [\n\t                0,\n\t                139,\n\t                139,\n\t                1\n\t            ],\n\t            'darkgoldenrod': [\n\t                184,\n\t                134,\n\t                11,\n\t                1\n\t            ],\n\t            'darkgray': [\n\t                169,\n\t                169,\n\t                169,\n\t                1\n\t            ],\n\t            'darkgreen': [\n\t                0,\n\t                100,\n\t                0,\n\t                1\n\t            ],\n\t            'darkgrey': [\n\t                169,\n\t                169,\n\t                169,\n\t                1\n\t            ],\n\t            'darkkhaki': [\n\t                189,\n\t                183,\n\t                107,\n\t                1\n\t            ],\n\t            'darkmagenta': [\n\t                139,\n\t                0,\n\t                139,\n\t                1\n\t            ],\n\t            'darkolivegreen': [\n\t                85,\n\t                107,\n\t                47,\n\t                1\n\t            ],\n\t            'darkorange': [\n\t                255,\n\t                140,\n\t                0,\n\t                1\n\t            ],\n\t            'darkorchid': [\n\t                153,\n\t                50,\n\t                204,\n\t                1\n\t            ],\n\t            'darkred': [\n\t                139,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'darksalmon': [\n\t                233,\n\t                150,\n\t                122,\n\t                1\n\t            ],\n\t            'darkseagreen': [\n\t                143,\n\t                188,\n\t                143,\n\t                1\n\t            ],\n\t            'darkslateblue': [\n\t                72,\n\t                61,\n\t                139,\n\t                1\n\t            ],\n\t            'darkslategray': [\n\t                47,\n\t                79,\n\t                79,\n\t                1\n\t            ],\n\t            'darkslategrey': [\n\t                47,\n\t                79,\n\t                79,\n\t                1\n\t            ],\n\t            'darkturquoise': [\n\t                0,\n\t                206,\n\t                209,\n\t                1\n\t            ],\n\t            'darkviolet': [\n\t                148,\n\t                0,\n\t                211,\n\t                1\n\t            ],\n\t            'deeppink': [\n\t                255,\n\t                20,\n\t                147,\n\t                1\n\t            ],\n\t            'deepskyblue': [\n\t                0,\n\t                191,\n\t                255,\n\t                1\n\t            ],\n\t            'dimgray': [\n\t                105,\n\t                105,\n\t                105,\n\t                1\n\t            ],\n\t            'dimgrey': [\n\t                105,\n\t                105,\n\t                105,\n\t                1\n\t            ],\n\t            'dodgerblue': [\n\t                30,\n\t                144,\n\t                255,\n\t                1\n\t            ],\n\t            'firebrick': [\n\t                178,\n\t                34,\n\t                34,\n\t                1\n\t            ],\n\t            'floralwhite': [\n\t                255,\n\t                250,\n\t                240,\n\t                1\n\t            ],\n\t            'forestgreen': [\n\t                34,\n\t                139,\n\t                34,\n\t                1\n\t            ],\n\t            'fuchsia': [\n\t                255,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'gainsboro': [\n\t                220,\n\t                220,\n\t                220,\n\t                1\n\t            ],\n\t            'ghostwhite': [\n\t                248,\n\t                248,\n\t                255,\n\t                1\n\t            ],\n\t            'gold': [\n\t                255,\n\t                215,\n\t                0,\n\t                1\n\t            ],\n\t            'goldenrod': [\n\t                218,\n\t                165,\n\t                32,\n\t                1\n\t            ],\n\t            'gray': [\n\t                128,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'green': [\n\t                0,\n\t                128,\n\t                0,\n\t                1\n\t            ],\n\t            'greenyellow': [\n\t                173,\n\t                255,\n\t                47,\n\t                1\n\t            ],\n\t            'grey': [\n\t                128,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'honeydew': [\n\t                240,\n\t                255,\n\t                240,\n\t                1\n\t            ],\n\t            'hotpink': [\n\t                255,\n\t                105,\n\t                180,\n\t                1\n\t            ],\n\t            'indianred': [\n\t                205,\n\t                92,\n\t                92,\n\t                1\n\t            ],\n\t            'indigo': [\n\t                75,\n\t                0,\n\t                130,\n\t                1\n\t            ],\n\t            'ivory': [\n\t                255,\n\t                255,\n\t                240,\n\t                1\n\t            ],\n\t            'khaki': [\n\t                240,\n\t                230,\n\t                140,\n\t                1\n\t            ],\n\t            'lavender': [\n\t                230,\n\t                230,\n\t                250,\n\t                1\n\t            ],\n\t            'lavenderblush': [\n\t                255,\n\t                240,\n\t                245,\n\t                1\n\t            ],\n\t            'lawngreen': [\n\t                124,\n\t                252,\n\t                0,\n\t                1\n\t            ],\n\t            'lemonchiffon': [\n\t                255,\n\t                250,\n\t                205,\n\t                1\n\t            ],\n\t            'lightblue': [\n\t                173,\n\t                216,\n\t                230,\n\t                1\n\t            ],\n\t            'lightcoral': [\n\t                240,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'lightcyan': [\n\t                224,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'lightgoldenrodyellow': [\n\t                250,\n\t                250,\n\t                210,\n\t                1\n\t            ],\n\t            'lightgray': [\n\t                211,\n\t                211,\n\t                211,\n\t                1\n\t            ],\n\t            'lightgreen': [\n\t                144,\n\t                238,\n\t                144,\n\t                1\n\t            ],\n\t            'lightgrey': [\n\t                211,\n\t                211,\n\t                211,\n\t                1\n\t            ],\n\t            'lightpink': [\n\t                255,\n\t                182,\n\t                193,\n\t                1\n\t            ],\n\t            'lightsalmon': [\n\t                255,\n\t                160,\n\t                122,\n\t                1\n\t            ],\n\t            'lightseagreen': [\n\t                32,\n\t                178,\n\t                170,\n\t                1\n\t            ],\n\t            'lightskyblue': [\n\t                135,\n\t                206,\n\t                250,\n\t                1\n\t            ],\n\t            'lightslategray': [\n\t                119,\n\t                136,\n\t                153,\n\t                1\n\t            ],\n\t            'lightslategrey': [\n\t                119,\n\t                136,\n\t                153,\n\t                1\n\t            ],\n\t            'lightsteelblue': [\n\t                176,\n\t                196,\n\t                222,\n\t                1\n\t            ],\n\t            'lightyellow': [\n\t                255,\n\t                255,\n\t                224,\n\t                1\n\t            ],\n\t            'lime': [\n\t                0,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'limegreen': [\n\t                50,\n\t                205,\n\t                50,\n\t                1\n\t            ],\n\t            'linen': [\n\t                250,\n\t                240,\n\t                230,\n\t                1\n\t            ],\n\t            'magenta': [\n\t                255,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'maroon': [\n\t                128,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'mediumaquamarine': [\n\t                102,\n\t                205,\n\t                170,\n\t                1\n\t            ],\n\t            'mediumblue': [\n\t                0,\n\t                0,\n\t                205,\n\t                1\n\t            ],\n\t            'mediumorchid': [\n\t                186,\n\t                85,\n\t                211,\n\t                1\n\t            ],\n\t            'mediumpurple': [\n\t                147,\n\t                112,\n\t                219,\n\t                1\n\t            ],\n\t            'mediumseagreen': [\n\t                60,\n\t                179,\n\t                113,\n\t                1\n\t            ],\n\t            'mediumslateblue': [\n\t                123,\n\t                104,\n\t                238,\n\t                1\n\t            ],\n\t            'mediumspringgreen': [\n\t                0,\n\t                250,\n\t                154,\n\t                1\n\t            ],\n\t            'mediumturquoise': [\n\t                72,\n\t                209,\n\t                204,\n\t                1\n\t            ],\n\t            'mediumvioletred': [\n\t                199,\n\t                21,\n\t                133,\n\t                1\n\t            ],\n\t            'midnightblue': [\n\t                25,\n\t                25,\n\t                112,\n\t                1\n\t            ],\n\t            'mintcream': [\n\t                245,\n\t                255,\n\t                250,\n\t                1\n\t            ],\n\t            'mistyrose': [\n\t                255,\n\t                228,\n\t                225,\n\t                1\n\t            ],\n\t            'moccasin': [\n\t                255,\n\t                228,\n\t                181,\n\t                1\n\t            ],\n\t            'navajowhite': [\n\t                255,\n\t                222,\n\t                173,\n\t                1\n\t            ],\n\t            'navy': [\n\t                0,\n\t                0,\n\t                128,\n\t                1\n\t            ],\n\t            'oldlace': [\n\t                253,\n\t                245,\n\t                230,\n\t                1\n\t            ],\n\t            'olive': [\n\t                128,\n\t                128,\n\t                0,\n\t                1\n\t            ],\n\t            'olivedrab': [\n\t                107,\n\t                142,\n\t                35,\n\t                1\n\t            ],\n\t            'orange': [\n\t                255,\n\t                165,\n\t                0,\n\t                1\n\t            ],\n\t            'orangered': [\n\t                255,\n\t                69,\n\t                0,\n\t                1\n\t            ],\n\t            'orchid': [\n\t                218,\n\t                112,\n\t                214,\n\t                1\n\t            ],\n\t            'palegoldenrod': [\n\t                238,\n\t                232,\n\t                170,\n\t                1\n\t            ],\n\t            'palegreen': [\n\t                152,\n\t                251,\n\t                152,\n\t                1\n\t            ],\n\t            'paleturquoise': [\n\t                175,\n\t                238,\n\t                238,\n\t                1\n\t            ],\n\t            'palevioletred': [\n\t                219,\n\t                112,\n\t                147,\n\t                1\n\t            ],\n\t            'papayawhip': [\n\t                255,\n\t                239,\n\t                213,\n\t                1\n\t            ],\n\t            'peachpuff': [\n\t                255,\n\t                218,\n\t                185,\n\t                1\n\t            ],\n\t            'peru': [\n\t                205,\n\t                133,\n\t                63,\n\t                1\n\t            ],\n\t            'pink': [\n\t                255,\n\t                192,\n\t                203,\n\t                1\n\t            ],\n\t            'plum': [\n\t                221,\n\t                160,\n\t                221,\n\t                1\n\t            ],\n\t            'powderblue': [\n\t                176,\n\t                224,\n\t                230,\n\t                1\n\t            ],\n\t            'purple': [\n\t                128,\n\t                0,\n\t                128,\n\t                1\n\t            ],\n\t            'red': [\n\t                255,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'rosybrown': [\n\t                188,\n\t                143,\n\t                143,\n\t                1\n\t            ],\n\t            'royalblue': [\n\t                65,\n\t                105,\n\t                225,\n\t                1\n\t            ],\n\t            'saddlebrown': [\n\t                139,\n\t                69,\n\t                19,\n\t                1\n\t            ],\n\t            'salmon': [\n\t                250,\n\t                128,\n\t                114,\n\t                1\n\t            ],\n\t            'sandybrown': [\n\t                244,\n\t                164,\n\t                96,\n\t                1\n\t            ],\n\t            'seagreen': [\n\t                46,\n\t                139,\n\t                87,\n\t                1\n\t            ],\n\t            'seashell': [\n\t                255,\n\t                245,\n\t                238,\n\t                1\n\t            ],\n\t            'sienna': [\n\t                160,\n\t                82,\n\t                45,\n\t                1\n\t            ],\n\t            'silver': [\n\t                192,\n\t                192,\n\t                192,\n\t                1\n\t            ],\n\t            'skyblue': [\n\t                135,\n\t                206,\n\t                235,\n\t                1\n\t            ],\n\t            'slateblue': [\n\t                106,\n\t                90,\n\t                205,\n\t                1\n\t            ],\n\t            'slategray': [\n\t                112,\n\t                128,\n\t                144,\n\t                1\n\t            ],\n\t            'slategrey': [\n\t                112,\n\t                128,\n\t                144,\n\t                1\n\t            ],\n\t            'snow': [\n\t                255,\n\t                250,\n\t                250,\n\t                1\n\t            ],\n\t            'springgreen': [\n\t                0,\n\t                255,\n\t                127,\n\t                1\n\t            ],\n\t            'steelblue': [\n\t                70,\n\t                130,\n\t                180,\n\t                1\n\t            ],\n\t            'tan': [\n\t                210,\n\t                180,\n\t                140,\n\t                1\n\t            ],\n\t            'teal': [\n\t                0,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'thistle': [\n\t                216,\n\t                191,\n\t                216,\n\t                1\n\t            ],\n\t            'tomato': [\n\t                255,\n\t                99,\n\t                71,\n\t                1\n\t            ],\n\t            'turquoise': [\n\t                64,\n\t                224,\n\t                208,\n\t                1\n\t            ],\n\t            'violet': [\n\t                238,\n\t                130,\n\t                238,\n\t                1\n\t            ],\n\t            'wheat': [\n\t                245,\n\t                222,\n\t                179,\n\t                1\n\t            ],\n\t            'white': [\n\t                255,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'whitesmoke': [\n\t                245,\n\t                245,\n\t                245,\n\t                1\n\t            ],\n\t            'yellow': [\n\t                255,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'yellowgreen': [\n\t                154,\n\t                205,\n\t                50,\n\t                1\n\t            ]\n\t        };\n\t    function clampCssByte(i) {\n\t        // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);\n\t        // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t    function clampCssAngle(i) {\n\t        // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);\n\t        // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t    function clampCssFloat(f) {\n\t        // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t    function parseCssInt(str) {\n\t        // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t    function parseCssFloat(str) {\n\t        // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        } else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();    // dup.\n\t        }\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);\n\t                // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 4095)) {\n\t                    return;    // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 3840) >> 4 | (iv & 3840) >> 8,\n\t                    iv & 240 | (iv & 240) >> 4,\n\t                    iv & 15 | (iv & 15) << 4,\n\t                    1\n\t                ];\n\t            } else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);\n\t                // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 16777215)) {\n\t                    return;    // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 16711680) >> 16,\n\t                    (iv & 65280) >> 8,\n\t                    iv & 255,\n\t                    1\n\t                ];\n\t            }\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;\n\t            // To allow case fallthrough.\n\t            switch (fname) {\n\t            case 'rgba':\n\t                if (params.length !== 4) {\n\t                    return;\n\t                }\n\t                alpha = parseCssFloat(params.pop());\n\t            // jshint ignore:line\n\t            // Fall through.\n\t            case 'rgb':\n\t                if (params.length !== 3) {\n\t                    return;\n\t                }\n\t                return [\n\t                    parseCssInt(params[0]),\n\t                    parseCssInt(params[1]),\n\t                    parseCssInt(params[2]),\n\t                    alpha\n\t                ];\n\t            case 'hsla':\n\t                if (params.length !== 4) {\n\t                    return;\n\t                }\n\t                params[3] = parseCssFloat(params[3]);\n\t                return hsla2rgba(params);\n\t            case 'hsl':\n\t                if (params.length !== 3) {\n\t                    return;\n\t                }\n\t                return hsla2rgba(params);\n\t            default:\n\t                return;\n\t            }\n\t        }\n\t        return;\n\t    }\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;\n\t        // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t        var rgba = [\n\t                clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t                clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t                clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t            ];\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t        return rgba;\n\t    }\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t        var vMin = Math.min(R, G, B);\n\t        // Min. value of RGB\n\t        var vMax = Math.max(R, G, B);\n\t        // Max. value of RGB\n\t        var delta = vMax - vMin;\n\t        // Delta RGB value\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        } else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            } else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n\t            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n\t            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            } else if (G === vMax) {\n\t                H = 1 / 3 + deltaR - deltaB;\n\t            } else if (B === vMax) {\n\t                H = 2 / 3 + deltaG - deltaR;\n\t            }\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t        var hsla = [\n\t                H * 360,\n\t                S,\n\t                L\n\t            ];\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t        return hsla;\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                } else {\n\t                    colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n\t        }\n\t    }\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t            return;\n\t        }\n\t        out = out || [\n\t            0,\n\t            0,\n\t            0,\n\t            0\n\t        ];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t            return;\n\t        }\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t        var color = stringify([\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ], 'rgba');\n\t        return fullOutput ? {\n\t            color: color,\n\t            leftIndex: leftIndex,\n\t            rightIndex: rightIndex,\n\t            value: value\n\t        } : color;\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t    return {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t});\n\tdefine('zrender/core/timsort', [], function () {\n\t    var DEFAULT_MIN_MERGE = 32;\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t        return n + r;\n\t    }\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t            reverseRun(array, lo, runHi);\n\t        } else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t        return runHi - lo;\n\t    }\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                } else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t            var n = start - left;\n\t            switch (n) {\n\t            case 3:\n\t                array[left + 3] = array[left + 2];\n\t            case 2:\n\t                array[left + 2] = array[left + 1];\n\t            case 1:\n\t                array[left + 1] = array[left];\n\t                break;\n\t            default:\n\t                while (n > 0) {\n\t                    array[left + n] = array[left + n - 1];\n\t                    n--;\n\t                }\n\t            }\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        } else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            } else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        } else {\n\t            maxOffset = length - hint;\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            } else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t        length = array.length;\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t        var tmp = [];\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t        runStart = [];\n\t        runLength = [];\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                } else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t            runLength[i] = length1 + length2;\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t            stackSize--;\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            } else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t            array[dest++] = array[cursor2++];\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    } else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = array[cursor2++];\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t                _minGallop += 2;\n\t            }\n\t            minGallop = _minGallop;\n\t            minGallop < 1 && (minGallop = 1);\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            } else if (length1 === 0) {\n\t                throw new Error();    // throw new Error('mergeLow preconditions were not respected');\n\t            } else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t        function mergeHigh(start1, length1, start2, length2) {\n\t            var i = 0;\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t            array[dest--] = array[cursor1--];\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t                return;\n\t            }\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t            var _minGallop = minGallop;\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    } else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest--] = tmp[cursor2--];\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest--] = array[cursor1--];\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t                _minGallop += 2;\n\t            }\n\t            minGallop = _minGallop;\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t                array[dest] = tmp[cursor2];\n\t            } else if (length2 === 0) {\n\t                throw new Error();    // throw new Error('mergeHigh preconditions were not respected');\n\t            } else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t        var remaining = hi - lo;\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t        var runLength = 0;\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t        var ts = new TimSort(array, compare);\n\t        var minRun = minRunLength(remaining);\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t        ts.forceMergeRuns();\n\t    }\n\t    return sort;\n\t});\n\tdefine('echarts/visual/seriesColor', ['require', 'zrender/graphic/Gradient'], function (require) {\n\t    var Gradient = require('zrender/graphic/Gradient');\n\t    return function (ecModel) {\n\t        function encodeColor(seriesModel) {\n\t            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n\t            var data = seriesModel.getData();\n\t            var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));\n\t            // Default color\n\t            // FIXME Set color function or use the platte color\n\t            data.setVisual('color', color);\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof color === 'function' && !(color instanceof Gradient)) {\n\t                    data.each(function (idx) {\n\t                        data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n\t                    });\n\t                }\n\t                // itemStyle in each data item\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var color = itemModel.get(colorAccessPath, true);\n\t                    if (color != null) {\n\t                        data.setItemVisual(idx, 'color', color);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t        ecModel.eachRawSeries(encodeColor);\n\t    };\n\t});\n\tdefine('echarts/preprocessor/backwardCompat', ['require', 'zrender/core/util', './helper/compatStyle'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var compatStyle = require('./helper/compatStyle');\n\t    function get(opt, path) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        for (var i = 0; i < path.length; i++) {\n\t            obj = obj && obj[path[i]];\n\t            if (obj == null) {\n\t                break;\n\t            }\n\t        }\n\t        return obj;\n\t    }\n\t    function set(opt, path, val, overwrite) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        var key;\n\t        for (var i = 0; i < path.length - 1; i++) {\n\t            key = path[i];\n\t            if (obj[key] == null) {\n\t                obj[key] = {};\n\t            }\n\t            obj = obj[key];\n\t        }\n\t        if (overwrite || obj[path[i]] == null) {\n\t            obj[path[i]] = val;\n\t        }\n\t    }\n\t    function compatLayoutProperties(option) {\n\t        each(LAYOUT_PROPERTIES, function (prop) {\n\t            if (prop[0] in option && !(prop[1] in option)) {\n\t                option[prop[1]] = option[prop[0]];\n\t            }\n\t        });\n\t    }\n\t    var LAYOUT_PROPERTIES = [\n\t            [\n\t                'x',\n\t                'left'\n\t            ],\n\t            [\n\t                'y',\n\t                'top'\n\t            ],\n\t            [\n\t                'x2',\n\t                'right'\n\t            ],\n\t            [\n\t                'y2',\n\t                'bottom'\n\t            ]\n\t        ];\n\t    var COMPATITABLE_COMPONENTS = [\n\t            'grid',\n\t            'geo',\n\t            'parallel',\n\t            'legend',\n\t            'toolbox',\n\t            'title',\n\t            'visualMap',\n\t            'dataZoom',\n\t            'timeline'\n\t        ];\n\t    var COMPATITABLE_SERIES = [\n\t            'bar',\n\t            'boxplot',\n\t            'candlestick',\n\t            'chord',\n\t            'effectScatter',\n\t            'funnel',\n\t            'gauge',\n\t            'lines',\n\t            'graph',\n\t            'heatmap',\n\t            'line',\n\t            'map',\n\t            'parallel',\n\t            'pie',\n\t            'radar',\n\t            'sankey',\n\t            'scatter',\n\t            'treemap'\n\t        ];\n\t    var each = zrUtil.each;\n\t    return function (option) {\n\t        each(option.series, function (seriesOpt) {\n\t            if (!zrUtil.isObject(seriesOpt)) {\n\t                return;\n\t            }\n\t            var seriesType = seriesOpt.type;\n\t            compatStyle(seriesOpt);\n\t            if (seriesType === 'pie' || seriesType === 'gauge') {\n\t                if (seriesOpt.clockWise != null) {\n\t                    seriesOpt.clockwise = seriesOpt.clockWise;\n\t                }\n\t            }\n\t            if (seriesType === 'gauge') {\n\t                var pointerColor = get(seriesOpt, 'pointer.color');\n\t                pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n\t            }\n\t            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n\t                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n\t                    compatLayoutProperties(seriesOpt);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t        // dataRange has changed to visualMap\n\t        if (option.dataRange) {\n\t            option.visualMap = option.dataRange;\n\t        }\n\t        each(COMPATITABLE_COMPONENTS, function (componentName) {\n\t            var options = option[componentName];\n\t            if (options) {\n\t                if (!zrUtil.isArray(options)) {\n\t                    options = [options];\n\t                }\n\t                each(options, function (option) {\n\t                    compatLayoutProperties(option);\n\t                });\n\t            }\n\t        });\n\t    };\n\t});\n\tdefine('echarts/loading/default', ['require', '../util/graphic', 'zrender/core/util'], function (require) {\n\t    var graphic = require('../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    var PI = Math.PI;\n\t    /**\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     * @param {Object} [opts]\n\t     * @param {string} [opts.text]\n\t     * @param {string} [opts.color]\n\t     * @param {string} [opts.textColor]\n\t     * @return {module:zrender/Element}\n\t     */\n\t    return function (api, opts) {\n\t        opts = opts || {};\n\t        zrUtil.defaults(opts, {\n\t            text: 'loading',\n\t            color: '#c23531',\n\t            textColor: '#000',\n\t            maskColor: 'rgba(255, 255, 255, 0.8)',\n\t            zlevel: 0\n\t        });\n\t        var mask = new graphic.Rect({\n\t                style: { fill: opts.maskColor },\n\t                zlevel: opts.zlevel,\n\t                z: 10000\n\t            });\n\t        var arc = new graphic.Arc({\n\t                shape: {\n\t                    startAngle: -PI / 2,\n\t                    endAngle: -PI / 2 + 0.1,\n\t                    r: 10\n\t                },\n\t                style: {\n\t                    stroke: opts.color,\n\t                    lineCap: 'round',\n\t                    lineWidth: 5\n\t                },\n\t                zlevel: opts.zlevel,\n\t                z: 10001\n\t            });\n\t        var labelRect = new graphic.Rect({\n\t                style: {\n\t                    fill: 'none',\n\t                    text: opts.text,\n\t                    textPosition: 'right',\n\t                    textDistance: 10,\n\t                    textFill: opts.textColor\n\t                },\n\t                zlevel: opts.zlevel,\n\t                z: 10001\n\t            });\n\t        arc.animateShape(true).when(1000, { endAngle: PI * 3 / 2 }).start('circularInOut');\n\t        arc.animateShape(true).when(1000, { startAngle: PI * 3 / 2 }).delay(300).start('circularInOut');\n\t        var group = new graphic.Group();\n\t        group.add(arc);\n\t        group.add(labelRect);\n\t        group.add(mask);\n\t        // Inject resize\n\t        group.resize = function () {\n\t            var cx = api.getWidth() / 2;\n\t            var cy = api.getHeight() / 2;\n\t            arc.setShape({\n\t                cx: cx,\n\t                cy: cy\n\t            });\n\t            var r = arc.shape.r;\n\t            labelRect.setShape({\n\t                x: cx - r,\n\t                y: cy - r,\n\t                width: r * 2,\n\t                height: r * 2\n\t            });\n\t            mask.setShape({\n\t                x: 0,\n\t                y: 0,\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        };\n\t        group.resize();\n\t        return group;\n\t    };\n\t});\n\tdefine('zrender/core/matrix', [], function () {\n\t    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t    /**\n\t     * 3x2\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t            create: function () {\n\t                var out = new ArrayCtor(6);\n\t                matrix.identity(out);\n\t                return out;\n\t            },\n\t            identity: function (out) {\n\t                out[0] = 1;\n\t                out[1] = 0;\n\t                out[2] = 0;\n\t                out[3] = 1;\n\t                out[4] = 0;\n\t                out[5] = 0;\n\t                return out;\n\t            },\n\t            copy: function (out, m) {\n\t                out[0] = m[0];\n\t                out[1] = m[1];\n\t                out[2] = m[2];\n\t                out[3] = m[3];\n\t                out[4] = m[4];\n\t                out[5] = m[5];\n\t                return out;\n\t            },\n\t            mul: function (out, m1, m2) {\n\t                // Consider matrix.mul(m, m2, m);\n\t                // where out is the same as m2.\n\t                // So use temp variable to escape error.\n\t                var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t                var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t                var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t                var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t                var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t                var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t                out[0] = out0;\n\t                out[1] = out1;\n\t                out[2] = out2;\n\t                out[3] = out3;\n\t                out[4] = out4;\n\t                out[5] = out5;\n\t                return out;\n\t            },\n\t            translate: function (out, a, v) {\n\t                out[0] = a[0];\n\t                out[1] = a[1];\n\t                out[2] = a[2];\n\t                out[3] = a[3];\n\t                out[4] = a[4] + v[0];\n\t                out[5] = a[5] + v[1];\n\t                return out;\n\t            },\n\t            rotate: function (out, a, rad) {\n\t                var aa = a[0];\n\t                var ac = a[2];\n\t                var atx = a[4];\n\t                var ab = a[1];\n\t                var ad = a[3];\n\t                var aty = a[5];\n\t                var st = Math.sin(rad);\n\t                var ct = Math.cos(rad);\n\t                out[0] = aa * ct + ab * st;\n\t                out[1] = -aa * st + ab * ct;\n\t                out[2] = ac * ct + ad * st;\n\t                out[3] = -ac * st + ct * ad;\n\t                out[4] = ct * atx + st * aty;\n\t                out[5] = ct * aty - st * atx;\n\t                return out;\n\t            },\n\t            scale: function (out, a, v) {\n\t                var vx = v[0];\n\t                var vy = v[1];\n\t                out[0] = a[0] * vx;\n\t                out[1] = a[1] * vy;\n\t                out[2] = a[2] * vx;\n\t                out[3] = a[3] * vy;\n\t                out[4] = a[4] * vx;\n\t                out[5] = a[5] * vy;\n\t                return out;\n\t            },\n\t            invert: function (out, a) {\n\t                var aa = a[0];\n\t                var ac = a[2];\n\t                var atx = a[4];\n\t                var ab = a[1];\n\t                var ad = a[3];\n\t                var aty = a[5];\n\t                var det = aa * ad - ab * ac;\n\t                if (!det) {\n\t                    return null;\n\t                }\n\t                det = 1 / det;\n\t                out[0] = ad * det;\n\t                out[1] = -ab * det;\n\t                out[2] = -ac * det;\n\t                out[3] = aa * det;\n\t                out[4] = (ac * aty - ad * atx) * det;\n\t                out[5] = (ab * atx - aa * aty) * det;\n\t                return out;\n\t            }\n\t        };\n\t    return matrix;\n\t});\n\tdefine('echarts/model/Model', ['require', 'zrender/core/util', '../util/clazz', './mixin/lineStyle', './mixin/areaStyle', './mixin/textStyle', './mixin/itemStyle'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazzUtil = require('../util/clazz');\n\t    /**\n\t     * @alias module:echarts/model/Model\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} [parentModel]\n\t     * @param {module:echarts/model/Global} [ecModel]\n\t     */\n\t    function Model(option, parentModel, ecModel) {\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         * @readOnly\n\t         */\n\t        this.parentModel = parentModel;\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        this.ecModel = ecModel;\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        this.option = option;    // Simple optimization\n\t                                 // if (this.init) {\n\t                                 //     if (arguments.length <= 4) {\n\t                                 //         this.init(option, parentModel, ecModel, extraOpt);\n\t                                 //     }\n\t                                 //     else {\n\t                                 //         this.init.apply(this, arguments);\n\t                                 //     }\n\t                                 // }\n\t    }\n\t    Model.prototype = {\n\t        constructor: Model,\n\t        init: null,\n\t        mergeOption: function (option) {\n\t            zrUtil.merge(this.option, option, true);\n\t        },\n\t        get: function (path, ignoreParent) {\n\t            if (!path) {\n\t                return this.option;\n\t            }\n\t            if (typeof path === 'string') {\n\t                path = path.split('.');\n\t            }\n\t            var obj = this.option;\n\t            var parentModel = this.parentModel;\n\t            for (var i = 0; i < path.length; i++) {\n\t                // Ignore empty\n\t                if (!path[i]) {\n\t                    continue;\n\t                }\n\t                // obj could be number/string/... (like 0)\n\t                obj = obj && typeof obj === 'object' ? obj[path[i]] : null;\n\t                if (obj == null) {\n\t                    break;\n\t                }\n\t            }\n\t            if (obj == null && parentModel && !ignoreParent) {\n\t                obj = parentModel.get(path);\n\t            }\n\t            return obj;\n\t        },\n\t        getShallow: function (key, ignoreParent) {\n\t            var option = this.option;\n\t            var val = option == null ? option : option[key];\n\t            var parentModel = this.parentModel;\n\t            if (val == null && parentModel && !ignoreParent) {\n\t                val = parentModel.getShallow(key);\n\t            }\n\t            return val;\n\t        },\n\t        getModel: function (path, parentModel) {\n\t            var obj = this.get(path, true);\n\t            var thisParentModel = this.parentModel;\n\t            var model = new Model(obj, parentModel || thisParentModel && thisParentModel.getModel(path), this.ecModel);\n\t            return model;\n\t        },\n\t        isEmpty: function () {\n\t            return this.option == null;\n\t        },\n\t        restoreData: function () {\n\t        },\n\t        clone: function () {\n\t            var Ctor = this.constructor;\n\t            return new Ctor(zrUtil.clone(this.option));\n\t        },\n\t        setReadOnly: function (properties) {\n\t            clazzUtil.setReadOnly(this, properties);\n\t        }\n\t    };\n\t    // Enable Model.extend.\n\t    clazzUtil.enableClassExtend(Model);\n\t    var mixin = zrUtil.mixin;\n\t    mixin(Model, require('./mixin/lineStyle'));\n\t    mixin(Model, require('./mixin/areaStyle'));\n\t    mixin(Model, require('./mixin/textStyle'));\n\t    mixin(Model, require('./mixin/itemStyle'));\n\t    return Model;\n\t});\n\tdefine('echarts/data/List', ['require', '../model/Model', './DataDiffer', 'zrender/core/util', '../util/model'], function (require) {\n\t    var UNDEFINED = 'undefined';\n\t    var globalObj = typeof window === 'undefined' ? global : window;\n\t    var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;\n\t    var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;\n\t    var dataCtors = {\n\t            'float': Float64Array,\n\t            'int': Int32Array,\n\t            'ordinal': Array,\n\t            'number': Array,\n\t            'time': Array\n\t        };\n\t    var Model = require('../model/Model');\n\t    var DataDiffer = require('./DataDiffer');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var isObject = zrUtil.isObject;\n\t    var TRANSFERABLE_PROPERTIES = [\n\t            'stackedOn',\n\t            'hasItemOption',\n\t            '_nameList',\n\t            '_idList',\n\t            '_rawData'\n\t        ];\n\t    var transferProperties = function (a, b) {\n\t        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n\t            if (b.hasOwnProperty(propName)) {\n\t                a[propName] = b[propName];\n\t            }\n\t        });\n\t        a.__wrappedMethods = b.__wrappedMethods;\n\t    };\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/data/List\n\t     *\n\t     * @param {Array.<string>} dimensions\n\t     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n\t     * @param {module:echarts/model/Model} hostModel\n\t     */\n\t    var List = function (dimensions, hostModel) {\n\t        dimensions = dimensions || [\n\t            'x',\n\t            'y'\n\t        ];\n\t        var dimensionInfos = {};\n\t        var dimensionNames = [];\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimensionName;\n\t            var dimensionInfo = {};\n\t            if (typeof dimensions[i] === 'string') {\n\t                dimensionName = dimensions[i];\n\t                dimensionInfo = {\n\t                    name: dimensionName,\n\t                    stackable: false,\n\t                    type: 'number'\n\t                };\n\t            } else {\n\t                dimensionInfo = dimensions[i];\n\t                dimensionName = dimensionInfo.name;\n\t                dimensionInfo.type = dimensionInfo.type || 'number';\n\t            }\n\t            dimensionNames.push(dimensionName);\n\t            dimensionInfos[dimensionName] = dimensionInfo;\n\t        }\n\t        /**\n\t         * @readOnly\n\t         * @type {Array.<string>}\n\t         */\n\t        this.dimensions = dimensionNames;\n\t        /**\n\t         * Infomation of each data dimension, like data type.\n\t         * @type {Object}\n\t         */\n\t        this._dimensionInfos = dimensionInfos;\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.hostModel = hostModel;\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.dataType;\n\t        /**\n\t         * Indices stores the indices of data subset after filtered.\n\t         * This data subset will be used in chart.\n\t         * @type {Array.<number>}\n\t         * @readOnly\n\t         */\n\t        this.indices = [];\n\t        /**\n\t         * Data storage\n\t         * @type {Object.<key, TypedArray|Array>}\n\t         * @private\n\t         */\n\t        this._storage = {};\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._nameList = [];\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._idList = [];\n\t        /**\n\t         * Models of data option is stored sparse for optimizing memory cost\n\t         * @type {Array.<module:echarts/model/Model>}\n\t         * @private\n\t         */\n\t        this._optionModels = [];\n\t        /**\n\t         * @param {module:echarts/data/List}\n\t         */\n\t        this.stackedOn = null;\n\t        /**\n\t         * Global visual properties after visual coding\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._visual = {};\n\t        /**\n\t         * Globel layout properties.\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._layout = {};\n\t        /**\n\t         * Item visual properties after visual coding\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemVisuals = [];\n\t        /**\n\t         * Item layout properties after layout\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemLayouts = [];\n\t        /**\n\t         * Graphic elemnents\n\t         * @type {Array.<module:zrender/Element>}\n\t         * @private\n\t         */\n\t        this._graphicEls = [];\n\t        /**\n\t         * @type {Array.<Array|Object>}\n\t         * @private\n\t         */\n\t        this._rawData;\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._extent;\n\t    };\n\t    var listProto = List.prototype;\n\t    listProto.type = 'list';\n\t    /**\n\t     * If each data item has it's own option\n\t     * @type {boolean}\n\t     */\n\t    listProto.hasItemOption = true;\n\t    /**\n\t     * Get dimension name\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     * @return {string} Concrete dim name.\n\t     */\n\t    listProto.getDimension = function (dim) {\n\t        if (!isNaN(dim)) {\n\t            dim = this.dimensions[dim] || dim;\n\t        }\n\t        return dim;\n\t    };\n\t    /**\n\t     * Get type and stackable info of particular dimension\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     */\n\t    listProto.getDimensionInfo = function (dim) {\n\t        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n\t    };\n\t    /**\n\t     * Initialize from data\n\t     * @param {Array.<Object|number|Array>} data\n\t     * @param {Array.<string>} [nameList]\n\t     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n\t     */\n\t    listProto.initData = function (data, nameList, dimValueGetter) {\n\t        data = data || [];\n\t        if (true) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t        this._rawData = data;\n\t        // Clear\n\t        var storage = this._storage = {};\n\t        var indices = this.indices = [];\n\t        var dimensions = this.dimensions;\n\t        var size = data.length;\n\t        var dimensionInfoMap = this._dimensionInfos;\n\t        var idList = [];\n\t        var nameRepeatCount = {};\n\t        nameList = nameList || [];\n\t        // Init storage\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimInfo = dimensionInfoMap[dimensions[i]];\n\t            var DataCtor = dataCtors[dimInfo.type];\n\t            storage[dimensions[i]] = new DataCtor(size);\n\t        }\n\t        var self = this;\n\t        if (!dimValueGetter) {\n\t            self.hasItemOption = false;\n\t        }\n\t        // Default dim value getter\n\t        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n\t            var value = modelUtil.getDataItemValue(dataItem);\n\t            // If any dataItem is like { value: 10 }\n\t            if (modelUtil.isDataItemOption(dataItem)) {\n\t                self.hasItemOption = true;\n\t            }\n\t            return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] : value, dimensionInfoMap[dimName]);\n\t        };\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            var dataItem = data[idx];\n\t            // Each data item is value\n\t            // [1, 2]\n\t            // 2\n\t            // Bar chart, line chart which uses category axis\n\t            // only gives the 'y' value. 'x' value is the indices of cateogry\n\t            // Use a tempValue to normalize the value to be a (x, y) value\n\t            // Store the data by dimensions\n\t            for (var k = 0; k < dimensions.length; k++) {\n\t                var dim = dimensions[k];\n\t                var dimStorage = storage[dim];\n\t                // PENDING NULL is empty or zero\n\t                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n\t            }\n\t            indices.push(idx);\n\t        }\n\t        // Use the name in option and create id\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (!nameList[i]) {\n\t                if (data[i] && data[i].name != null) {\n\t                    nameList[i] = data[i].name;\n\t                }\n\t            }\n\t            var name = nameList[i] || '';\n\t            // Try using the id in option\n\t            var id = data[i] && data[i].id;\n\t            if (!id && name) {\n\t                // Use name as id and add counter to avoid same name\n\t                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n\t                id = name;\n\t                if (nameRepeatCount[name] > 0) {\n\t                    id += '__ec__' + nameRepeatCount[name];\n\t                }\n\t                nameRepeatCount[name]++;\n\t            }\n\t            id && (idList[i] = id);\n\t        }\n\t        this._nameList = nameList;\n\t        this._idList = idList;\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    listProto.count = function () {\n\t        return this.indices.length;\n\t    };\n\t    /**\n\t     * Get value. Return NaN if idx is out of range.\n\t     * @param {string} dim Dim must be concrete name.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.get = function (dim, idx, stack) {\n\t        var storage = this._storage;\n\t        var dataIndex = this.indices[idx];\n\t        // If value not exists\n\t        if (dataIndex == null) {\n\t            return NaN;\n\t        }\n\t        var value = storage[dim] && storage[dim][dataIndex];\n\t        // FIXME ordinal data type is not stackable\n\t        if (stack) {\n\t            var dimensionInfo = this._dimensionInfos[dim];\n\t            if (dimensionInfo && dimensionInfo.stackable) {\n\t                var stackedOn = this.stackedOn;\n\t                while (stackedOn) {\n\t                    // Get no stacked data of stacked on\n\t                    var stackedValue = stackedOn.get(dim, idx);\n\t                    // Considering positive stack, negative stack and empty data\n\t                    if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {\n\t                        value += stackedValue;\n\t                    }\n\t                    stackedOn = stackedOn.stackedOn;\n\t                }\n\t            }\n\t        }\n\t        return value;\n\t    };\n\t    /**\n\t     * Get value for multi dimensions.\n\t     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.getValues = function (dimensions, idx, stack) {\n\t        var values = [];\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            stack = idx;\n\t            idx = dimensions;\n\t            dimensions = this.dimensions;\n\t        }\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            values.push(this.get(dimensions[i], idx, stack));\n\t        }\n\t        return values;\n\t    };\n\t    /**\n\t     * If value is NaN. Inlcuding '-'\n\t     * @param {string} dim\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.hasValue = function (idx) {\n\t        var dimensions = this.dimensions;\n\t        var dimensionInfos = this._dimensionInfos;\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t    /**\n\t     * Get extent of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getDataExtent = function (dim, stack) {\n\t        dim = this.getDimension(dim);\n\t        var dimData = this._storage[dim];\n\t        var dimInfo = this.getDimensionInfo(dim);\n\t        stack = dimInfo && dimInfo.stackable && stack;\n\t        var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n\t        var value;\n\t        if (dimExtent) {\n\t            return dimExtent;\n\t        }\n\t        // var dimInfo = this._dimensionInfos[dim];\n\t        if (dimData) {\n\t            var min = Infinity;\n\t            var max = -Infinity;\n\t            // var isOrdinal = dimInfo.type === 'ordinal';\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                value = this.get(dim, i, stack);\n\t                // FIXME\n\t                // if (isOrdinal && typeof value === 'string') {\n\t                //     value = zrUtil.indexOf(dimData, value);\n\t                // }\n\t                value < min && (min = value);\n\t                value > max && (max = value);\n\t            }\n\t            return this._extent[dim + !!stack] = [\n\t                min,\n\t                max\n\t            ];\n\t        } else {\n\t            return [\n\t                Infinity,\n\t                -Infinity\n\t            ];\n\t        }\n\t    };\n\t    /**\n\t     * Get sum of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getSum = function (dim, stack) {\n\t        var dimData = this._storage[dim];\n\t        var sum = 0;\n\t        if (dimData) {\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var value = this.get(dim, i, stack);\n\t                if (!isNaN(value)) {\n\t                    sum += value;\n\t                }\n\t            }\n\t        }\n\t        return sum;\n\t    };\n\t    /**\n\t     * Retreive the index with given value\n\t     * @param {number} idx\n\t     * @param {number} value\n\t     * @return {number}\n\t     */\n\t    // FIXME Precision of float value\n\t    listProto.indexOf = function (dim, value) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        var indices = this.indices;\n\t        if (dimData) {\n\t            for (var i = 0, len = indices.length; i < len; i++) {\n\t                var rawIndex = indices[i];\n\t                if (dimData[rawIndex] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index with given name\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfName = function (name) {\n\t        var indices = this.indices;\n\t        var nameList = this._nameList;\n\t        for (var i = 0, len = indices.length; i < len; i++) {\n\t            var rawIndex = indices[i];\n\t            if (nameList[rawIndex] === name) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index with given raw data index\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfRawIndex = function (rawIndex) {\n\t        // Indices are ascending\n\t        var indices = this.indices;\n\t        var left = 0;\n\t        var right = indices.length - 1;\n\t        while (left <= right) {\n\t            var mid = (left + right) / 2 | 0;\n\t            if (indices[mid] < rawIndex) {\n\t                left = mid + 1;\n\t            } else if (indices[mid] > rawIndex) {\n\t                right = mid - 1;\n\t            } else {\n\t                return mid;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index of nearest value\n\t     * @param {string} dim\n\t     * @param {number} value\n\t     * @param {boolean} stack If given value is after stacked\n\t     * @param {number} [maxDistance=Infinity]\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        if (maxDistance == null) {\n\t            maxDistance = Infinity;\n\t        }\n\t        var nearestIdx = -1;\n\t        if (dimData) {\n\t            var minDist = Number.MAX_VALUE;\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var diff = value - this.get(dim, i, stack);\n\t                var dist = Math.abs(diff);\n\t                if (diff <= maxDistance && (dist < minDist || dist === minDist && diff > 0)) {\n\t                    minDist = dist;\n\t                    nearestIdx = i;\n\t                }\n\t            }\n\t        }\n\t        return nearestIdx;\n\t    };\n\t    /**\n\t     * Get raw data index\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawIndex = function (idx) {\n\t        var rawIdx = this.indices[idx];\n\t        return rawIdx == null ? -1 : rawIdx;\n\t    };\n\t    /**\n\t     * Get raw data item\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawDataItem = function (idx) {\n\t        return this._rawData[this.getRawIndex(idx)];\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getName = function (idx) {\n\t        return this._nameList[this.indices[idx]] || '';\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getId = function (idx) {\n\t        return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n\t    };\n\t    function normalizeDimensions(dimensions) {\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            dimensions = [dimensions];\n\t        }\n\t        return dimensions;\n\t    }\n\t    /**\n\t     * Data iteration\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     *\n\t     * @example\n\t     *  list.each('x', function (x, idx) {});\n\t     *  list.each(['x', 'y'], function (x, y, idx) {});\n\t     *  list.each(function (idx) {})\n\t     */\n\t    listProto.each = function (dims, cb, stack, context) {\n\t        if (typeof dims === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dims;\n\t            dims = [];\n\t        }\n\t        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\t        var value = [];\n\t        var dimSize = dims.length;\n\t        var indices = this.indices;\n\t        context = context || this;\n\t        for (var i = 0; i < indices.length; i++) {\n\t            // Simple optimization\n\t            switch (dimSize) {\n\t            case 0:\n\t                cb.call(context, i);\n\t                break;\n\t            case 1:\n\t                cb.call(context, this.get(dims[0], i, stack), i);\n\t                break;\n\t            case 2:\n\t                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n\t                break;\n\t            default:\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dims[k], i, stack);\n\t                }\n\t                // Index\n\t                value[k] = i;\n\t                cb.apply(context, value);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Data filter\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     */\n\t    listProto.filterSelf = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n\t        var newIndices = [];\n\t        var value = [];\n\t        var dimSize = dimensions.length;\n\t        var indices = this.indices;\n\t        context = context || this;\n\t        for (var i = 0; i < indices.length; i++) {\n\t            var keep;\n\t            // Simple optimization\n\t            if (dimSize === 1) {\n\t                keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n\t            } else {\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dimensions[k], i, stack);\n\t                }\n\t                value[k] = i;\n\t                keep = cb.apply(context, value);\n\t            }\n\t            if (keep) {\n\t                newIndices.push(indices[i]);\n\t            }\n\t        }\n\t        this.indices = newIndices;\n\t        // Reset data extent\n\t        this._extent = {};\n\t        return this;\n\t    };\n\t    /**\n\t     * Data mapping to a plain array\n\t     * @param {string|Array.<string>} [dimensions]\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.mapArray = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t        var result = [];\n\t        this.each(dimensions, function () {\n\t            result.push(cb && cb.apply(this, arguments));\n\t        }, stack, context);\n\t        return result;\n\t    };\n\t    function cloneListForMapAndSample(original, excludeDimensions) {\n\t        var allDimensions = original.dimensions;\n\t        var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n\t        // FIXME If needs stackedOn, value may already been stacked\n\t        transferProperties(list, original);\n\t        var storage = list._storage = {};\n\t        var originalStorage = original._storage;\n\t        // Init storage\n\t        for (var i = 0; i < allDimensions.length; i++) {\n\t            var dim = allDimensions[i];\n\t            var dimStore = originalStorage[dim];\n\t            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n\t                storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n\t            } else {\n\t                // Direct reference for other dimensions\n\t                storage[dim] = originalStorage[dim];\n\t            }\n\t        }\n\t        return list;\n\t    }\n\t    /**\n\t     * Data mapping to a new List with given dimensions\n\t     * @param {string|Array.<string>} dimensions\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.map = function (dimensions, cb, stack, context) {\n\t        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n\t        var list = cloneListForMapAndSample(this, dimensions);\n\t        // Following properties are all immutable.\n\t        // So we can reference to the same value\n\t        var indices = list.indices = this.indices;\n\t        var storage = list._storage;\n\t        var tmpRetValue = [];\n\t        this.each(dimensions, function () {\n\t            var idx = arguments[arguments.length - 1];\n\t            var retValue = cb && cb.apply(this, arguments);\n\t            if (retValue != null) {\n\t                // a number\n\t                if (typeof retValue === 'number') {\n\t                    tmpRetValue[0] = retValue;\n\t                    retValue = tmpRetValue;\n\t                }\n\t                for (var i = 0; i < retValue.length; i++) {\n\t                    var dim = dimensions[i];\n\t                    var dimStore = storage[dim];\n\t                    var rawIdx = indices[idx];\n\t                    if (dimStore) {\n\t                        dimStore[rawIdx] = retValue[i];\n\t                    }\n\t                }\n\t            }\n\t        }, stack, context);\n\t        return list;\n\t    };\n\t    /**\n\t     * Large data down sampling on given dimension\n\t     * @param {string} dimension\n\t     * @param {number} rate\n\t     * @param {Function} sampleValue\n\t     * @param {Function} sampleIndex Sample index for name and id\n\t     */\n\t    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n\t        var list = cloneListForMapAndSample(this, [dimension]);\n\t        var storage = this._storage;\n\t        var targetStorage = list._storage;\n\t        var originalIndices = this.indices;\n\t        var indices = list.indices = [];\n\t        var frameValues = [];\n\t        var frameIndices = [];\n\t        var frameSize = Math.floor(1 / rate);\n\t        var dimStore = targetStorage[dimension];\n\t        var len = this.count();\n\t        // Copy data from original data\n\t        for (var i = 0; i < storage[dimension].length; i++) {\n\t            targetStorage[dimension][i] = storage[dimension][i];\n\t        }\n\t        for (var i = 0; i < len; i += frameSize) {\n\t            // Last frame\n\t            if (frameSize > len - i) {\n\t                frameSize = len - i;\n\t                frameValues.length = frameSize;\n\t            }\n\t            for (var k = 0; k < frameSize; k++) {\n\t                var idx = originalIndices[i + k];\n\t                frameValues[k] = dimStore[idx];\n\t                frameIndices[k] = idx;\n\t            }\n\t            var value = sampleValue(frameValues);\n\t            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n\t            // Only write value on the filtered data\n\t            dimStore[idx] = value;\n\t            indices.push(idx);\n\t        }\n\t        return list;\n\t    };\n\t    /**\n\t     * Get model of one data item.\n\t     *\n\t     * @param {number} idx\n\t     */\n\t    // FIXME Model proxy ?\n\t    listProto.getItemModel = function (idx) {\n\t        var hostModel = this.hostModel;\n\t        idx = this.indices[idx];\n\t        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n\t    };\n\t    /**\n\t     * Create a data differ\n\t     * @param {module:echarts/data/List} otherList\n\t     * @return {module:echarts/data/DataDiffer}\n\t     */\n\t    listProto.diff = function (otherList) {\n\t        var idList = this._idList;\n\t        var otherIdList = otherList && otherList._idList;\n\t        return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n\t            return otherIdList[idx] || idx + '';\n\t        }, function (idx) {\n\t            return idList[idx] || idx + '';\n\t        });\n\t    };\n\t    /**\n\t     * Get visual property.\n\t     * @param {string} key\n\t     */\n\t    listProto.getVisual = function (key) {\n\t        var visual = this._visual;\n\t        return visual && visual[key];\n\t    };\n\t    /**\n\t     * Set visual property\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setVisual('color', color);\n\t     *  setVisual({\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setVisual = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setVisual(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._visual = this._visual || {};\n\t        this._visual[key] = val;\n\t    };\n\t    /**\n\t     * Set layout property.\n\t     * @param {string} key\n\t     * @param {*} [val]\n\t     */\n\t    listProto.setLayout = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setLayout(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._layout[key] = val;\n\t    };\n\t    /**\n\t     * Get layout property.\n\t     * @param  {string} key.\n\t     * @return {*}\n\t     */\n\t    listProto.getLayout = function (key) {\n\t        return this._layout[key];\n\t    };\n\t    /**\n\t     * Get layout of single data item\n\t     * @param {number} idx\n\t     */\n\t    listProto.getItemLayout = function (idx) {\n\t        return this._itemLayouts[idx];\n\t    };\n\t    /**\n\t     * Set layout of single data item\n\t     * @param {number} idx\n\t     * @param {Object} layout\n\t     * @param {boolean=} [merge=false]\n\t     */\n\t    listProto.setItemLayout = function (idx, layout, merge) {\n\t        this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n\t    };\n\t    /**\n\t     * Clear all layout of single data item\n\t     */\n\t    listProto.clearItemLayouts = function () {\n\t        this._itemLayouts.length = 0;\n\t    };\n\t    /**\n\t     * Get visual property of single data item\n\t     * @param {number} idx\n\t     * @param {string} key\n\t     * @param {boolean} ignoreParent\n\t     */\n\t    listProto.getItemVisual = function (idx, key, ignoreParent) {\n\t        var itemVisual = this._itemVisuals[idx];\n\t        var val = itemVisual && itemVisual[key];\n\t        if (val == null && !ignoreParent) {\n\t            // Use global visual property\n\t            return this.getVisual(key);\n\t        }\n\t        return val;\n\t    };\n\t    /**\n\t     * Set visual property of single data item\n\t     *\n\t     * @param {number} idx\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setItemVisual(0, 'color', color);\n\t     *  setItemVisual(0, {\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setItemVisual = function (idx, key, value) {\n\t        var itemVisual = this._itemVisuals[idx] || {};\n\t        this._itemVisuals[idx] = itemVisual;\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    itemVisual[name] = key[name];\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        itemVisual[key] = value;\n\t    };\n\t    /**\n\t     * Clear itemVisuals and list visual.\n\t     */\n\t    listProto.clearAllVisual = function () {\n\t        this._visual = {};\n\t        this._itemVisuals = [];\n\t    };\n\t    var setItemDataAndSeriesIndex = function (child) {\n\t        child.seriesIndex = this.seriesIndex;\n\t        child.dataIndex = this.dataIndex;\n\t        child.dataType = this.dataType;\n\t    };\n\t    /**\n\t     * Set graphic element relative to data. It can be set as null\n\t     * @param {number} idx\n\t     * @param {module:zrender/Element} [el]\n\t     */\n\t    listProto.setItemGraphicEl = function (idx, el) {\n\t        var hostModel = this.hostModel;\n\t        if (el) {\n\t            // Add data index and series index for indexing the data by element\n\t            // Useful in tooltip\n\t            el.dataIndex = idx;\n\t            el.dataType = this.dataType;\n\t            el.seriesIndex = hostModel && hostModel.seriesIndex;\n\t            if (el.type === 'group') {\n\t                el.traverse(setItemDataAndSeriesIndex, el);\n\t            }\n\t        }\n\t        this._graphicEls[idx] = el;\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @return {module:zrender/Element}\n\t     */\n\t    listProto.getItemGraphicEl = function (idx) {\n\t        return this._graphicEls[idx];\n\t    };\n\t    /**\n\t     * @param {Function} cb\n\t     * @param {*} context\n\t     */\n\t    listProto.eachItemGraphicEl = function (cb, context) {\n\t        zrUtil.each(this._graphicEls, function (el, idx) {\n\t            if (el) {\n\t                cb && cb.call(context, el, idx);\n\t            }\n\t        });\n\t    };\n\t    /**\n\t     * Shallow clone a new list except visual and layout properties, and graph elements.\n\t     * New list only change the indices.\n\t     */\n\t    listProto.cloneShallow = function () {\n\t        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n\t        var list = new List(dimensionInfoList, this.hostModel);\n\t        // FIXME\n\t        list._storage = this._storage;\n\t        transferProperties(list, this);\n\t        // Clone will not change the data extent and indices\n\t        list.indices = this.indices.slice();\n\t        if (this._extent) {\n\t            list._extent = zrUtil.extend({}, this._extent);\n\t        }\n\t        return list;\n\t    };\n\t    /**\n\t     * Wrap some method to add more feature\n\t     * @param {string} methodName\n\t     * @param {Function} injectFunction\n\t     */\n\t    listProto.wrapMethod = function (methodName, injectFunction) {\n\t        var originalMethod = this[methodName];\n\t        if (typeof originalMethod !== 'function') {\n\t            return;\n\t        }\n\t        this.__wrappedMethods = this.__wrappedMethods || [];\n\t        this.__wrappedMethods.push(methodName);\n\t        this[methodName] = function () {\n\t            var res = originalMethod.apply(this, arguments);\n\t            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n\t        };\n\t    };\n\t    // Methods that create a new list based on this list should be listed here.\n\t    // Notice that those method should `RETURN` the new list.\n\t    listProto.TRANSFERABLE_METHODS = [\n\t        'cloneShallow',\n\t        'downSample',\n\t        'map'\n\t    ];\n\t    // Methods that change indices of this list should be listed here.\n\t    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\t    return List;\n\t});\n\tdefine('zrender/core/vector', [], function () {\n\t    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * \n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t            create: function (x, y) {\n\t                var out = new ArrayCtor(2);\n\t                if (x == null) {\n\t                    x = 0;\n\t                }\n\t                if (y == null) {\n\t                    y = 0;\n\t                }\n\t                out[0] = x;\n\t                out[1] = y;\n\t                return out;\n\t            },\n\t            copy: function (out, v) {\n\t                out[0] = v[0];\n\t                out[1] = v[1];\n\t                return out;\n\t            },\n\t            clone: function (v) {\n\t                var out = new ArrayCtor(2);\n\t                out[0] = v[0];\n\t                out[1] = v[1];\n\t                return out;\n\t            },\n\t            set: function (out, a, b) {\n\t                out[0] = a;\n\t                out[1] = b;\n\t                return out;\n\t            },\n\t            add: function (out, v1, v2) {\n\t                out[0] = v1[0] + v2[0];\n\t                out[1] = v1[1] + v2[1];\n\t                return out;\n\t            },\n\t            scaleAndAdd: function (out, v1, v2, a) {\n\t                out[0] = v1[0] + v2[0] * a;\n\t                out[1] = v1[1] + v2[1] * a;\n\t                return out;\n\t            },\n\t            sub: function (out, v1, v2) {\n\t                out[0] = v1[0] - v2[0];\n\t                out[1] = v1[1] - v2[1];\n\t                return out;\n\t            },\n\t            len: function (v) {\n\t                return Math.sqrt(this.lenSquare(v));\n\t            },\n\t            lenSquare: function (v) {\n\t                return v[0] * v[0] + v[1] * v[1];\n\t            },\n\t            mul: function (out, v1, v2) {\n\t                out[0] = v1[0] * v2[0];\n\t                out[1] = v1[1] * v2[1];\n\t                return out;\n\t            },\n\t            div: function (out, v1, v2) {\n\t                out[0] = v1[0] / v2[0];\n\t                out[1] = v1[1] / v2[1];\n\t                return out;\n\t            },\n\t            dot: function (v1, v2) {\n\t                return v1[0] * v2[0] + v1[1] * v2[1];\n\t            },\n\t            scale: function (out, v, s) {\n\t                out[0] = v[0] * s;\n\t                out[1] = v[1] * s;\n\t                return out;\n\t            },\n\t            normalize: function (out, v) {\n\t                var d = vector.len(v);\n\t                if (d === 0) {\n\t                    out[0] = 0;\n\t                    out[1] = 0;\n\t                } else {\n\t                    out[0] = v[0] / d;\n\t                    out[1] = v[1] / d;\n\t                }\n\t                return out;\n\t            },\n\t            distance: function (v1, v2) {\n\t                return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n\t            },\n\t            distanceSquare: function (v1, v2) {\n\t                return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t            },\n\t            negate: function (out, v) {\n\t                out[0] = -v[0];\n\t                out[1] = -v[1];\n\t                return out;\n\t            },\n\t            lerp: function (out, v1, v2, t) {\n\t                out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t                out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t                return out;\n\t            },\n\t            applyTransform: function (out, v, m) {\n\t                var x = v[0];\n\t                var y = v[1];\n\t                out[0] = m[0] * x + m[2] * y + m[4];\n\t                out[1] = m[1] * x + m[3] * y + m[5];\n\t                return out;\n\t            },\n\t            min: function (out, v1, v2) {\n\t                out[0] = Math.min(v1[0], v2[0]);\n\t                out[1] = Math.min(v1[1], v2[1]);\n\t                return out;\n\t            },\n\t            max: function (out, v1, v2) {\n\t                out[0] = Math.max(v1[0], v2[0]);\n\t                out[1] = Math.max(v1[1], v2[1]);\n\t                return out;\n\t            }\n\t        };\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t    return vector;\n\t});\n\tdefine('echarts/scale/Scale', ['require', '../util/clazz'], function (require) {\n\t    var clazzUtil = require('../util/clazz');\n\t    function Scale() {\n\t        /**\n\t         * Extent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._extent = [\n\t            Infinity,\n\t            -Infinity\n\t        ];\n\t        /**\n\t         * Step is calculated in adjustExtent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._interval = 0;\n\t        this.init && this.init.apply(this, arguments);\n\t    }\n\t    var scaleProto = Scale.prototype;\n\t    /**\n\t     * Parse input val to valid inner number.\n\t     * @param {*} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.parse = function (val) {\n\t        // Notice: This would be a trap here, If the implementation\n\t        // of this method depends on extent, and this method is used\n\t        // before extent set (like in dataZoom), it would be wrong.\n\t        // Nevertheless, parse does not depend on extent generally.\n\t        return val;\n\t    };\n\t    scaleProto.contain = function (val) {\n\t        var extent = this._extent;\n\t        return val >= extent[0] && val <= extent[1];\n\t    };\n\t    /**\n\t     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.normalize = function (val) {\n\t        var extent = this._extent;\n\t        if (extent[1] === extent[0]) {\n\t            return 0.5;\n\t        }\n\t        return (val - extent[0]) / (extent[1] - extent[0]);\n\t    };\n\t    /**\n\t     * Scale normalized value\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.scale = function (val) {\n\t        var extent = this._extent;\n\t        return val * (extent[1] - extent[0]) + extent[0];\n\t    };\n\t    /**\n\t     * Set extent from data\n\t     * @param {Array.<number>} other\n\t     */\n\t    scaleProto.unionExtent = function (other) {\n\t        var extent = this._extent;\n\t        other[0] < extent[0] && (extent[0] = other[0]);\n\t        other[1] > extent[1] && (extent[1] = other[1]);    // not setExtent because in log axis it may transformed to power\n\t                                                           // this.setExtent(extent[0], extent[1]);\n\t    };\n\t    /**\n\t     * Get extent\n\t     * @return {Array.<number>}\n\t     */\n\t    scaleProto.getExtent = function () {\n\t        return this._extent.slice();\n\t    };\n\t    /**\n\t     * Set extent\n\t     * @param {number} start\n\t     * @param {number} end\n\t     */\n\t    scaleProto.setExtent = function (start, end) {\n\t        var thisExtent = this._extent;\n\t        if (!isNaN(start)) {\n\t            thisExtent[0] = start;\n\t        }\n\t        if (!isNaN(end)) {\n\t            thisExtent[1] = end;\n\t        }\n\t    };\n\t    /**\n\t     * @return {Array.<string>}\n\t     */\n\t    scaleProto.getTicksLabels = function () {\n\t        var labels = [];\n\t        var ticks = this.getTicks();\n\t        for (var i = 0; i < ticks.length; i++) {\n\t            labels.push(this.getLabel(ticks[i]));\n\t        }\n\t        return labels;\n\t    };\n\t    clazzUtil.enableClassExtend(Scale);\n\t    clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true });\n\t    return Scale;\n\t});\n\tdefine('echarts/coord/axisHelper', ['require', '../scale/Ordinal', '../scale/Interval', '../scale/Time', '../scale/Log', '../scale/Scale', '../util/number', 'zrender/core/util', 'zrender/contain/text'], function (require) {\n\t    var OrdinalScale = require('../scale/Ordinal');\n\t    var IntervalScale = require('../scale/Interval');\n\t    require('../scale/Time');\n\t    require('../scale/Log');\n\t    var Scale = require('../scale/Scale');\n\t    var numberUtil = require('../util/number');\n\t    var zrUtil = require('zrender/core/util');\n\t    var textContain = require('zrender/contain/text');\n\t    var axisHelper = {};\n\t    /**\n\t     * Get axis scale extent before niced.\n\t     */\n\t    axisHelper.getScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var originalExtent = scale.getExtent();\n\t        var span = originalExtent[1] - originalExtent[0];\n\t        if (scale.type === 'ordinal') {\n\t            // If series has no data, scale extent may be wrong\n\t            if (!isFinite(span)) {\n\t                return [\n\t                    0,\n\t                    0\n\t                ];\n\t            } else {\n\t                return originalExtent;\n\t            }\n\t        }\n\t        var min = model.getMin ? model.getMin() : model.get('min');\n\t        var max = model.getMax ? model.getMax() : model.get('max');\n\t        var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');\n\t        var boundaryGap = model.get('boundaryGap');\n\t        if (!zrUtil.isArray(boundaryGap)) {\n\t            boundaryGap = [\n\t                boundaryGap || 0,\n\t                boundaryGap || 0\n\t            ];\n\t        }\n\t        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n\t        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n\t        var fixMin = true;\n\t        var fixMax = true;\n\t        // Add boundary gap\n\t        if (min == null) {\n\t            min = originalExtent[0] - boundaryGap[0] * span;\n\t            fixMin = false;\n\t        }\n\t        if (max == null) {\n\t            max = originalExtent[1] + boundaryGap[1] * span;\n\t            fixMax = false;\n\t        }\n\t        if (min === 'dataMin') {\n\t            min = originalExtent[0];\n\t        }\n\t        if (max === 'dataMax') {\n\t            max = originalExtent[1];\n\t        }\n\t        // Evaluate if axis needs cross zero\n\t        if (crossZero) {\n\t            // Axis is over zero and min is not set\n\t            if (min > 0 && max > 0 && !fixMin) {\n\t                min = 0;\n\t            }\n\t            // Axis is under zero and max is not set\n\t            if (min < 0 && max < 0 && !fixMax) {\n\t                max = 0;\n\t            }\n\t        }\n\t        return [\n\t            min,\n\t            max\n\t        ];\n\t    };\n\t    axisHelper.niceScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var extent = axisHelper.getScaleExtent(axis, model);\n\t        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n\t        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n\t        var splitNumber = model.get('splitNumber');\n\t        if (scale.type === 'log') {\n\t            scale.base = model.get('logBase');\n\t        }\n\t        scale.setExtent(extent[0], extent[1]);\n\t        scale.niceExtent(splitNumber, fixMin, fixMax);\n\t        // Use minInterval to constraint the calculated interval.\n\t        // If calculated interval is less than minInterval. increase the interval quantity until\n\t        // it is larger than minInterval.\n\t        // For example:\n\t        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n\t        //  an integer axis.\n\t        var minInterval = model.get('minInterval');\n\t        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n\t            var interval = scale.getInterval();\n\t            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n\t            // while (interval < minInterval) {\n\t            //     var quantity = numberUtil.quantity(interval);\n\t            //     interval = quantity * 10;\n\t            //     scaleQuantity *= 10;\n\t            // }\n\t            extent = scale.getExtent();\n\t            scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);\n\t            scale.niceExtent(splitNumber);\n\t        }\n\t        // If some one specified the min, max. And the default calculated interval\n\t        // is not good enough. He can specify the interval. It is often appeared\n\t        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n\t        // to be 60.\n\t        // FIXME\n\t        var interval = model.get('interval');\n\t        if (interval != null) {\n\t            scale.setInterval && scale.setInterval(interval);\n\t        }\n\t    };\n\t    /**\n\t     * @param {module:echarts/model/Model} model\n\t     * @param {string} [axisType] Default retrieve from model.type\n\t     * @return {module:echarts/scale/*}\n\t     */\n\t    axisHelper.createScaleByModel = function (model, axisType) {\n\t        axisType = axisType || model.get('type');\n\t        if (axisType) {\n\t            switch (axisType) {\n\t            // Buildin scale\n\t            case 'category':\n\t                return new OrdinalScale(model.getCategories(), [\n\t                    Infinity,\n\t                    -Infinity\n\t                ]);\n\t            case 'value':\n\t                return new IntervalScale();\n\t            // Extended scale, like time and log\n\t            default:\n\t                return (Scale.getClass(axisType) || IntervalScale).create(model);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Check if the axis corss 0\n\t     */\n\t    axisHelper.ifAxisCrossZero = function (axis) {\n\t        var dataExtent = axis.scale.getExtent();\n\t        var min = dataExtent[0];\n\t        var max = dataExtent[1];\n\t        return !(min > 0 && max > 0 || min < 0 && max < 0);\n\t    };\n\t    /**\n\t     * @param {Array.<number>} tickCoords In axis self coordinate.\n\t     * @param {Array.<string>} labels\n\t     * @param {string} font\n\t     * @param {boolean} isAxisHorizontal\n\t     * @return {number}\n\t     */\n\t    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n\t        // FIXME\n\t        // axislabelhorizontalvertical.\n\t        var textSpaceTakenRect;\n\t        var autoLabelInterval = 0;\n\t        var accumulatedLabelInterval = 0;\n\t        var step = 1;\n\t        if (labels.length > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.floor(labels.length / 40);\n\t        }\n\t        for (var i = 0; i < tickCoords.length; i += step) {\n\t            var tickCoord = tickCoords[i];\n\t            var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n\t            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n\t            // FIXME Magic number 1.5\n\t            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n\t            if (!textSpaceTakenRect) {\n\t                textSpaceTakenRect = rect.clone();\n\t            }    // There is no space for current label;\n\t            else if (textSpaceTakenRect.intersect(rect)) {\n\t                accumulatedLabelInterval++;\n\t                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n\t            } else {\n\t                textSpaceTakenRect.union(rect);\n\t                // Reset\n\t                accumulatedLabelInterval = 0;\n\t            }\n\t        }\n\t        if (autoLabelInterval === 0 && step > 1) {\n\t            return step;\n\t        }\n\t        return (autoLabelInterval + 1) * step - 1;\n\t    };\n\t    /**\n\t     * @param {Object} axis\n\t     * @param {Function} labelFormatter\n\t     * @return {Array.<string>}\n\t     */\n\t    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n\t        var scale = axis.scale;\n\t        var labels = scale.getTicksLabels();\n\t        var ticks = scale.getTicks();\n\t        if (typeof labelFormatter === 'string') {\n\t            labelFormatter = function (tpl) {\n\t                return function (val) {\n\t                    return tpl.replace('{value}', val);\n\t                };\n\t            }(labelFormatter);\n\t            return zrUtil.map(labels, labelFormatter);\n\t        } else if (typeof labelFormatter === 'function') {\n\t            return zrUtil.map(ticks, function (tick, idx) {\n\t                return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);\n\t            }, this);\n\t        } else {\n\t            return labels;\n\t        }\n\t    };\n\t    return axisHelper;\n\t});\n\tdefine('echarts/coord/cartesian/Cartesian2D', ['require', 'zrender/core/util', './Cartesian'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var Cartesian = require('./Cartesian');\n\t    function Cartesian2D(name) {\n\t        Cartesian.call(this, name);\n\t    }\n\t    Cartesian2D.prototype = {\n\t        constructor: Cartesian2D,\n\t        type: 'cartesian2d',\n\t        dimensions: [\n\t            'x',\n\t            'y'\n\t        ],\n\t        getBaseAxis: function () {\n\t            return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n\t        },\n\t        containPoint: function (point) {\n\t            var axisX = this.getAxis('x');\n\t            var axisY = this.getAxis('y');\n\t            return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n\t        },\n\t        containData: function (data) {\n\t            return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n\t        },\n\t        dataToPoints: function (data, stack) {\n\t            return data.mapArray([\n\t                'x',\n\t                'y'\n\t            ], function (x, y) {\n\t                return this.dataToPoint([\n\t                    x,\n\t                    y\n\t                ]);\n\t            }, stack, this);\n\t        },\n\t        dataToPoint: function (data, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n\t                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n\t            ];\n\t        },\n\t        pointToData: function (point, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n\t                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n\t            ];\n\t        },\n\t        getOtherAxis: function (axis) {\n\t            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n\t        }\n\t    };\n\t    zrUtil.inherits(Cartesian2D, Cartesian);\n\t    return Cartesian2D;\n\t});\n\tdefine('echarts/coord/cartesian/Axis2D', ['require', 'zrender/core/util', '../Axis', './axisLabelInterval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Axis = require('../Axis');\n\t    var axisLabelInterval = require('./axisLabelInterval');\n\t    /**\n\t     * Extend axis 2d\n\t     * @constructor module:echarts/coord/cartesian/Axis2D\n\t     * @extends {module:echarts/coord/cartesian/Axis}\n\t     * @param {string} dim\n\t     * @param {*} scale\n\t     * @param {Array.<number>} coordExtent\n\t     * @param {string} axisType\n\t     * @param {string} position\n\t     */\n\t    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n\t        Axis.call(this, dim, scale, coordExtent);\n\t        /**\n\t         * Axis type\n\t         *  - 'category'\n\t         *  - 'value'\n\t         *  - 'time'\n\t         *  - 'log'\n\t         * @type {string}\n\t         */\n\t        this.type = axisType || 'value';\n\t        /**\n\t         * Axis position\n\t         *  - 'top'\n\t         *  - 'bottom'\n\t         *  - 'left'\n\t         *  - 'right'\n\t         */\n\t        this.position = position || 'bottom';\n\t    };\n\t    Axis2D.prototype = {\n\t        constructor: Axis2D,\n\t        index: 0,\n\t        onZero: false,\n\t        model: null,\n\t        isHorizontal: function () {\n\t            var position = this.position;\n\t            return position === 'top' || position === 'bottom';\n\t        },\n\t        getGlobalExtent: function () {\n\t            var ret = this.getExtent();\n\t            ret[0] = this.toGlobalCoord(ret[0]);\n\t            ret[1] = this.toGlobalCoord(ret[1]);\n\t            return ret;\n\t        },\n\t        getLabelInterval: function () {\n\t            var labelInterval = this._labelInterval;\n\t            if (!labelInterval) {\n\t                labelInterval = this._labelInterval = axisLabelInterval(this);\n\t            }\n\t            return labelInterval;\n\t        },\n\t        isLabelIgnored: function (idx) {\n\t            if (this.type === 'category') {\n\t                var labelInterval = this.getLabelInterval();\n\t                return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n\t            }\n\t        },\n\t        toLocalCoord: null,\n\t        toGlobalCoord: null\n\t    };\n\t    zrUtil.inherits(Axis2D, Axis);\n\t    return Axis2D;\n\t});\n\tdefine('echarts/coord/cartesian/GridModel', ['require', './AxisModel', '../../model/Component'], function (require) {\n\t    'use strict';\n\t    require('./AxisModel');\n\t    var ComponentModel = require('../../model/Component');\n\t    return ComponentModel.extend({\n\t        type: 'grid',\n\t        dependencies: [\n\t            'xAxis',\n\t            'yAxis'\n\t        ],\n\t        layoutMode: 'box',\n\t        coordinateSystem: null,\n\t        defaultOption: {\n\t            show: false,\n\t            zlevel: 0,\n\t            z: 0,\n\t            left: '10%',\n\t            top: 60,\n\t            right: '10%',\n\t            bottom: 60,\n\t            containLabel: false,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderWidth: 1,\n\t            borderColor: '#ccc'\n\t        }\n\t    });\n\t});\n\tdefine('zrender/tool/path', ['require', '../graphic/Path', '../core/PathProxy', './transformPath', '../core/matrix'], function (require) {\n\t    var Path = require('../graphic/Path');\n\t    var PathProxy = require('../core/PathProxy');\n\t    var transformPath = require('./transformPath');\n\t    var matrix = require('../core/matrix');\n\t    // command chars\n\t    var cc = [\n\t            'm',\n\t            'M',\n\t            'l',\n\t            'L',\n\t            'v',\n\t            'V',\n\t            'h',\n\t            'H',\n\t            'z',\n\t            'Z',\n\t            'c',\n\t            'C',\n\t            'q',\n\t            'Q',\n\t            't',\n\t            'T',\n\t            's',\n\t            'S',\n\t            'a',\n\t            'A'\n\t        ];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t    var vMag = function (v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function (u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function (u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n\t    };\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;\n\t        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t        var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t        var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n\t        var theta = vAngle([\n\t                1,\n\t                0\n\t            ], [\n\t                (xp - cxp) / rx,\n\t                (yp - cyp) / ry\n\t            ]);\n\t        var u = [\n\t                (xp - cxp) / rx,\n\t                (yp - cyp) / ry\n\t            ];\n\t        var v = [\n\t                (-1 * xp - cxp) / rx,\n\t                (-1 * yp - cyp) / ry\n\t            ];\n\t        var dTheta = vAngle(u, v);\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                case 'l':\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'L':\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'm':\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.M;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    c = 'l';\n\t                    break;\n\t                case 'M':\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.M;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    c = 'L';\n\t                    break;\n\t                case 'h':\n\t                    cpx += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'H':\n\t                    cpx = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'v':\n\t                    cpy += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'V':\n\t                    cpy = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'C':\n\t                    cmd = CMD.C;\n\t                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n\t                    cpx = p[off - 2];\n\t                    cpy = p[off - 1];\n\t                    break;\n\t                case 'c':\n\t                    cmd = CMD.C;\n\t                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n\t                    cpx += p[off - 2];\n\t                    cpy += p[off - 1];\n\t                    break;\n\t                case 'S':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.C) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cmd = CMD.C;\n\t                    x1 = p[off++];\n\t                    y1 = p[off++];\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 's':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.C) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cmd = CMD.C;\n\t                    x1 = cpx + p[off++];\n\t                    y1 = cpy + p[off++];\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'Q':\n\t                    x1 = p[off++];\n\t                    y1 = p[off++];\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'q':\n\t                    x1 = p[off++] + cpx;\n\t                    y1 = p[off++] + cpy;\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'T':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.Q) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                    break;\n\t                case 't':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.Q) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                    break;\n\t                case 'A':\n\t                    rx = p[off++];\n\t                    ry = p[off++];\n\t                    psi = p[off++];\n\t                    fa = p[off++];\n\t                    fs = p[off++];\n\t                    x1 = cpx, y1 = cpy;\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.A;\n\t                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t                    break;\n\t                case 'a':\n\t                    rx = p[off++];\n\t                    ry = p[off++];\n\t                    psi = p[off++];\n\t                    fa = p[off++];\n\t                    fs = p[off++];\n\t                    x1 = cpx, y1 = cpy;\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.A;\n\t                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t                    break;\n\t                }\n\t            }\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t            prevCmd = cmd;\n\t        }\n\t        path.toStatic();\n\t        return path;\n\t    }\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t        return opts;\n\t    }\n\t    return {\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t            return pathBundle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/Path', ['require', './Displayable', '../core/util', '../core/PathProxy', '../contain/path', './Pattern'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var zrUtil = require('../core/util');\n\t    var PathProxy = require('../core/PathProxy');\n\t    var pathContain = require('../contain/path');\n\t    var Pattern = require('./Pattern');\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t    var abs = Math.abs;\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t    Path.prototype = {\n\t        constructor: Path,\n\t        type: 'path',\n\t        __dirtyPath: true,\n\t        strokeContainThreshold: 5,\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!fill.colorStops;\n\t            var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n\t            var hasFillPattern = hasFill && !!fill.image;\n\t            var hasStrokePattern = hasStroke && !!stroke.image;\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            } else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            } else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n\t                path = this.path.beginPath(ctx);\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t                this.buildPath(path, this.shape, false);\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            } else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t            hasFill && path.fill(ctx);\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t            hasStroke && path.stroke(ctx);\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t            this.restoreTransform(ctx);\n\t            // Draw rect text\n\t            if (style.text || style.text === 0) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t        buildPath: function (ctx, shapeCfg, inBundle) {\n\t        },\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t            return rect;\n\t        },\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            } else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        shape[name] = key[name];\n\t                    }\n\t                } else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n\t        }\n\t    };\n\t    /**\n\t     *  Path element, \n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t        zrUtil.inherits(Sub, Path);\n\t        // FIXME  extend position, rotation \n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t        return Sub;\n\t    };\n\t    zrUtil.inherits(Path, Displayable);\n\t    return Path;\n\t});\n\tdefine('zrender/graphic/Gradient', ['require'], function (require) {\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t        this.colorStops = colorStops || [];\n\t    };\n\t    Gradient.prototype = {\n\t        constructor: Gradient,\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t                offset: offset,\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t    return Gradient;\n\t});\n\tdefine('zrender/container/Group', ['require', '../core/util', '../Element', '../core/BoundingRect'], function (require) {\n\t    var zrUtil = require('../core/util');\n\t    var Element = require('../Element');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t        opts = opts || {};\n\t        Element.call(this, opts);\n\t        for (var key in opts) {\n\t            this[key] = opts[key];\n\t        }\n\t        this._children = [];\n\t        this.__storage = null;\n\t        this.__dirty = true;\n\t    };\n\t    Group.prototype = {\n\t        constructor: Group,\n\t        isGroup: true,\n\t        type: 'group',\n\t        silent: false,\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t            }\n\t        },\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t                this._children.push(child);\n\t                this._doAdd(child);\n\t            }\n\t            return this;\n\t        },\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t            child.parent = this;\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t            zr && zr.refresh();\n\t        },\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t            child.parent = null;\n\t            if (storage) {\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t            zr && zr.refresh();\n\t            return this;\n\t        },\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t            return this;\n\t        },\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            // TODO Transform\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                } else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t    zrUtil.inherits(Group, Element);\n\t    return Group;\n\t});\n\tdefine('zrender/graphic/Text', ['require', './Displayable', '../core/util', '../contain/text'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var zrUtil = require('../core/util');\n\t    var textContain = require('../contain/text');\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t    Text.prototype = {\n\t        constructor: Text,\n\t        type: 'text',\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t            if (text) {\n\t                this.setTransform(ctx);\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(text, font, style.textAlign, 'top');\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                    case 'middle':\n\t                        y -= rect.height / 2 - rect.lineHeight / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= rect.height - rect.lineHeight / 2;\n\t                        break;\n\t                    default:\n\t                        y += rect.lineHeight / 2;\n\t                    }\n\t                } else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t                var lineHeight = textContain.measureText('', ctx.font).width;\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);\n\t                switch (textVerticalAlign) {\n\t                case 'middle':\n\t                    rect.y -= rect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    rect.y -= rect.height;\n\t                    break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t    zrUtil.inherits(Text, Displayable);\n\t    return Text;\n\t});\n\tdefine('zrender/graphic/Image', ['require', './Displayable', '../core/BoundingRect', '../core/util', '../core/LRU'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    var zrUtil = require('../core/util');\n\t    var LRU = require('../core/LRU');\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t    ZImage.prototype = {\n\t        constructor: ZImage,\n\t        type: 'image',\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }    // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                } else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t            if (image) {\n\t                // \n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // \n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t                // transform\n\t                this.setTransform(ctx);\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n\t                } else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n\t                } else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t                // \n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t                this.restoreTransform(ctx);\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (!this._rect) {\n\t                this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t    zrUtil.inherits(ZImage, Displayable);\n\t    return ZImage;\n\t});\n\tdefine('zrender/graphic/shape/Circle', ['require', '../Path'], function (require) {\n\t    'use strict';\n\t    return require('../Path').extend({\n\t        type: 'circle',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t        buildPath: function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Ring', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'ring',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Sector', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'sector',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r0: 0,\n\t            r: 0,\n\t            startAngle: 0,\n\t            endAngle: Math.PI * 2,\n\t            clockwise: true\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t            ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t            ctx.closePath();\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Rect', ['require', '../helper/roundRect', '../Path'], function (require) {\n\t    var roundRectHelper = require('../helper/roundRect');\n\t    return require('../Path').extend({\n\t        type: 'rect',\n\t        shape: {\n\t            r: 0,\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            } else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Polygon', ['require', '../helper/poly', '../Path'], function (require) {\n\t    var polyHelper = require('../helper/poly');\n\t    return require('../Path').extend({\n\t        type: 'polygon',\n\t        shape: {\n\t            points: null,\n\t            smooth: false,\n\t            smoothConstraint: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Polyline', ['require', '../helper/poly', '../Path'], function (require) {\n\t    var polyHelper = require('../helper/poly');\n\t    return require('../Path').extend({\n\t        type: 'polyline',\n\t        shape: {\n\t            points: null,\n\t            smooth: false,\n\t            smoothConstraint: null\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Line', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'line',\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            percent: 1\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t            ctx.moveTo(x1, y1);\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/BezierCurve', ['require', '../../core/curve', '../../core/vector', '../Path'], function (require) {\n\t    'use strict';\n\t    var curveTool = require('../../core/curve');\n\t    var vec2 = require('../../core/vector');\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t    var out = [];\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        } else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    return require('../Path').extend({\n\t        type: 'bezier-curve',\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            percent: 1\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t            ctx.moveTo(x1, y1);\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(x1, cpx1, x2, percent, out);\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(y1, cpy1, y2, percent, out);\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t                ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n\t            } else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n\t            }\n\t        },\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Arc', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'arc',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            startAngle: 0,\n\t            endAngle: Math.PI * 2,\n\t            clockwise: true\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/RadialGradient', ['require', '../core/util', './Gradient'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('../core/util');\n\t    var Gradient = require('./Gradient');\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t        this.y = y == null ? 0.5 : y;\n\t        this.r = r == null ? 0.5 : r;\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t        Gradient.call(this, colorStops);\n\t    };\n\t    RadialGradient.prototype = { constructor: RadialGradient };\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t    return RadialGradient;\n\t});\n\tdefine('zrender/graphic/LinearGradient', ['require', '../core/util', './Gradient'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('../core/util');\n\t    var Gradient = require('./Gradient');\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t        this.y = y == null ? 0 : y;\n\t        this.x2 = x2 == null ? 1 : x2;\n\t        this.y2 = y2 == null ? 0 : y2;\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t        Gradient.call(this, colorStops);\n\t    };\n\t    LinearGradient.prototype = { constructor: LinearGradient };\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t    return LinearGradient;\n\t});\n\tdefine('zrender/graphic/CompoundPath', ['require', './Path'], function (require) {\n\t    var Path = require('./Path');\n\t    return Path.extend({\n\t        type: 'compound',\n\t        shape: { paths: null },\n\t        _updatePathDirty: function () {\n\t            var dirtyPath = this.__dirtyPath;\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                // Mark as dirty if any subpath is dirty\n\t                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n\t            }\n\t            this.__dirtyPath = dirtyPath;\n\t            this.__dirty = this.__dirty || dirtyPath;\n\t        },\n\t        beforeBrush: function () {\n\t            this._updatePathDirty();\n\t            var paths = this.shape.paths || [];\n\t            var scale = this.getGlobalScale();\n\t            // Update path scale\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].path.setScale(scale[0], scale[1]);\n\t            }\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var paths = shape.paths || [];\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].buildPath(ctx, paths[i].shape, true);\n\t            }\n\t        },\n\t        afterBrush: function () {\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].__dirtyPath = false;\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            this._updatePathDirty();\n\t            return Path.prototype.getBoundingRect.call(this);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/core/BoundingRect', ['require', './vector', './matrix'], function (require) {\n\t    'use strict';\n\t    var vec2 = require('./vector');\n\t    var matrix = require('./matrix');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathAbs = Math.abs;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t    BoundingRect.prototype = {\n\t        constructor: BoundingRect,\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n\t            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t        applyTransform: function () {\n\t            var min = [];\n\t            var max = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                min[0] = this.x;\n\t                min[1] = this.y;\n\t                max[0] = this.x + this.width;\n\t                max[1] = this.y + this.height;\n\t                v2ApplyTransform(min, min, m);\n\t                v2ApplyTransform(max, max, m);\n\t                this.x = mathMin(min[0], max[0]);\n\t                this.y = mathMin(min[1], max[1]);\n\t                this.width = mathAbs(max[0] - min[0]);\n\t                this.height = mathAbs(max[1] - min[1]);\n\t            };\n\t        }(),\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t            var m = matrix.create();\n\t            // \n\t            matrix.translate(m, m, [\n\t                -a.x,\n\t                -a.y\n\t            ]);\n\t            matrix.scale(m, m, [\n\t                sx,\n\t                sy\n\t            ]);\n\t            matrix.translate(m, m, [\n\t                b.x,\n\t                b.y\n\t            ]);\n\t            return m;\n\t        },\n\t        intersect: function (b) {\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t            return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n\t        },\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        }\n\t    };\n\t    return BoundingRect;\n\t});\n\tdefine('zrender/contain/text', ['require', '../core/util', '../core/BoundingRect'], function (require) {\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t    var util = require('../core/util');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    var retrieve = util.retrieve;\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText  Canvas \n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t        return width;\n\t    }\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME \n\t        var lineHeight = getTextWidth('', textFont);\n\t        var height = textLineLen * lineHeight;\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t        switch (textBaseline) {\n\t        case 'bottom':\n\t        case 'alphabetic':\n\t            rect.y -= lineHeight;\n\t            break;\n\t        case 'middle':\n\t            rect.y -= lineHeight / 2;\n\t            break;    // case 'hanging':\n\t                      // case 'top':\n\t        }\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t        case 'end':\n\t        case 'right':\n\t            rect.x -= rect.width;\n\t            break;\n\t        case 'center':\n\t            rect.x -= rect.width / 2;\n\t            break;    // case 'start':\n\t                      // case 'left':\n\t        }\n\t        return rect;\n\t    }\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t        var textHeight = textRect.height;\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t        var textAlign = 'left';\n\t        switch (textPosition) {\n\t        case 'left':\n\t            x -= distance;\n\t            y += halfHeight;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'right':\n\t            x += distance + width;\n\t            y += halfHeight;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'top':\n\t            x += width / 2;\n\t            y -= distance + textHeight;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'bottom':\n\t            x += width / 2;\n\t            y += height + distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'inside':\n\t            x += width / 2;\n\t            y += halfHeight;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideLeft':\n\t            x += distance;\n\t            y += halfHeight;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'insideRight':\n\t            x += width - distance;\n\t            y += halfHeight;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'insideTop':\n\t            x += width / 2;\n\t            y += distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideBottom':\n\t            x += width / 2;\n\t            y += height - textHeight - distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideTopLeft':\n\t            x += distance;\n\t            y += distance;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'insideTopRight':\n\t            x += width - distance;\n\t            y += distance;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'insideBottomLeft':\n\t            x += distance;\n\t            y += height - textHeight - distance;\n\t            break;\n\t        case 'insideBottomRight':\n\t            x += width - distance;\n\t            y += height - textHeight - distance;\n\t            textAlign = 'right';\n\t            break;\n\t        }\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t        options = options || {};\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n\t        // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t        var textLines = (text + '').split('\\n');\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t                var subLength = j === 0 ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t            textLines[i] = textLine;\n\t        }\n\t        return textLines.join('\\n');\n\t    }\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t    var textContain = {\n\t            getWidth: getTextWidth,\n\t            getBoundingRect: getTextRect,\n\t            adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t            truncateText: truncateText,\n\t            measureText: function (text, textFont) {\n\t                var ctx = util.getContext();\n\t                ctx.font = textFont || '12px sans-serif';\n\t                return ctx.measureText(text);\n\t            }\n\t        };\n\t    return textContain;\n\t});\n\tdefine('echarts/util/model', ['require', './format', './number', '../model/Model', 'zrender/core/util'], function (require) {\n\t    var formatUtil = require('./format');\n\t    var nubmerUtil = require('./number');\n\t    var Model = require('../model/Model');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = {};\n\t    /**\n\t     * If value is not array, then translate it to array.\n\t     * @param  {*} value\n\t     * @return {Array} [value] or value\n\t     */\n\t    modelUtil.normalizeToArray = function (value) {\n\t        return value instanceof Array ? value : value == null ? [] : [value];\n\t    };\n\t    /**\n\t     * Sync default option between normal and emphasis like `position` and `show`\n\t     * In case some one will write code like\n\t     *     label: {\n\t     *         normal: {\n\t     *             show: false,\n\t     *             position: 'outside',\n\t     *             textStyle: {\n\t     *                 fontSize: 18\n\t     *             }\n\t     *         },\n\t     *         emphasis: {\n\t     *             show: true\n\t     *         }\n\t     *     }\n\t     * @param {Object} opt\n\t     * @param {Array.<string>} subOpts\n\t     */\n\t    modelUtil.defaultEmphasis = function (opt, subOpts) {\n\t        if (opt) {\n\t            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n\t            var normalOpt = opt.normal = opt.normal || {};\n\t            // Default emphasis option from normal\n\t            zrUtil.each(subOpts, function (subOptName) {\n\t                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n\t                if (val != null) {\n\t                    emphasisOpt[subOptName] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t    modelUtil.LABEL_OPTIONS = [\n\t        'position',\n\t        'show',\n\t        'textStyle',\n\t        'distance',\n\t        'formatter'\n\t    ];\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method retieves value from data.\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     * @return {number|string|Date|Array.<number|string|Date>}\n\t     */\n\t    modelUtil.getDataItemValue = function (dataItem) {\n\t        // Performance sensitive.\n\t        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\t    };\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method determine if dataItem has extra option besides value\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     */\n\t    modelUtil.isDataItemOption = function (dataItem) {\n\t        return zrUtil.isObject(dataItem) && !(dataItem instanceof Array);    // // markLine data can be array\n\t                                                                             // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n\t    };\n\t    /**\n\t     * This helper method convert value in data.\n\t     * @param {string|number|Date} value\n\t     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n\t     */\n\t    modelUtil.converDataValue = function (value, dimInfo) {\n\t        // Performance sensitive.\n\t        var dimType = dimInfo && dimInfo.type;\n\t        if (dimType === 'ordinal') {\n\t            return value;\n\t        }\n\t        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n\t            value = +nubmerUtil.parseDate(value);\n\t        }\n\t        // dimType defaults 'number'.\n\t        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n\t        // parse to NaN.\n\t        return value == null || value === '' ? NaN : +value;    // If string (like '-'), using '+' parse to NaN\n\t    };\n\t    /**\n\t     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} opt\n\t     * @param {string} [opt.seriesIndex]\n\t     * @param {Object} [opt.name]\n\t     * @param {Object} [opt.mainType]\n\t     * @param {Object} [opt.subType]\n\t     */\n\t    modelUtil.createDataFormatModel = function (data, opt) {\n\t        var model = new Model();\n\t        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n\t        model.seriesIndex = opt.seriesIndex;\n\t        model.name = opt.name || '';\n\t        model.mainType = opt.mainType;\n\t        model.subType = opt.subType;\n\t        model.getData = function () {\n\t            return data;\n\t        };\n\t        return model;\n\t    };\n\t    // PENDING A little ugly\n\t    modelUtil.dataFormatMixin = {\n\t        getDataParams: function (dataIndex, dataType) {\n\t            var data = this.getData(dataType);\n\t            var seriesIndex = this.seriesIndex;\n\t            var seriesName = this.name;\n\t            var rawValue = this.getRawValue(dataIndex, dataType);\n\t            var rawDataIndex = data.getRawIndex(dataIndex);\n\t            var name = data.getName(dataIndex, true);\n\t            var itemOpt = data.getRawDataItem(dataIndex);\n\t            return {\n\t                componentType: this.mainType,\n\t                componentSubType: this.subType,\n\t                seriesType: this.mainType === 'series' ? this.subType : null,\n\t                seriesIndex: seriesIndex,\n\t                seriesName: seriesName,\n\t                name: name,\n\t                dataIndex: rawDataIndex,\n\t                data: itemOpt,\n\t                dataType: dataType,\n\t                value: rawValue,\n\t                color: data.getItemVisual(dataIndex, 'color'),\n\t                $vars: [\n\t                    'seriesName',\n\t                    'name',\n\t                    'value'\n\t                ]\n\t            };\n\t        },\n\t        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n\t            status = status || 'normal';\n\t            var data = this.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t            var params = this.getDataParams(dataIndex, dataType);\n\t            if (dimIndex != null && params.value instanceof Array) {\n\t                params.value = params.value[dimIndex];\n\t            }\n\t            var formatter = itemModel.get([\n\t                    'label',\n\t                    status,\n\t                    'formatter'\n\t                ]);\n\t            if (typeof formatter === 'function') {\n\t                params.status = status;\n\t                return formatter(params);\n\t            } else if (typeof formatter === 'string') {\n\t                return formatUtil.formatTpl(formatter, params);\n\t            }\n\t        },\n\t        getRawValue: function (idx, dataType) {\n\t            var data = this.getData(dataType);\n\t            var dataItem = data.getRawDataItem(idx);\n\t            if (dataItem != null) {\n\t                return zrUtil.isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n\t            }\n\t        },\n\t        formatTooltip: zrUtil.noop\n\t    };\n\t    /**\n\t     * Mapping to exists for merge.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n\t     * @param {Object|Array.<Object>} newCptOptions\n\t     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          which order is the same as exists.\n\t     */\n\t    modelUtil.mappingToExists = function (exists, newCptOptions) {\n\t        // Mapping by the order by original option (but not order of\n\t        // new option) in merge mode. Because we should ensure\n\t        // some specified index (like xAxisIndex) is consistent with\n\t        // original option, which is easy to understand, espatially in\n\t        // media query. And in most case, merge option is used to\n\t        // update partial option but not be expected to change order.\n\t        newCptOptions = (newCptOptions || []).slice();\n\t        var result = zrUtil.map(exists || [], function (obj, index) {\n\t                return { exist: obj };\n\t            });\n\t        // Mapping by id or name if specified.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t            // id has highest priority.\n\t            for (var i = 0; i < result.length; i++) {\n\t                if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t            for (var i = 0; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '') {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t        // Otherwise mapping by index.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t            var i = 0;\n\t            for (; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {\n\t                    result[i].option = cptOption;\n\t                    break;\n\t                }\n\t            }\n\t            if (i >= result.length) {\n\t                result.push({ option: cptOption });\n\t            }\n\t        });\n\t        return result;\n\t    };\n\t    /**\n\t     * @public\n\t     * @param {Object} cptOption\n\t     * @return {boolean}\n\t     */\n\t    modelUtil.isIdInner = function (cptOption) {\n\t        return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\u0000_ec_\u0000') === 0;\n\t    };\n\t    /**\n\t     * A helper for removing duplicate items between batchA and batchB,\n\t     * and in themselves, and categorize by series.\n\t     *\n\t     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n\t     */\n\t    modelUtil.compressBatches = function (batchA, batchB) {\n\t        var mapA = {};\n\t        var mapB = {};\n\t        makeMap(batchA || [], mapA);\n\t        makeMap(batchB || [], mapB, mapA);\n\t        return [\n\t            mapToArray(mapA),\n\t            mapToArray(mapB)\n\t        ];\n\t        function makeMap(sourceBatch, map, otherMap) {\n\t            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n\t                var seriesId = sourceBatch[i].seriesId;\n\t                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n\t                var otherDataIndices = otherMap && otherMap[seriesId];\n\t                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n\t                    var dataIndex = dataIndices[j];\n\t                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n\t                        otherDataIndices[dataIndex] = null;\n\t                    } else {\n\t                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function mapToArray(map, isData) {\n\t            var result = [];\n\t            for (var i in map) {\n\t                if (map.hasOwnProperty(i) && map[i] != null) {\n\t                    if (isData) {\n\t                        result.push(+i);\n\t                    } else {\n\t                        var dataIndices = mapToArray(map[i], true);\n\t                        dataIndices.length && result.push({\n\t                            seriesId: i,\n\t                            dataIndex: dataIndices\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\t    return modelUtil;\n\t});\n\tdefine('echarts/model/globalDefault', [], function () {\n\t    var platform = '';\n\t    // Navigator not exists in node\n\t    if (typeof navigator !== 'undefined') {\n\t        platform = navigator.platform || '';\n\t    }\n\t    return {\n\t        color: [\n\t            '#c23531',\n\t            '#2f4554',\n\t            '#61a0a8',\n\t            '#d48265',\n\t            '#91c7ae',\n\t            '#749f83',\n\t            '#ca8622',\n\t            '#bda29a',\n\t            '#6e7074',\n\t            '#546570',\n\t            '#c4ccd3'\n\t        ],\n\t        textStyle: {\n\t            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n\t            fontSize: 12,\n\t            fontStyle: 'normal',\n\t            fontWeight: 'normal'\n\t        },\n\t        blendMode: null,\n\t        animation: true,\n\t        animationDuration: 1000,\n\t        animationDurationUpdate: 300,\n\t        animationEasing: 'exponentialOut',\n\t        animationEasingUpdate: 'cubicOut',\n\t        animationThreshold: 2000,\n\t        progressiveThreshold: 3000,\n\t        progressive: 400,\n\t        hoverLayerThreshold: 3000\n\t    };\n\t});\n\tdefine('echarts/model/mixin/colorPalette', [], function () {\n\t    return {\n\t        clearColorPalette: function () {\n\t            this._colorIdx = 0;\n\t            this._colorNameMap = {};\n\t        },\n\t        getColorFromPalette: function (name, scope) {\n\t            scope = scope || this;\n\t            var colorIdx = scope._colorIdx || 0;\n\t            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n\t            if (colorNameMap[name]) {\n\t                return colorNameMap[name];\n\t            }\n\t            var colorPalette = this.get('color', true) || [];\n\t            if (!colorPalette.length) {\n\t                return;\n\t            }\n\t            var color = colorPalette[colorIdx];\n\t            if (name) {\n\t                colorNameMap[name] = color;\n\t            }\n\t            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\t            return color;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/core/PathProxy', ['require', './curve', './vector', './bbox', './BoundingRect', '../config'], function (require) {\n\t    'use strict';\n\t    var curve = require('./curve');\n\t    var vec2 = require('./vector');\n\t    var bbox = require('./bbox');\n\t    var BoundingRect = require('./BoundingRect');\n\t    var dpr = require('../config').devicePixelRatio;\n\t    var CMD = {\n\t            M: 1,\n\t            L: 2,\n\t            C: 3,\n\t            Q: 4,\n\t            A: 5,\n\t            Z: 6,\n\t            R: 7\n\t        };\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t        this._len = 0;\n\t        this._ctx = null;\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t    /**\n\t     * Path\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t        constructor: PathProxy,\n\t        _lineDash: null,\n\t        _dashOffset: 0,\n\t        _dashIdx: 0,\n\t        _dashSum: 0,\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t        beginPath: function (ctx) {\n\t            this._ctx = ctx;\n\t            ctx && ctx.beginPath();\n\t            ctx && (this.dpr = ctx.dpr);\n\t            // Reset\n\t            this._len = 0;\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t                this._dashOffset = 0;\n\t            }\n\t            return this;\n\t        },\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t            // x0, y0, xi, yi  _dashedXXXXTo \n\t            // xi, yi , x0, y0  closePath \n\t            //  beginPath  lineTo x0, y0 \n\t            //  lineTo dashed line  IE10- \n\t            this._x0 = x;\n\t            this._y0 = y;\n\t            this._xi = x;\n\t            this._yi = y;\n\t            return this;\n\t        },\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;\n\t            this.addData(CMD.L, x, y);\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t            return this;\n\t        },\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t                this._dashIdx = 0;\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t        setData: function (data) {\n\t            var len = data.length;\n\t            if (!(this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t            this._len = len;\n\t        },\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && this.data instanceof Float32Array) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                //  Float32Array\n\t                // \n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t            this._prevCmd = cmd;\n\t        },\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t            while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t            var x;\n\t            var y;\n\t            var tmpLen = 0;\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t            while (t <= 1) {\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n\t                t += lineDash[idx] / bezierLen;\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t            // Finish the last segment and calculate the new offset\n\t            idx % 2 !== 0 && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo  subpath, \n\t                    //  closePath \n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    min2[0] = x0;\n\t                    min2[1] = y0;\n\t                    max2[0] = x0;\n\t                    max2[1] = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc \n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++];\n\t                    var endAngle = data[i++] + startAngle;\n\t                    // TODO Arc \n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    if (i == 1) {\n\t                        //  arc \n\t                        // \n\t                        x0 = mathCos(startAngle) * rx + cx;\n\t                        y0 = mathSin(startAngle) * ry + cy;\n\t                    }\n\t                    bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n\t                    xi = mathCos(endAngle) * rx + cx;\n\t                    yi = mathSin(endAngle) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    // Use fromLine\n\t                    bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                    break;\n\t                case CMD.Z:\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                }\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t            return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t        },\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                case CMD.M:\n\t                    x0 = xi = d[i++];\n\t                    y0 = yi = d[i++];\n\t                    ctx.moveTo(xi, yi);\n\t                    break;\n\t                case CMD.L:\n\t                    x = d[i++];\n\t                    y = d[i++];\n\t                    // Not draw too small seg between\n\t                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                        ctx.lineTo(x, y);\n\t                        xi = x;\n\t                        yi = y;\n\t                    }\n\t                    break;\n\t                case CMD.C:\n\t                    ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n\t                    xi = d[i - 2];\n\t                    yi = d[i - 1];\n\t                    break;\n\t                case CMD.Q:\n\t                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                    xi = d[i - 2];\n\t                    yi = d[i - 1];\n\t                    break;\n\t                case CMD.A:\n\t                    var cx = d[i++];\n\t                    var cy = d[i++];\n\t                    var rx = d[i++];\n\t                    var ry = d[i++];\n\t                    var theta = d[i++];\n\t                    var dTheta = d[i++];\n\t                    var psi = d[i++];\n\t                    var fs = d[i++];\n\t                    var r = rx > ry ? rx : ry;\n\t                    var scaleX = rx > ry ? 1 : rx / ry;\n\t                    var scaleY = rx > ry ? ry / rx : 1;\n\t                    var isEllipse = Math.abs(rx - ry) > 0.001;\n\t                    var endAngle = theta + dTheta;\n\t                    if (isEllipse) {\n\t                        ctx.translate(cx, cy);\n\t                        ctx.rotate(psi);\n\t                        ctx.scale(scaleX, scaleY);\n\t                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                        ctx.scale(1 / scaleX, 1 / scaleY);\n\t                        ctx.rotate(-psi);\n\t                        ctx.translate(-cx, -cy);\n\t                    } else {\n\t                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                    }\n\t                    if (i == 1) {\n\t                        //  arc \n\t                        // \n\t                        x0 = mathCos(theta) * rx + cx;\n\t                        y0 = mathSin(theta) * ry + cy;\n\t                    }\n\t                    xi = mathCos(endAngle) * rx + cx;\n\t                    yi = mathSin(endAngle) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = d[i];\n\t                    y0 = yi = d[i + 1];\n\t                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                    break;\n\t                case CMD.Z:\n\t                    ctx.closePath();\n\t                    xi = x0;\n\t                    yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    PathProxy.CMD = CMD;\n\t    return PathProxy;\n\t});\n\tdefine('zrender/tool/transformPath', ['require', '../core/PathProxy', '../core/vector'], function (require) {\n\t    var CMD = require('../core/PathProxy').CMD;\n\t    var vec2 = require('../core/vector');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var points = [\n\t            [],\n\t            [],\n\t            []\n\t        ];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t            case M:\n\t                nPoint = 1;\n\t                break;\n\t            case L:\n\t                nPoint = 1;\n\t                break;\n\t            case C:\n\t                nPoint = 3;\n\t                break;\n\t            case Q:\n\t                nPoint = 2;\n\t                break;\n\t            case A:\n\t                var x = m[4];\n\t                var y = m[5];\n\t                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                // cx\n\t                data[i++] += x;\n\t                // cy\n\t                data[i++] += y;\n\t                // Scale rx and ry\n\t                // FIXME Assume psi is 0 here\n\t                data[i++] *= sx;\n\t                data[i++] *= sy;\n\t                // Start angle\n\t                data[i++] += angle;\n\t                // end angle\n\t                data[i++] += angle;\n\t                // FIXME psi\n\t                i += 2;\n\t                j = i;\n\t                break;\n\t            case R:\n\t                // x0, y0\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t                // x1, y1\n\t                p[0] += data[i++];\n\t                p[1] += data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t    return transformPath;\n\t});\n\tdefine('echarts/util/clazz', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazz = {};\n\t    var TYPE_DELIMITER = '.';\n\t    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n\t    /**\n\t     * @public\n\t     */\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\n\t            var ret = {\n\t                    main: '',\n\t                    sub: ''\n\t                };\n\t            if (componentType) {\n\t                componentType = componentType.split(TYPE_DELIMITER);\n\t                ret.main = componentType[0] || '';\n\t                ret.sub = componentType[1] || '';\n\t            }\n\t            return ret;\n\t        };\n\t    /**\n\t     * @public\n\t     */\n\t    clazz.enableClassExtend = function (RootClass) {\n\t        RootClass.$constructor = RootClass;\n\t        RootClass.extend = function (proto) {\n\t            var superClass = this;\n\t            var ExtendedClass = function () {\n\t                if (!proto.$constructor) {\n\t                    superClass.apply(this, arguments);\n\t                } else {\n\t                    proto.$constructor.apply(this, arguments);\n\t                }\n\t            };\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\n\t            ExtendedClass.extend = this.extend;\n\t            ExtendedClass.superCall = superCall;\n\t            ExtendedClass.superApply = superApply;\n\t            zrUtil.inherits(ExtendedClass, this);\n\t            ExtendedClass.superClass = superClass;\n\t            return ExtendedClass;\n\t        };\n\t    };\n\t    // superCall should have class info, which can not be fetch from 'this'.\n\t    // Consider this case:\n\t    // class A has method f,\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\n\t    // class C inherits class B, do not overrides method f,\n\t    // then when method of class C is called, dead loop occured.\n\t    function superCall(context, methodName) {\n\t        var args = zrUtil.slice(arguments, 2);\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t    function superApply(context, methodName, args) {\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t    /**\n\t     * @param {Object} entity\n\t     * @param {Object} options\n\t     * @param {boolean} [options.registerWhenExtend]\n\t     * @public\n\t     */\n\t    clazz.enableClassManagement = function (entity, options) {\n\t        options = options || {};\n\t        /**\n\t         * Component model classes\n\t         * key: componentType,\n\t         * value:\n\t         *     componentClass, when componentType is 'xxx'\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n\t         * @type {Object}\n\t         */\n\t        var storage = {};\n\t        entity.registerClass = function (Clazz, componentType) {\n\t            if (componentType) {\n\t                componentType = parseClassType(componentType);\n\t                if (!componentType.sub) {\n\t                    if (true) {\n\t                        if (storage[componentType.main]) {\n\t                            console.warn(componentType.main + ' exists.');\n\t                        }\n\t                    }\n\t                    storage[componentType.main] = Clazz;\n\t                } else if (componentType.sub !== IS_CONTAINER) {\n\t                    var container = makeContainer(componentType);\n\t                    container[componentType.sub] = Clazz;\n\t                }\n\t            }\n\t            return Clazz;\n\t        };\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n\t            var Clazz = storage[componentTypeMain];\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\n\t                Clazz = subType ? Clazz[subType] : null;\n\t            }\n\t            if (throwWhenNotFound && !Clazz) {\n\t                throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');\n\t            }\n\t            return Clazz;\n\t        };\n\t        entity.getClassesByMainType = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var result = [];\n\t            var obj = storage[componentType.main];\n\t            if (obj && obj[IS_CONTAINER]) {\n\t                zrUtil.each(obj, function (o, type) {\n\t                    type !== IS_CONTAINER && result.push(o);\n\t                });\n\t            } else {\n\t                result.push(obj);\n\t            }\n\t            return result;\n\t        };\n\t        entity.hasClass = function (componentType) {\n\t            // Just consider componentType.main.\n\t            componentType = parseClassType(componentType);\n\t            return !!storage[componentType.main];\n\t        };\n\t        /**\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n\t         */\n\t        entity.getAllClassMainTypes = function () {\n\t            var types = [];\n\t            zrUtil.each(storage, function (obj, type) {\n\t                types.push(type);\n\t            });\n\t            return types;\n\t        };\n\t        /**\n\t         * If a main type is container and has sub types\n\t         * @param  {string}  mainType\n\t         * @return {boolean}\n\t         */\n\t        entity.hasSubTypes = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var obj = storage[componentType.main];\n\t            return obj && obj[IS_CONTAINER];\n\t        };\n\t        entity.parseClassType = parseClassType;\n\t        function makeContainer(componentType) {\n\t            var container = storage[componentType.main];\n\t            if (!container || !container[IS_CONTAINER]) {\n\t                container = storage[componentType.main] = {};\n\t                container[IS_CONTAINER] = true;\n\t            }\n\t            return container;\n\t        }\n\t        if (options.registerWhenExtend) {\n\t            var originalExtend = entity.extend;\n\t            if (originalExtend) {\n\t                entity.extend = function (proto) {\n\t                    var ExtendedClass = originalExtend.call(this, proto);\n\t                    return entity.registerClass(ExtendedClass, proto.type);\n\t                };\n\t            }\n\t        }\n\t        return entity;\n\t    };\n\t    /**\n\t     * @param {string|Array.<string>} properties\n\t     */\n\t    clazz.setReadOnly = function (obj, properties) {\n\t    };\n\t    return clazz;\n\t});\n\tdefine('zrender/graphic/Displayable', ['require', '../core/util', './Style', '../Element', './mixin/RectText'], function (require) {\n\t    var zrUtil = require('../core/util');\n\t    var Style = require('./Style');\n\t    var Element = require('../Element');\n\t    var RectText = require('./mixin/RectText');\n\t    // var Stateful = require('./mixin/Stateful');\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t        opts = opts || {};\n\t        Element.call(this, opts);\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (opts.hasOwnProperty(name) && name !== 'style') {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];    // FIXME Stateful must be mixined after style is setted\n\t                                  // Stateful.call(this, opts);\n\t    }\n\t    Displayable.prototype = {\n\t        constructor: Displayable,\n\t        type: 'displayable',\n\t        __dirty: true,\n\t        invisible: false,\n\t        z: 0,\n\t        z2: 0,\n\t        zlevel: 0,\n\t        draggable: false,\n\t        dragging: false,\n\t        silent: false,\n\t        culling: false,\n\t        cursor: 'pointer',\n\t        rectHover: false,\n\t        progressive: -1,\n\t        beforeBrush: function (ctx) {\n\t        },\n\t        afterBrush: function (ctx) {\n\t        },\n\t        brush: function (ctx, prevEl) {\n\t        },\n\t        getBoundingRect: function () {\n\t        },\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this._rect = null;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            } else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t    zrUtil.inherits(Displayable, Element);\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t    return Displayable;\n\t});\n\tdefine('zrender/contain/path', ['require', '../core/PathProxy', './line', './cubic', './quadratic', './arc', './util', '../core/curve', './windingLine'], function (require) {\n\t    'use strict';\n\t    var CMD = require('../core/PathProxy').CMD;\n\t    var line = require('./line');\n\t    var cubic = require('./cubic');\n\t    var quadratic = require('./quadratic');\n\t    var arc = require('./arc');\n\t    var normalizeRadian = require('./util').normalizeRadian;\n\t    var curve = require('../core/curve');\n\t    var windingLine = require('./windingLine');\n\t    var containStroke = line.containStroke;\n\t    var PI2 = Math.PI * 2;\n\t    var EPSILON = 0.0001;\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t    // \n\t    var roots = [\n\t            -1,\n\t            -1,\n\t            -1\n\t        ];\n\t    var extrema = [\n\t            -1,\n\t            -1\n\t        ];\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        } else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = t === 0 || t === 1 ? 0.5 : 1;\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) {\n\t                    // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    } else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    } else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                } else {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    } else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        } else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {\n\t                        // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    } else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            } else {\n\t                // Remove one endpoint.\n\t                var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {\n\t                    // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t    // TODO\n\t    // Arc \n\t    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 0.0001) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 0.0001) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        } else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }    //  subpath \n\t                     // if (w !== 0) {\n\t                     //     return true;\n\t                     // }\n\t            }\n\t            if (i == 1) {\n\t                //  L, C, Q\n\t                //  previous point  point\n\t                //\n\t                //  Arc \n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t            switch (cmd) {\n\t            case CMD.M:\n\t                // moveTo  subpath, \n\t                //  closePath \n\t                x0 = data[i++];\n\t                y0 = data[i++];\n\t                xi = x0;\n\t                yi = y0;\n\t                break;\n\t            case CMD.L:\n\t                if (isStroke) {\n\t                    if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // NOTE  L, C, Q  NaN\n\t                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.C:\n\t                if (isStroke) {\n\t                    if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.Q:\n\t                if (isStroke) {\n\t                    if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.A:\n\t                // TODO Arc \n\t                var cx = data[i++];\n\t                var cy = data[i++];\n\t                var rx = data[i++];\n\t                var ry = data[i++];\n\t                var theta = data[i++];\n\t                var dTheta = data[i++];\n\t                // TODO Arc \n\t                var psi = data[i++];\n\t                var anticlockwise = 1 - data[i++];\n\t                var x1 = Math.cos(theta) * rx + cx;\n\t                var y1 = Math.sin(theta) * ry + cy;\n\t                //  arc \n\t                if (i > 1) {\n\t                    w += windingLine(xi, yi, x1, y1, x, y);\n\t                } else {\n\t                    // \n\t                    x0 = x1;\n\t                    y0 = y1;\n\t                }\n\t                // zr scale, x\n\t                var _x = (x - cx) * ry / rx + cx;\n\t                if (isStroke) {\n\t                    if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n\t                }\n\t                xi = Math.cos(theta + dTheta) * rx + cx;\n\t                yi = Math.sin(theta + dTheta) * ry + cy;\n\t                break;\n\t            case CMD.R:\n\t                x0 = xi = data[i++];\n\t                y0 = yi = data[i++];\n\t                var width = data[i++];\n\t                var height = data[i++];\n\t                var x1 = x0 + width;\n\t                var y1 = y0 + height;\n\t                if (isStroke) {\n\t                    if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // FIXME Clockwise ?\n\t                    w += windingLine(x1, y0, x1, y1, x, y);\n\t                    w += windingLine(x0, y1, x0, y0, x, y);\n\t                }\n\t                break;\n\t            case CMD.Z:\n\t                if (isStroke) {\n\t                    if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // Close a subpath\n\t                    w += windingLine(xi, yi, x0, y0, x, y);    //  subpath \n\t                                                               // FIXME subpaths may overlap\n\t                                                               // if (w !== 0) {\n\t                                                               //     return true;\n\t                                                               // }\n\t                }\n\t                xi = x0;\n\t                yi = y0;\n\t                break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t    return {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/model/mixin/lineStyle', ['require', './makeStyleMapper'], function (require) {\n\t    var getLineStyle = require('./makeStyleMapper')([\n\t            [\n\t                'lineWidth',\n\t                'width'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'color'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getLineStyle: function (excludes) {\n\t            var style = getLineStyle.call(this, excludes);\n\t            var lineDash = this.getLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t        getLineDash: function () {\n\t            var lineType = this.get('type');\n\t            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n\t                5,\n\t                5\n\t            ] : [\n\t                2,\n\t                2\n\t            ];\n\t        }\n\t    };\n\t});\n\tdefine('echarts/scale/Ordinal', ['require', 'zrender/core/util', './Scale'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Scale = require('./Scale');\n\t    var scaleProto = Scale.prototype;\n\t    var OrdinalScale = Scale.extend({\n\t            type: 'ordinal',\n\t            init: function (data, extent) {\n\t                this._data = data;\n\t                this._extent = extent || [\n\t                    0,\n\t                    data.length - 1\n\t                ];\n\t            },\n\t            parse: function (val) {\n\t                return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);\n\t            },\n\t            contain: function (rank) {\n\t                rank = this.parse(rank);\n\t                return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n\t            },\n\t            normalize: function (val) {\n\t                return scaleProto.normalize.call(this, this.parse(val));\n\t            },\n\t            scale: function (val) {\n\t                return Math.round(scaleProto.scale.call(this, val));\n\t            },\n\t            getTicks: function () {\n\t                var ticks = [];\n\t                var extent = this._extent;\n\t                var rank = extent[0];\n\t                while (rank <= extent[1]) {\n\t                    ticks.push(rank);\n\t                    rank++;\n\t                }\n\t                return ticks;\n\t            },\n\t            getLabel: function (n) {\n\t                return this._data[n];\n\t            },\n\t            count: function () {\n\t                return this._extent[1] - this._extent[0] + 1;\n\t            },\n\t            niceTicks: zrUtil.noop,\n\t            niceExtent: zrUtil.noop\n\t        });\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    OrdinalScale.create = function () {\n\t        return new OrdinalScale();\n\t    };\n\t    return OrdinalScale;\n\t});\n\tdefine('zrender/graphic/Pattern', ['require'], function (require) {\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t        return this._canvasPattern || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t    return Pattern;\n\t});\n\tdefine('echarts/model/mixin/areaStyle', ['require', './makeStyleMapper'], function (require) {\n\t    return {\n\t        getAreaStyle: require('./makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['opacity'],\n\t            ['shadowColor']\n\t        ])\n\t    };\n\t});\n\tdefine('echarts/model/mixin/textStyle', ['require', 'zrender/contain/text'], function (require) {\n\t    var textContain = require('zrender/contain/text');\n\t    function getShallow(model, path) {\n\t        return model && model.getShallow(path);\n\t    }\n\t    return {\n\t        getTextColor: function () {\n\t            var ecModel = this.ecModel;\n\t            return this.getShallow('color') || ecModel && ecModel.get('textStyle.color');\n\t        },\n\t        getFont: function () {\n\t            var ecModel = this.ecModel;\n\t            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n\t            return [\n\t                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n\t                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n\t                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n\t                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n\t            ].join(' ');\n\t        },\n\t        getTextRect: function (text) {\n\t            var textStyle = this.get('textStyle') || {};\n\t            return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);\n\t        },\n\t        truncateText: function (text, containerWidth, ellipsis, options) {\n\t            return textContain.truncateText(text, containerWidth, this.getFont(), ellipsis, options);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/model/mixin/itemStyle', ['require', './makeStyleMapper'], function (require) {\n\t    var getItemStyle = require('./makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'borderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'borderWidth'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getItemStyle: function (excludes) {\n\t            var style = getItemStyle.call(this, excludes);\n\t            var lineDash = this.getBorderLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t        getBorderLineDash: function () {\n\t            var lineType = this.get('borderType');\n\t            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n\t                5,\n\t                5\n\t            ] : [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/Style', ['require'], function (require) {\n\t    var STYLE_COMMON_PROPS = [\n\t            [\n\t                'shadowBlur',\n\t                0\n\t            ],\n\t            [\n\t                'shadowOffsetX',\n\t                0\n\t            ],\n\t            [\n\t                'shadowOffsetY',\n\t                0\n\t            ],\n\t            [\n\t                'shadowColor',\n\t                '#000'\n\t            ],\n\t            [\n\t                'lineCap',\n\t                'butt'\n\t            ],\n\t            [\n\t                'lineJoin',\n\t                'miter'\n\t            ],\n\t            [\n\t                'miterLimit',\n\t                10\n\t            ]\n\t        ];\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t        return canvasGradient;\n\t    }\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t        return canvasGradient;\n\t    }\n\t    Style.prototype = {\n\t        constructor: Style,\n\t        fill: '#000000',\n\t        stroke: null,\n\t        opacity: 1,\n\t        lineDash: null,\n\t        lineDashOffset: 0,\n\t        shadowBlur: 0,\n\t        shadowOffsetX: 0,\n\t        shadowOffsetY: 0,\n\t        lineWidth: 1,\n\t        strokeNoScale: false,\n\t        text: null,\n\t        textFill: '#000',\n\t        textStroke: null,\n\t        textPosition: 'inside',\n\t        textBaseline: null,\n\t        textAlign: null,\n\t        textVerticalAlign: null,\n\t        textDistance: 5,\n\t        textShadowBlur: 0,\n\t        textShadowOffsetX: 0,\n\t        textShadowOffsetY: 0,\n\t        textTransform: false,\n\t        textRotation: 0,\n\t        blend: null,\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t            if (firstDraw || style.fill !== prevStyle.fill) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if (firstDraw || style.stroke !== prevStyle.stroke) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if (firstDraw || style.opacity !== prevStyle.opacity) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t            if (firstDraw || style.blend !== prevStyle.blend) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n\t            }\n\t        },\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            } else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t    return Style;\n\t});\n\tdefine('zrender/graphic/mixin/RectText', ['require', '../../contain/text', '../../core/BoundingRect'], function (require) {\n\t    var textContain = require('../../contain/text');\n\t    var BoundingRect = require('../../core/BoundingRect');\n\t    var tmpRect = new BoundingRect();\n\t    var RectText = function () {\n\t    };\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t    RectText.prototype = {\n\t        constructor: RectText,\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t            // FIXME\n\t            ctx.save();\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            } else {\n\t                this.setTransform(ctx);\n\t            }\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                    case 'middle':\n\t                        y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= textRect.height - textRect.lineHeight / 2;\n\t                        break;\n\t                    default:\n\t                        y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            } else {\n\t                var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t            var textLines = text.split('\\n');\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t            ctx.restore();\n\t        }\n\t    };\n\t    return RectText;\n\t});\n\tdefine('zrender/Element', ['require', './core/guid', './mixin/Eventful', './mixin/Transformable', './mixin/Animatable', './core/util'], function (require) {\n\t    'use strict';\n\t    var guid = require('./core/guid');\n\t    var Eventful = require('./mixin/Eventful');\n\t    var Transformable = require('./mixin/Transformable');\n\t    var Animatable = require('./mixin/Animatable');\n\t    var zrUtil = require('./core/util');\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t        /**\n\t         * ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t    Element.prototype = {\n\t        type: 'element',\n\t        name: '',\n\t        __zr: null,\n\t        ignore: false,\n\t        clipPath: null,\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t            case 'horizontal':\n\t                dy = 0;\n\t                break;\n\t            case 'vertical':\n\t                dx = 0;\n\t                break;\n\t            }\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [\n\t                    1,\n\t                    0,\n\t                    0,\n\t                    1,\n\t                    0,\n\t                    0\n\t                ];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t        beforeUpdate: function () {\n\t        },\n\t        afterUpdate: function () {\n\t        },\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t        traverse: function (cb, context) {\n\t        },\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            } else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            } else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t            this.dirty(false);\n\t        },\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t                this.dirty(false);\n\t            }\n\t        },\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t    return Element;\n\t});\n\tdefine('echarts/model/mixin/makeStyleMapper', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    return function (properties) {\n\t        // Normalize\n\t        for (var i = 0; i < properties.length; i++) {\n\t            if (!properties[i][1]) {\n\t                properties[i][1] = properties[i][0];\n\t            }\n\t        }\n\t        return function (excludes) {\n\t            var style = {};\n\t            for (var i = 0; i < properties.length; i++) {\n\t                var propName = properties[i][1];\n\t                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n\t                    continue;\n\t                }\n\t                var val = this.getShallow(propName);\n\t                if (val != null) {\n\t                    style[properties[i][0]] = val;\n\t                }\n\t            }\n\t            return style;\n\t        };\n\t    };\n\t});\n\tdefine('echarts/coord/cartesian/Cartesian', ['require', 'zrender/core/util'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    function dimAxisMapper(dim) {\n\t        return this._axes[dim];\n\t    }\n\t    /**\n\t     * @alias module:echarts/coord/Cartesian\n\t     * @constructor\n\t     */\n\t    var Cartesian = function (name) {\n\t        this._axes = {};\n\t        this._dimList = [];\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.name = name || '';\n\t    };\n\t    Cartesian.prototype = {\n\t        constructor: Cartesian,\n\t        type: 'cartesian',\n\t        getAxis: function (dim) {\n\t            return this._axes[dim];\n\t        },\n\t        getAxes: function () {\n\t            return zrUtil.map(this._dimList, dimAxisMapper, this);\n\t        },\n\t        getAxesByScale: function (scaleType) {\n\t            scaleType = scaleType.toLowerCase();\n\t            return zrUtil.filter(this.getAxes(), function (axis) {\n\t                return axis.scale.type === scaleType;\n\t            });\n\t        },\n\t        addAxis: function (axis) {\n\t            var dim = axis.dim;\n\t            this._axes[dim] = axis;\n\t            this._dimList.push(dim);\n\t        },\n\t        dataToCoord: function (val) {\n\t            return this._dataCoordConvert(val, 'dataToCoord');\n\t        },\n\t        coordToData: function (val) {\n\t            return this._dataCoordConvert(val, 'coordToData');\n\t        },\n\t        _dataCoordConvert: function (input, method) {\n\t            var dimList = this._dimList;\n\t            var output = input instanceof Array ? [] : {};\n\t            for (var i = 0; i < dimList.length; i++) {\n\t                var dim = dimList[i];\n\t                var axis = this._axes[dim];\n\t                output[dim] = axis[method](input[dim]);\n\t            }\n\t            return output;\n\t        }\n\t    };\n\t    return Cartesian;\n\t});\n\tdefine('zrender/core/guid', [], function () {\n\t    var idStart = 2311;\n\t    return function () {\n\t        return idStart++;\n\t    };\n\t});\n\tdefine('zrender/mixin/Transformable', ['require', '../core/matrix', '../core/vector'], function (require) {\n\t    'use strict';\n\t    var matrix = require('../core/matrix');\n\t    var vector = require('../core/vector');\n\t    var mIdentity = matrix.identity;\n\t    var EPSILON = 0.00005;\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [\n\t                0,\n\t                0\n\t            ];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t        /**\n\t         * \n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t    /**\n\t     * \n\t     * , position, rotation, scaletransformtransform\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t        m = m || matrix.create();\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        } else {\n\t            mIdentity(m);\n\t        }\n\t        // \n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            } else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // \n\t        this.transform = m;\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t        var origin = this.origin;\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t        return m;\n\t    };\n\t    /**\n\t     * transformcontext\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        } else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    };\n\t    var tmpTransform = [];\n\t    /**\n\t     * `transform``position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [\n\t            sx,\n\t            sy\n\t        ];\n\t    };\n\t    /**\n\t     *  shape \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [\n\t                x,\n\t                y\n\t            ];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t    /**\n\t     * \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [\n\t                x,\n\t                y\n\t            ];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t    return Transformable;\n\t});\n\tdefine('zrender/mixin/Animatable', ['require', '../animation/Animator', '../core/util', '../core/log'], function (require) {\n\t    'use strict';\n\t    var Animator = require('../animation/Animator');\n\t    var util = require('../core/util');\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = require('../core/log');\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t    Animatable.prototype = {\n\t        constructor: Animatable,\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            } else {\n\t                target = el;\n\t            }\n\t            if (!target) {\n\t                log('Property \"' + path + '\" is not existed in element ' + el.id);\n\t                return;\n\t            }\n\t            var animators = el.animators;\n\t            var animator = new Animator(target, loop);\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            }).done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t            animators.push(animator);\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t            return animator;\n\t        },\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t            return this;\n\t        },\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }    // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }    // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }    // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }    // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i].done(done).start(easing);\n\t            }\n\t        },\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n\t                    } else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                } else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    } else {\n\t                        // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n\t            }\n\t            return this;\n\t        }\n\t    };\n\t    return Animatable;\n\t});\n\tdefine('echarts/util/component', ['require', 'zrender/core/util', './clazz'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazz = require('./clazz');\n\t    var parseClassType = clazz.parseClassType;\n\t    var base = 0;\n\t    var componentUtil = {};\n\t    var DELIMITER = '_';\n\t    /**\n\t     * @public\n\t     * @param {string} type\n\t     * @return {string}\n\t     */\n\t    componentUtil.getUID = function (type) {\n\t        // Considering the case of crossing js context,\n\t        // use Math.random to make id as unique as possible.\n\t        return [\n\t            type || '',\n\t            base++,\n\t            Math.random()\n\t        ].join(DELIMITER);\n\t    };\n\t    /**\n\t     * @inner\n\t     */\n\t    componentUtil.enableSubTypeDefaulter = function (entity) {\n\t        var subTypeDefaulters = {};\n\t        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n\t            componentType = parseClassType(componentType);\n\t            subTypeDefaulters[componentType.main] = defaulter;\n\t        };\n\t        entity.determineSubType = function (componentType, option) {\n\t            var type = option.type;\n\t            if (!type) {\n\t                var componentTypeMain = parseClassType(componentType).main;\n\t                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n\t                    type = subTypeDefaulters[componentTypeMain](option);\n\t                }\n\t            }\n\t            return type;\n\t        };\n\t        return entity;\n\t    };\n\t    /**\n\t     * Topological travel on Activity Network (Activity On Vertices).\n\t     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n\t     *\n\t     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n\t     *\n\t     * If there is circle dependencey, Error will be thrown.\n\t     *\n\t     */\n\t    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\t        /**\n\t         * @public\n\t         * @param {Array.<string>} targetNameList Target Component type list.\n\t         *                                           Can be ['aa', 'bb', 'aa.xx']\n\t         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n\t         * @param {Function} callback Params: componentType, dependencies.\n\t         * @param {Object} context Scope of callback.\n\t         */\n\t        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n\t            if (!targetNameList.length) {\n\t                return;\n\t            }\n\t            var result = makeDepndencyGraph(fullNameList);\n\t            var graph = result.graph;\n\t            var stack = result.noEntryList;\n\t            var targetNameSet = {};\n\t            zrUtil.each(targetNameList, function (name) {\n\t                targetNameSet[name] = true;\n\t            });\n\t            while (stack.length) {\n\t                var currComponentType = stack.pop();\n\t                var currVertex = graph[currComponentType];\n\t                var isInTargetNameSet = !!targetNameSet[currComponentType];\n\t                if (isInTargetNameSet) {\n\t                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n\t                    delete targetNameSet[currComponentType];\n\t                }\n\t                zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n\t            }\n\t            zrUtil.each(targetNameSet, function () {\n\t                throw new Error('Circle dependency may exists');\n\t            });\n\t            function removeEdge(succComponentType) {\n\t                graph[succComponentType].entryCount--;\n\t                if (graph[succComponentType].entryCount === 0) {\n\t                    stack.push(succComponentType);\n\t                }\n\t            }\n\t            // Consider this case: legend depends on series, and we call\n\t            // chart.setOption({series: [...]}), where only series is in option.\n\t            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n\t            // not be called, but only sereis.mergeOption is called. Thus legend\n\t            // have no chance to update its local record about series (like which\n\t            // name of series is available in legend).\n\t            function removeEdgeAndAdd(succComponentType) {\n\t                targetNameSet[succComponentType] = true;\n\t                removeEdge(succComponentType);\n\t            }\n\t        };\n\t        /**\n\t         * DepndencyGraph: {Object}\n\t         * key: conponentType,\n\t         * value: {\n\t         *     successor: [conponentTypes...],\n\t         *     originalDeps: [conponentTypes...],\n\t         *     entryCount: {number}\n\t         * }\n\t         */\n\t        function makeDepndencyGraph(fullNameList) {\n\t            var graph = {};\n\t            var noEntryList = [];\n\t            zrUtil.each(fullNameList, function (name) {\n\t                var thisItem = createDependencyGraphItem(graph, name);\n\t                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\t                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n\t                thisItem.entryCount = availableDeps.length;\n\t                if (thisItem.entryCount === 0) {\n\t                    noEntryList.push(name);\n\t                }\n\t                zrUtil.each(availableDeps, function (dependentName) {\n\t                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n\t                        thisItem.predecessor.push(dependentName);\n\t                    }\n\t                    var thatItem = createDependencyGraphItem(graph, dependentName);\n\t                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n\t                        thatItem.successor.push(name);\n\t                    }\n\t                });\n\t            });\n\t            return {\n\t                graph: graph,\n\t                noEntryList: noEntryList\n\t            };\n\t        }\n\t        function createDependencyGraphItem(graph, name) {\n\t            if (!graph[name]) {\n\t                graph[name] = {\n\t                    predecessor: [],\n\t                    successor: []\n\t                };\n\t            }\n\t            return graph[name];\n\t        }\n\t        function getAvailableDependencies(originalDeps, fullNameList) {\n\t            var availableDeps = [];\n\t            zrUtil.each(originalDeps, function (dep) {\n\t                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n\t            });\n\t            return availableDeps;\n\t        }\n\t    };\n\t    return componentUtil;\n\t});\n\tdefine('echarts/model/mixin/boxLayout', ['require'], function (require) {\n\t    return {\n\t        getBoxLayoutParams: function () {\n\t            return {\n\t                left: this.get('left'),\n\t                top: this.get('top'),\n\t                right: this.get('right'),\n\t                bottom: this.get('bottom'),\n\t                width: this.get('width'),\n\t                height: this.get('height')\n\t            };\n\t        }\n\t    };\n\t});\n\tdefine('echarts/coord/Axis', ['require', '../util/number', 'zrender/core/util'], function (require) {\n\t    var numberUtil = require('../util/number');\n\t    var linearMap = numberUtil.linearMap;\n\t    var zrUtil = require('zrender/core/util');\n\t    function fixExtentWithBands(extent, nTick) {\n\t        var size = extent[1] - extent[0];\n\t        var len = nTick;\n\t        var margin = size / len / 2;\n\t        extent[0] += margin;\n\t        extent[1] -= margin;\n\t    }\n\t    var normalizedExtent = [\n\t            0,\n\t            1\n\t        ];\n\t    /**\n\t     * @name module:echarts/coord/CartesianAxis\n\t     * @constructor\n\t     */\n\t    var Axis = function (dim, scale, extent) {\n\t        /**\n\t         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n\t         * @type {string}\n\t         */\n\t        this.dim = dim;\n\t        /**\n\t         * Axis scale\n\t         * @type {module:echarts/coord/scale/*}\n\t         */\n\t        this.scale = scale;\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        this._extent = extent || [\n\t            0,\n\t            0\n\t        ];\n\t        /**\n\t         * @type {boolean}\n\t         */\n\t        this.inverse = false;\n\t        /**\n\t         * Usually true when axis has a ordinal scale\n\t         * @type {boolean}\n\t         */\n\t        this.onBand = false;\n\t    };\n\t    Axis.prototype = {\n\t        constructor: Axis,\n\t        contain: function (coord) {\n\t            var extent = this._extent;\n\t            var min = Math.min(extent[0], extent[1]);\n\t            var max = Math.max(extent[0], extent[1]);\n\t            return coord >= min && coord <= max;\n\t        },\n\t        containData: function (data) {\n\t            return this.contain(this.dataToCoord(data));\n\t        },\n\t        getExtent: function () {\n\t            var ret = this._extent.slice();\n\t            return ret;\n\t        },\n\t        getPixelPrecision: function (dataExtent) {\n\t            return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n\t        },\n\t        setExtent: function (start, end) {\n\t            var extent = this._extent;\n\t            extent[0] = start;\n\t            extent[1] = end;\n\t        },\n\t        dataToCoord: function (data, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            data = scale.normalize(data);\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t            return linearMap(data, normalizedExtent, extent, clamp);\n\t        },\n\t        coordToData: function (coord, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\t            return this.scale.scale(t);\n\t        },\n\t        getTicksCoords: function (alignWithLabel) {\n\t            if (this.onBand && !alignWithLabel) {\n\t                var bands = this.getBands();\n\t                var coords = [];\n\t                for (var i = 0; i < bands.length; i++) {\n\t                    coords.push(bands[i][0]);\n\t                }\n\t                if (bands[i - 1]) {\n\t                    coords.push(bands[i - 1][1]);\n\t                }\n\t                return coords;\n\t            } else {\n\t                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t            }\n\t        },\n\t        getLabelsCoords: function () {\n\t            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t        },\n\t        getBands: function () {\n\t            var extent = this.getExtent();\n\t            var bands = [];\n\t            var len = this.scale.count();\n\t            var start = extent[0];\n\t            var end = extent[1];\n\t            var span = end - start;\n\t            for (var i = 0; i < len; i++) {\n\t                bands.push([\n\t                    span * i / len + start,\n\t                    span * (i + 1) / len + start\n\t                ]);\n\t            }\n\t            return bands;\n\t        },\n\t        getBandWidth: function () {\n\t            var axisExtent = this._extent;\n\t            var dataExtent = this.scale.getExtent();\n\t            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n\t            // Fix #2728, avoid NaN when only one data.\n\t            len === 0 && (len = 1);\n\t            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\t            return Math.abs(size) / len;\n\t        }\n\t    };\n\t    return Axis;\n\t});\n\tdefine('echarts/coord/cartesian/axisLabelInterval', ['require', 'zrender/core/util', '../axisHelper'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisHelper = require('../axisHelper');\n\t    return function (axis) {\n\t        var axisModel = axis.model;\n\t        var labelModel = axisModel.getModel('axisLabel');\n\t        var labelInterval = labelModel.get('interval');\n\t        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n\t            return labelInterval === 'auto' ? 0 : labelInterval;\n\t        }\n\t        return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());\n\t    };\n\t});\n\tdefine('zrender/core/log', ['require', '../config'], function (require) {\n\t    var config = require('../config');\n\t    /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t         */\n\t    return function () {\n\t        if (config.debugMode === 0) {\n\t            return;\n\t        } else if (config.debugMode == 1) {\n\t            for (var k in arguments) {\n\t                throw new Error(arguments[k]);\n\t            }\n\t        } else if (config.debugMode > 1) {\n\t            for (var k in arguments) {\n\t                console.log(arguments[k]);\n\t            }\n\t        }\n\t    };    /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>' \n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t});\n\tdefine('zrender/animation/Animator', ['require', './Clip', '../tool/color', '../core/util'], function (require) {\n\t    var Clip = require('./Clip');\n\t    var color = require('../tool/color');\n\t    var util = require('../core/util');\n\t    var isArrayLike = util.isArrayLike;\n\t    var arraySlice = Array.prototype.slice;\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        } else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            } else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            } else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        } else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n\t            }\n\t        } else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t    }\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t            return arraySlice.call(value);\n\t        }\n\t        return value;\n\t    }\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t        // For vertices morphing\n\t        var arrDim = isValueArray && isArrayLike(firstVal[0]) ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function (a, b) {\n\t            return a.time - b.time;\n\t        });\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t            // Check if value is equal, deep check if value is array\n\t            if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                } else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            } else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t        if (isValueColor) {\n\t            var rgba = [\n\t                    0,\n\t                    0,\n\t                    0,\n\t                    0\n\t                ];\n\t        }\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            } else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            } else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t            var range = kfPercents[frame + 1] - kfPercents[frame];\n\t            if (range === 0) {\n\t                return;\n\t            } else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n\t                } else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n\t                        value = rgba2String(rgba);\n\t                    } else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    } else {\n\t                        value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n\t                    }\n\t                    setter(target, propName, value);\n\t                }\n\t            } else {\n\t                if (isValueArray) {\n\t                    interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n\t                } else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n\t                        value = rgba2String(rgba);\n\t                    } else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    } else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(target, propName, value);\n\t                }\n\t            }\n\t        };\n\t        var clip = new Clip({\n\t                target: animator._target,\n\t                life: trackMaxTime,\n\t                loop: animator._loop,\n\t                delay: animator._delay,\n\t                onframe: onframe,\n\t                ondestroy: oneTrackDone\n\t            });\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t        return clip;\n\t    }\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function (target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t        this._loop = loop || false;\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t        this._clipCount = 0;\n\t        this._delay = 0;\n\t        this._doneList = [];\n\t        this._onframeList = [];\n\t        this._clipList = [];\n\t    };\n\t    Animator.prototype = {\n\t        when: function (time, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        start: function (easing) {\n\t            var self = this;\n\t            var clipCount = 0;\n\t            var oneTrackDone = function () {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        done: function (cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t    return Animator;\n\t});\n\tdefine('echarts/coord/cartesian/AxisModel', ['require', '../../model/Component', 'zrender/core/util', '../axisModelCreator', '../axisModelCommonMixin'], function (require) {\n\t    'use strict';\n\t    var ComponentModel = require('../../model/Component');\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisModelCreator = require('../axisModelCreator');\n\t    var AxisModel = ComponentModel.extend({\n\t            type: 'cartesian2dAxis',\n\t            axis: null,\n\t            init: function () {\n\t                AxisModel.superApply(this, 'init', arguments);\n\t                this._resetRange();\n\t            },\n\t            mergeOption: function () {\n\t                AxisModel.superApply(this, 'mergeOption', arguments);\n\t                this._resetRange();\n\t            },\n\t            restoreData: function () {\n\t                AxisModel.superApply(this, 'restoreData', arguments);\n\t                this._resetRange();\n\t            },\n\t            setRange: function (rangeStart, rangeEnd) {\n\t                this.option.rangeStart = rangeStart;\n\t                this.option.rangeEnd = rangeEnd;\n\t            },\n\t            getMin: function () {\n\t                var option = this.option;\n\t                return option.rangeStart != null ? option.rangeStart : option.min;\n\t            },\n\t            getMax: function () {\n\t                var option = this.option;\n\t                return option.rangeEnd != null ? option.rangeEnd : option.max;\n\t            },\n\t            getNeedCrossZero: function () {\n\t                var option = this.option;\n\t                return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n\t            },\n\t            findGridModel: function () {\n\t                return this.ecModel.queryComponents({\n\t                    mainType: 'grid',\n\t                    index: this.get('gridIndex'),\n\t                    id: this.get('gridId')\n\t                })[0];\n\t            },\n\t            _resetRange: function () {\n\t                // rangeStart and rangeEnd is readonly.\n\t                this.option.rangeStart = this.option.rangeEnd = null;\n\t            }\n\t        });\n\t    function getAxisType(axisDim, option) {\n\t        // Default axis with data is category axis\n\t        return option.type || (option.data ? 'category' : 'value');\n\t    }\n\t    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n\t    var extraOption = { offset: 0 };\n\t    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n\t    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\t    return AxisModel;\n\t});\n\tdefine('zrender/animation/Clip', ['require', './easing'], function (require) {\n\t    var easingFuncs = require('./easing');\n\t    function Clip(options) {\n\t        this._target = options.target;\n\t        // \n\t        this._life = options.life || 1000;\n\t        // \n\t        this._delay = options.delay || 0;\n\t        // \n\t        // this._startTime = new Date().getTime() + this._delay;// \n\t        this._initialized = false;\n\t        // \n\t        this.loop = options.loop == null ? false : options.loop;\n\t        this.gap = options.gap || 0;\n\t        this.easing = options.easing || 'Linear';\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t    Clip.prototype = {\n\t        constructor: Clip,\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t            // \n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t            percent = Math.min(percent, 1);\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n\t            this.fire('frame', schedule);\n\t            // \n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart(globalTime);\n\t                    // \n\t                    //  stage.update \n\t                    return 'restart';\n\t                }\n\t                // \n\t                // Animation.update\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t            return null;\n\t        },\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t            this._needsRemove = false;\n\t        },\n\t        fire: function (eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t    return Clip;\n\t});\n\tdefine('echarts/coord/axisModelCreator', ['require', './axisDefault', 'zrender/core/util', '../model/Component', '../util/layout'], function (require) {\n\t    var axisDefault = require('./axisDefault');\n\t    var zrUtil = require('zrender/core/util');\n\t    var ComponentModel = require('../model/Component');\n\t    var layout = require('../util/layout');\n\t    // FIXME axisType is fixed ?\n\t    var AXIS_TYPES = [\n\t            'value',\n\t            'category',\n\t            'time',\n\t            'log'\n\t        ];\n\t    /**\n\t     * Generate sub axis model class\n\t     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n\t     * @param {module:echarts/model/Component} BaseAxisModelClass\n\t     * @param {Function} axisTypeDefaulter\n\t     * @param {Object} [extraDefaultOption]\n\t     */\n\t    return function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\t        zrUtil.each(AXIS_TYPES, function (axisType) {\n\t            BaseAxisModelClass.extend({\n\t                type: axisName + 'Axis.' + axisType,\n\t                mergeDefaultAndTheme: function (option, ecModel) {\n\t                    var layoutMode = this.layoutMode;\n\t                    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n\t                    var themeModel = ecModel.getTheme();\n\t                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n\t                    zrUtil.merge(option, this.getDefaultOption());\n\t                    option.type = axisTypeDefaulter(axisName, option);\n\t                    if (layoutMode) {\n\t                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                    }\n\t                },\n\t                defaultOption: zrUtil.mergeAll([\n\t                    {},\n\t                    axisDefault[axisType + 'Axis'],\n\t                    extraDefaultOption\n\t                ], true)\n\t            });\n\t        });\n\t        ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n\t    };\n\t});\n\tdefine('echarts/coord/axisModelCommonMixin', ['require', 'zrender/core/util', './axisHelper'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisHelper = require('./axisHelper');\n\t    function getName(obj) {\n\t        if (zrUtil.isObject(obj) && obj.value != null) {\n\t            return obj.value;\n\t        } else {\n\t            return obj;\n\t        }\n\t    }\n\t    /**\n\t     * Get categories\n\t     */\n\t    function getCategories() {\n\t        return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n\t    }\n\t    /**\n\t     * Format labels\n\t     * @return {Array.<string>}\n\t     */\n\t    function getFormattedLabels() {\n\t        return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n\t    }\n\t    return {\n\t        getFormattedLabels: getFormattedLabels,\n\t        getCategories: getCategories\n\t    };\n\t});\n\tdefine('zrender/animation/easing', [], function () {\n\t    var easing = {\n\t            linear: function (k) {\n\t                return k;\n\t            },\n\t            quadraticIn: function (k) {\n\t                return k * k;\n\t            },\n\t            quadraticOut: function (k) {\n\t                return k * (2 - k);\n\t            },\n\t            quadraticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k;\n\t                }\n\t                return -0.5 * (--k * (k - 2) - 1);\n\t            },\n\t            cubicIn: function (k) {\n\t                return k * k * k;\n\t            },\n\t            cubicOut: function (k) {\n\t                return --k * k * k + 1;\n\t            },\n\t            cubicInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k;\n\t                }\n\t                return 0.5 * ((k -= 2) * k * k + 2);\n\t            },\n\t            quarticIn: function (k) {\n\t                return k * k * k * k;\n\t            },\n\t            quarticOut: function (k) {\n\t                return 1 - --k * k * k * k;\n\t            },\n\t            quarticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k * k;\n\t                }\n\t                return -0.5 * ((k -= 2) * k * k * k - 2);\n\t            },\n\t            quinticIn: function (k) {\n\t                return k * k * k * k * k;\n\t            },\n\t            quinticOut: function (k) {\n\t                return --k * k * k * k * k + 1;\n\t            },\n\t            quinticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k * k * k;\n\t                }\n\t                return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t            },\n\t            sinusoidalIn: function (k) {\n\t                return 1 - Math.cos(k * Math.PI / 2);\n\t            },\n\t            sinusoidalOut: function (k) {\n\t                return Math.sin(k * Math.PI / 2);\n\t            },\n\t            sinusoidalInOut: function (k) {\n\t                return 0.5 * (1 - Math.cos(Math.PI * k));\n\t            },\n\t            exponentialIn: function (k) {\n\t                return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t            },\n\t            exponentialOut: function (k) {\n\t                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t            },\n\t            exponentialInOut: function (k) {\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * Math.pow(1024, k - 1);\n\t                }\n\t                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t            },\n\t            circularIn: function (k) {\n\t                return 1 - Math.sqrt(1 - k * k);\n\t            },\n\t            circularOut: function (k) {\n\t                return Math.sqrt(1 - --k * k);\n\t            },\n\t            circularInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t                }\n\t                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t            },\n\t            elasticIn: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            },\n\t            elasticOut: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t            },\n\t            elasticInOut: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                if ((k *= 2) < 1) {\n\t                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t                }\n\t                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t            },\n\t            backIn: function (k) {\n\t                var s = 1.70158;\n\t                return k * k * ((s + 1) * k - s);\n\t            },\n\t            backOut: function (k) {\n\t                var s = 1.70158;\n\t                return --k * k * ((s + 1) * k + s) + 1;\n\t            },\n\t            backInOut: function (k) {\n\t                var s = 1.70158 * 1.525;\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * (k * k * ((s + 1) * k - s));\n\t                }\n\t                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t            },\n\t            bounceIn: function (k) {\n\t                return 1 - easing.bounceOut(1 - k);\n\t            },\n\t            bounceOut: function (k) {\n\t                if (k < 1 / 2.75) {\n\t                    return 7.5625 * k * k;\n\t                } else if (k < 2 / 2.75) {\n\t                    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t                } else if (k < 2.5 / 2.75) {\n\t                    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t                } else {\n\t                    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t                }\n\t            },\n\t            bounceInOut: function (k) {\n\t                if (k < 0.5) {\n\t                    return easing.bounceIn(k * 2) * 0.5;\n\t                }\n\t                return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t            }\n\t        };\n\t    return easing;\n\t});\n\tdefine('echarts/coord/axisDefault', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var defaultOption = {\n\t            show: true,\n\t            zlevel: 0,\n\t            z: 0,\n\t            inverse: false,\n\t            name: '',\n\t            nameLocation: 'end',\n\t            nameRotate: null,\n\t            nameTruncate: {\n\t                maxWidth: null,\n\t                ellipsis: '...',\n\t                placeholder: '.'\n\t            },\n\t            nameTextStyle: {},\n\t            nameGap: 15,\n\t            silent: false,\n\t            triggerEvent: false,\n\t            tooltip: { show: false },\n\t            axisLine: {\n\t                show: true,\n\t                onZero: true,\n\t                lineStyle: {\n\t                    color: '#333',\n\t                    width: 1,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            axisTick: {\n\t                show: true,\n\t                inside: false,\n\t                length: 5,\n\t                lineStyle: { width: 1 }\n\t            },\n\t            axisLabel: {\n\t                show: true,\n\t                inside: false,\n\t                rotate: 0,\n\t                margin: 8,\n\t                textStyle: { fontSize: 12 }\n\t            },\n\t            splitLine: {\n\t                show: true,\n\t                lineStyle: {\n\t                    color: ['#ccc'],\n\t                    width: 1,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            splitArea: {\n\t                show: false,\n\t                areaStyle: {\n\t                    color: [\n\t                        'rgba(250,250,250,0.3)',\n\t                        'rgba(200,200,200,0.3)'\n\t                    ]\n\t                }\n\t            }\n\t        };\n\t    var categoryAxis = zrUtil.merge({\n\t            boundaryGap: true,\n\t            splitLine: { show: false },\n\t            axisTick: {\n\t                alignWithLabel: false,\n\t                interval: 'auto'\n\t            },\n\t            axisLabel: { interval: 'auto' }\n\t        }, defaultOption);\n\t    var valueAxis = zrUtil.merge({\n\t            boundaryGap: [\n\t                0,\n\t                0\n\t            ],\n\t            splitNumber: 5\n\t        }, defaultOption);\n\t    // FIXME\n\t    var timeAxis = zrUtil.defaults({\n\t            scale: true,\n\t            min: 'dataMin',\n\t            max: 'dataMax'\n\t        }, valueAxis);\n\t    var logAxis = zrUtil.defaults({ logBase: 10 }, valueAxis);\n\t    logAxis.scale = true;\n\t    return {\n\t        categoryAxis: categoryAxis,\n\t        valueAxis: valueAxis,\n\t        timeAxis: timeAxis,\n\t        logAxis: logAxis\n\t    };\n\t});\n\tdefine('zrender/config', [], function () {\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t            debugMode: 0,\n\t            devicePixelRatio: dpr\n\t        };\n\t    return config;\n\t});\n\tdefine('echarts/chart/helper/createListFromArray', ['require', '../../data/List', '../../data/helper/completeDimensions', 'zrender/core/util', '../../util/model', '../../CoordinateSystem'], function (require) {\n\t    'use strict';\n\t    var List = require('../../data/List');\n\t    var completeDimensions = require('../../data/helper/completeDimensions');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../../util/model');\n\t    var CoordinateSystem = require('../../CoordinateSystem');\n\t    var getDataItemValue = modelUtil.getDataItemValue;\n\t    var converDataValue = modelUtil.converDataValue;\n\t    function firstDataNotNull(data) {\n\t        var i = 0;\n\t        while (i < data.length && data[i] == null) {\n\t            i++;\n\t        }\n\t        return data[i];\n\t    }\n\t    function ifNeedCompleteOrdinalData(data) {\n\t        var sampleItem = firstDataNotNull(data);\n\t        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n\t    }\n\t    /**\n\t     * Helper function to create a list from option data\n\t     */\n\t    function createListFromArray(data, seriesModel, ecModel) {\n\t        // If data is undefined\n\t        data = data || [];\n\t        if (true) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t        var coordSysName = seriesModel.get('coordinateSystem');\n\t        var creator = creators[coordSysName];\n\t        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n\t        // FIXME\n\t        var axesInfo = creator && creator(data, seriesModel, ecModel);\n\t        var dimensions = axesInfo && axesInfo.dimensions;\n\t        if (!dimensions) {\n\t            // Get dimensions from registered coordinate system\n\t            dimensions = registeredCoordSys && registeredCoordSys.dimensions || [\n\t                'x',\n\t                'y'\n\t            ];\n\t            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n\t        }\n\t        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\t        var list = new List(dimensions, seriesModel);\n\t        var nameList = createNameList(axesInfo, data);\n\t        var categories = {};\n\t        var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t                // Use dataIndex as ordinal value in categoryAxis\n\t                return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n\t            } : function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                var value = getDataItemValue(itemOpt);\n\t                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\t                if (categoryAxesModels && categoryAxesModels[dimName]) {\n\t                    // If given value is a category string\n\t                    if (typeof val === 'string') {\n\t                        // Lazy get categories\n\t                        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n\t                        val = zrUtil.indexOf(categories[dimName], val);\n\t                        if (val < 0 && !isNaN(val)) {\n\t                            // In case some one write '1', '2' istead of 1, 2\n\t                            val = +val;\n\t                        }\n\t                    }\n\t                }\n\t                return val;\n\t            };\n\t        list.hasItemOption = false;\n\t        list.initData(data, nameList, dimValueGetter);\n\t        return list;\n\t    }\n\t    function isStackable(axisType) {\n\t        return axisType !== 'category' && axisType !== 'time';\n\t    }\n\t    function getDimTypeByAxis(axisType) {\n\t        return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n\t    }\n\t    /**\n\t     * Creaters for each coord system.\n\t     */\n\t    var creators = {\n\t            cartesian2d: function (data, seriesModel, ecModel) {\n\t                var axesModels = zrUtil.map([\n\t                        'xAxis',\n\t                        'yAxis'\n\t                    ], function (name) {\n\t                        return ecModel.queryComponents({\n\t                            mainType: name,\n\t                            index: seriesModel.get(name + 'Index'),\n\t                            id: seriesModel.get(name + 'Id')\n\t                        })[0];\n\t                    });\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t                if (true) {\n\t                    if (!xAxisModel) {\n\t                        throw new Error('xAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n\t                    }\n\t                    if (!yAxisModel) {\n\t                        throw new Error('yAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n\t                    }\n\t                }\n\t                var xAxisType = xAxisModel.get('type');\n\t                var yAxisType = yAxisModel.get('type');\n\t                var dimensions = [\n\t                        {\n\t                            name: 'x',\n\t                            type: getDimTypeByAxis(xAxisType),\n\t                            stackable: isStackable(xAxisType)\n\t                        },\n\t                        {\n\t                            name: 'y',\n\t                            type: getDimTypeByAxis(yAxisType),\n\t                            stackable: isStackable(yAxisType)\n\t                        }\n\t                    ];\n\t                var isXAxisCateogry = xAxisType === 'category';\n\t                var isYAxisCategory = yAxisType === 'category';\n\t                completeDimensions(dimensions, data, [\n\t                    'x',\n\t                    'y',\n\t                    'z'\n\t                ]);\n\t                var categoryAxesModels = {};\n\t                if (isXAxisCateogry) {\n\t                    categoryAxesModels.x = xAxisModel;\n\t                }\n\t                if (isYAxisCategory) {\n\t                    categoryAxesModels.y = yAxisModel;\n\t                }\n\t                return {\n\t                    dimensions: dimensions,\n\t                    categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n\t                    categoryAxesModels: categoryAxesModels\n\t                };\n\t            },\n\t            polar: function (data, seriesModel, ecModel) {\n\t                var polarModel = ecModel.queryComponents({\n\t                        mainType: 'polar',\n\t                        index: seriesModel.get('polarIndex'),\n\t                        id: seriesModel.get('polarId')\n\t                    })[0];\n\t                var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\t                var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\t                if (true) {\n\t                    if (!angleAxisModel) {\n\t                        throw new Error('angleAxis option not found');\n\t                    }\n\t                    if (!radiusAxisModel) {\n\t                        throw new Error('radiusAxis option not found');\n\t                    }\n\t                }\n\t                var radiusAxisType = radiusAxisModel.get('type');\n\t                var angleAxisType = angleAxisModel.get('type');\n\t                var dimensions = [\n\t                        {\n\t                            name: 'radius',\n\t                            type: getDimTypeByAxis(radiusAxisType),\n\t                            stackable: isStackable(radiusAxisType)\n\t                        },\n\t                        {\n\t                            name: 'angle',\n\t                            type: getDimTypeByAxis(angleAxisType),\n\t                            stackable: isStackable(angleAxisType)\n\t                        }\n\t                    ];\n\t                var isAngleAxisCateogry = angleAxisType === 'category';\n\t                var isRadiusAxisCateogry = radiusAxisType === 'category';\n\t                completeDimensions(dimensions, data, [\n\t                    'radius',\n\t                    'angle',\n\t                    'value'\n\t                ]);\n\t                var categoryAxesModels = {};\n\t                if (isRadiusAxisCateogry) {\n\t                    categoryAxesModels.radius = radiusAxisModel;\n\t                }\n\t                if (isAngleAxisCateogry) {\n\t                    categoryAxesModels.angle = angleAxisModel;\n\t                }\n\t                return {\n\t                    dimensions: dimensions,\n\t                    categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n\t                    categoryAxesModels: categoryAxesModels\n\t                };\n\t            },\n\t            geo: function (data, seriesModel, ecModel) {\n\t                // TODO Region\n\t                // \n\t                return {\n\t                    dimensions: completeDimensions([\n\t                        { name: 'lng' },\n\t                        { name: 'lat' }\n\t                    ], data, [\n\t                        'lng',\n\t                        'lat',\n\t                        'value'\n\t                    ])\n\t                };\n\t            }\n\t        };\n\t    function createNameList(result, data) {\n\t        var nameList = [];\n\t        var categoryDim = result && result.dimensions[result.categoryIndex];\n\t        var categoryAxisModel;\n\t        if (categoryDim) {\n\t            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n\t        }\n\t        if (categoryAxisModel) {\n\t            // FIXME Two category axis\n\t            var categories = categoryAxisModel.getCategories();\n\t            if (categories) {\n\t                var dataLen = data.length;\n\t                // Ordered data is given explicitly like\n\t                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n\t                // or given scatter data,\n\t                // pick the category\n\t                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n\t                    nameList = [];\n\t                    for (var i = 0; i < dataLen; i++) {\n\t                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n\t                    }\n\t                } else {\n\t                    nameList = categories.slice(0);\n\t                }\n\t            }\n\t        }\n\t        return nameList;\n\t    }\n\t    return createListFromArray;\n\t});\n\tdefine('zrender/core/curve', ['require', './vector'], function (require) {\n\t    'use strict';\n\t    var vec2 = require('./vector');\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 0.0001;\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t    // \n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1 - p0);\n\t        var d = p0 - val;\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t        var n = 0;\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            } else {\n\t                var t1 = -c / b;\n\t                //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = B * B - 4 * A * C;\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;\n\t                // t1, a is not zero\n\t                var t2 = -K / 2;\n\t                // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                } else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                } else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            } else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} \n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] \n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t            d1 = v2DistSquare(_v1, _v0);\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            } else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                } else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        } else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out \n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            } else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                } else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t    return {\n\t        cubicAt: cubicAt,\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t        cubicRootAt: cubicRootAt,\n\t        cubicExtrema: cubicExtrema,\n\t        cubicSubdivide: cubicSubdivide,\n\t        cubicProjectPoint: cubicProjectPoint,\n\t        quadraticAt: quadraticAt,\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t        quadraticRootAt: quadraticRootAt,\n\t        quadraticExtremum: quadraticExtremum,\n\t        quadraticSubdivide: quadraticSubdivide,\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\t});\n\tdefine('zrender/core/bbox', ['require', './vector', './curve'], function (require) {\n\t    var vec2 = require('./vector');\n\t    var curve = require('./curve');\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * `min``max`\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points \n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function (points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * (p0, p1, p2, p3)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t    /**\n\t     * (p0, p1, p2)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function (x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n\t        var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t    /**\n\t     * `min``max`\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff % PI2 < 0.0001 && diff > 0.0001) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % PI2;\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % PI2;\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        } else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t    return bbox;\n\t});\n\tdefine('echarts/data/DataDiffer', ['require'], function (require) {\n\t    'use strict';\n\t    function defaultKeyGetter(item) {\n\t        return item;\n\t    }\n\t    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n\t        this._old = oldArr;\n\t        this._new = newArr;\n\t        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n\t        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\t    }\n\t    DataDiffer.prototype = {\n\t        constructor: DataDiffer,\n\t        add: function (func) {\n\t            this._add = func;\n\t            return this;\n\t        },\n\t        update: function (func) {\n\t            this._update = func;\n\t            return this;\n\t        },\n\t        remove: function (func) {\n\t            this._remove = func;\n\t            return this;\n\t        },\n\t        execute: function () {\n\t            var oldArr = this._old;\n\t            var newArr = this._new;\n\t            var oldKeyGetter = this._oldKeyGetter;\n\t            var newKeyGetter = this._newKeyGetter;\n\t            var oldDataIndexMap = {};\n\t            var newDataIndexMap = {};\n\t            var oldDataKeyArr = [];\n\t            var newDataKeyArr = [];\n\t            var i;\n\t            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n\t            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\t            // Travel by inverted order to make sure order consistency\n\t            // when duplicate keys exists (consider newDataIndex.pop() below).\n\t            // For performance consideration, these code below do not look neat.\n\t            for (i = 0; i < oldArr.length; i++) {\n\t                var key = oldDataKeyArr[i];\n\t                var idx = newDataIndexMap[key];\n\t                // idx can never be empty array here. see 'set null' logic below.\n\t                if (idx != null) {\n\t                    // Consider there is duplicate key (for example, use dataItem.name as key).\n\t                    // We should make sure every item in newArr and oldArr can be visited.\n\t                    var len = idx.length;\n\t                    if (len) {\n\t                        len === 1 && (newDataIndexMap[key] = null);\n\t                        idx = idx.unshift();\n\t                    } else {\n\t                        newDataIndexMap[key] = null;\n\t                    }\n\t                    this._update && this._update(idx, i);\n\t                } else {\n\t                    this._remove && this._remove(i);\n\t                }\n\t            }\n\t            for (var i = 0; i < newDataKeyArr.length; i++) {\n\t                var key = newDataKeyArr[i];\n\t                if (newDataIndexMap.hasOwnProperty(key)) {\n\t                    var idx = newDataIndexMap[key];\n\t                    if (idx == null) {\n\t                        continue;\n\t                    }\n\t                    // idx can never be empty array here. see 'set null' logic above.\n\t                    if (!idx.length) {\n\t                        this._add && this._add(idx);\n\t                    } else {\n\t                        for (var j = 0, len = idx.length; j < len; j++) {\n\t                            this._add && this._add(idx[j]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    function initIndexMap(arr, map, keyArr, keyGetter) {\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var key = keyGetter(arr[i], i);\n\t            var existence = map[key];\n\t            if (existence == null) {\n\t                keyArr.push(key);\n\t                map[key] = i;\n\t            } else {\n\t                if (!existence.length) {\n\t                    map[key] = existence = [existence];\n\t                }\n\t                existence.push(i);\n\t            }\n\t        }\n\t    }\n\t    return DataDiffer;\n\t});\n\tdefine('echarts/data/helper/completeDimensions', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    /**\n\t     * Complete the dimensions array guessed from the data structure.\n\t     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n\t     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n\t     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n\t     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n\t     * @return {Array.<string>}\n\t     */\n\t    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n\t        if (!data) {\n\t            return dimensions;\n\t        }\n\t        var value0 = retrieveValue(data[0]);\n\t        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\t        defaultNames = defaultNames || [];\n\t        extraPrefix = extraPrefix || 'extra';\n\t        for (var i = 0; i < dimSize; i++) {\n\t            if (!dimensions[i]) {\n\t                var name = defaultNames[i] || extraPrefix + (i - defaultNames.length);\n\t                dimensions[i] = guessOrdinal(data, i) ? {\n\t                    type: 'ordinal',\n\t                    name: name\n\t                } : name;\n\t            }\n\t        }\n\t        return dimensions;\n\t    }\n\t    // The rule should not be complex, otherwise user might not\n\t    // be able to known where the data is wrong.\n\t    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var value = retrieveValue(data[i]);\n\t                if (!zrUtil.isArray(value)) {\n\t                    return false;\n\t                }\n\t                var value = value[dimIndex];\n\t                if (value != null && isFinite(value)) {\n\t                    return false;\n\t                } else if (zrUtil.isString(value) && value !== '-') {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        };\n\t    function retrieveValue(o) {\n\t        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n\t    }\n\t    return completeDimensions;\n\t});\n\tdefine('zrender/contain/cubic', ['require', '../core/curve'], function (require) {\n\t    var curve = require('../core/curve');\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/line', [], function () {\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n\t                return false;\n\t            }\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n\t            } else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/quadratic', ['require', '../core/curve'], function (require) {\n\t    var curve = require('../core/curve');\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/arc', ['require', './util'], function (require) {\n\t    var normalizeRadian = require('./util').normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t    return {\n\t        containStroke: function (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t            if (d - _l > r || d + _l < r) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 0.0001) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/util', ['require'], function (require) {\n\t    var PI2 = Math.PI * 2;\n\t    return {\n\t        normalizeRadian: function (angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/windingLine', [], function () {\n\t    return function windingLine(x0, y0, x1, y1, x, y) {\n\t        if (y > y0 && y > y1 || y < y0 && y < y1) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t        var x_ = t * (x1 - x0) + x0;\n\t        return x_ > x ? dir : 0;\n\t    };\n\t});\n\tdefine('echarts/chart/bar/barItemStyle', ['require', '../../model/mixin/makeStyleMapper'], function (require) {\n\t    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'borderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'borderWidth'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'barBorderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'barBorderWidth'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getBarItemStyle: function (excludes) {\n\t            var style = getBarItemStyle.call(this, excludes);\n\t            if (this.getBorderLineDash) {\n\t                var lineDash = this.getBorderLineDash();\n\t                lineDash && (style.lineDash = lineDash);\n\t            }\n\t            return style;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/core/LRU', ['require'], function (require) {\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function () {\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t        this._len = 0;\n\t    };\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function (val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function (entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        } else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function (entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        } else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        } else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function () {\n\t        return this._len;\n\t    };\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function (val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function (maxSize) {\n\t        this._list = new LinkedList();\n\t        this._map = {};\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t    var LRUProto = LRU.prototype;\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function (key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function (key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t            return entry.value;\n\t        }\n\t    };\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function () {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t    return LRU;\n\t});\n\tdefine('zrender/graphic/helper/poly', ['require', './smoothSpline', './smoothBezier'], function (require) {\n\t    var smoothSpline = require('./smoothSpline');\n\t    var smoothBezier = require('./smoothBezier');\n\t    return {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n\t                    }\n\t                } else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/smoothSpline', ['require', '../../core/vector'], function (require) {\n\t    var vec2 = require('../../core/vector');\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t    }\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points \n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    return function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t            var w = pos - idx;\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            } else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/smoothBezier', ['require', '../../core/vector'], function (require) {\n\t    var vec2 = require('../../core/vector');\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t    /**\n\t     * \n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points \n\t     * @param {number} smooth , 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint \n\t     *                            [[0, 0], [100, 100]], \n\t     *                           \n\t     * @param {Array} \n\t     */\n\t    return function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [\n\t                Infinity,\n\t                Infinity\n\t            ];\n\t            max = [\n\t                -Infinity,\n\t                -Infinity\n\t            ];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // \n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            } else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                } else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t        return cps;\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/roundRect', ['require'], function (require) {\n\t    return {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            } else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                } else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                } else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                } else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            } else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\t});\n\tdefine('zrender/Storage', ['require', './core/util', './core/env', './container/Group', './core/timsort'], function (require) {\n\t    'use strict';\n\t    var util = require('./core/util');\n\t    var env = require('./core/env');\n\t    var Group = require('./container/Group');\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = require('./core/timsort');\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     *  (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // idmap\n\t        this._elements = {};\n\t        this._roots = [];\n\t        this._displayList = [];\n\t        this._displayListLen = 0;\n\t    };\n\t    Storage.prototype = {\n\t        constructor: Storage,\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t            el.beforeUpdate();\n\t            if (el.__dirty) {\n\t                el.update();\n\t            }\n\t            el.afterUpdate();\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath  group \n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t                // FIXME \n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                } else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t            } else {\n\t                el.__clipPaths = clipPaths;\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // elId\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t                return;\n\t            }\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t            var el;\n\t            if (typeof elId == 'string') {\n\t                el = this._elements[elId];\n\t            } else {\n\t                el = elId;\n\t            }\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t            this._elements[el.id] = el;\n\t            return this;\n\t        },\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        dispose: function () {\n\t            this._elements = this._renderList = this._roots = null;\n\t        },\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t    return Storage;\n\t});\n\tdefine('zrender/Handler', ['require', './core/util', './mixin/Draggable', './mixin/Eventful'], function (require) {\n\t    'use strict';\n\t    var util = require('./core/util');\n\t    var Draggable = require('./mixin/Draggable');\n\t    var Eventful = require('./mixin/Eventful');\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta\n\t        };\n\t    }\n\t    function EmptyProxy() {\n\t    }\n\t    EmptyProxy.prototype.dispose = function () {\n\t    };\n\t    var handlerNames = [\n\t            'click',\n\t            'dblclick',\n\t            'mousewheel',\n\t            'mouseout',\n\t            'mouseup',\n\t            'mousedown',\n\t            'mousemove'\n\t        ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {HTMLElement} root Main HTML element for painting.\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     */\n\t    var Handler = function (storage, painter, proxy) {\n\t        Eventful.call(this);\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t        proxy = proxy || new EmptyProxy();\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t        // Attach handler\n\t        proxy.handler = this;\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t        Draggable.call(this);\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t    Handler.prototype = {\n\t        constructor: Handler,\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t            this._hovered = hovered;\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t            this.trigger('globalout', { event: event });\n\t        },\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t        dispose: function () {\n\t            this.proxy.dispose();\n\t            this.storage = this.proxy = this.painter = null;\n\t        },\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t            var el = targetEl;\n\t            while (el) {\n\t                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t                el.trigger(eventName, eventPacket);\n\t                el = el.parent;\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t            if (!eventPacket.cancelBubble) {\n\t                //  zrender \n\t                this.trigger(eventName, eventPacket);\n\t                // \n\t                //  click  dispose painter \n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof layer[eventHandler] == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t        findHover: function (x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0; i--) {\n\t                if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t    // Common handlers\n\t    util.each([\n\t        'click',\n\t        'mousedown',\n\t        'mouseup',\n\t        'mousewheel',\n\t        'dblclick'\n\t    ], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            } else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            } else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || el.clipPath && !el.clipPath.contain(x, y)) {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t    return Handler;\n\t});\n\tdefine('zrender/animation/Animation', ['require', '../core/util', '../core/event', './requestAnimationFrame', './Animator'], function (require) {\n\t    'use strict';\n\t    var util = require('../core/util');\n\t    var Dispatcher = require('../core/event').Dispatcher;\n\t    var requestAnimationFrame = require('./requestAnimationFrame');\n\t    var Animator = require('./Animator');\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t        options = options || {};\n\t        this.stage = options.stage || {};\n\t        this.onframe = options.onframe || function () {\n\t        };\n\t        // private properties\n\t        this._clips = [];\n\t        this._running = false;\n\t        this._time;\n\t        this._pausedTime;\n\t        this._pauseStart;\n\t        this._paused = false;\n\t        Dispatcher.call(this);\n\t    };\n\t    Animation.prototype = {\n\t        constructor: Animation,\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        removeClip: function (clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t        _update: function () {\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                } else {\n\t                    i++;\n\t                }\n\t            }\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t            this._time = time;\n\t            this.onframe(delta);\n\t            this.trigger('frame', delta);\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t        _startLoop: function () {\n\t            var self = this;\n\t            this._running = true;\n\t            function step() {\n\t                if (self._running) {\n\t                    requestAnimationFrame(step);\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t            requestAnimationFrame(step);\n\t        },\n\t        start: function () {\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t            this._startLoop();\n\t        },\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += new Date().getTime() - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(target, options.loop, options.getter, options.setter);\n\t            return animator;\n\t        }\n\t    };\n\t    util.mixin(Animation, Dispatcher);\n\t    return Animation;\n\t});\n\tdefine('zrender/dom/HandlerProxy', ['require', '../core/event', '../core/util', '../mixin/Eventful', '../core/env', '../core/GestureMgr'], function (require) {\n\t    var eventTool = require('../core/event');\n\t    var zrUtil = require('../core/util');\n\t    var Eventful = require('../mixin/Eventful');\n\t    var env = require('../core/env');\n\t    var GestureMgr = require('../core/GestureMgr');\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t    var TOUCH_CLICK_DELAY = 300;\n\t    var mouseHandlerNames = [\n\t            'click',\n\t            'dblclick',\n\t            'mousewheel',\n\t            'mouseout',\n\t            'mouseup',\n\t            'mousedown',\n\t            'mousemove'\n\t        ];\n\t    var touchHandlerNames = [\n\t            'touchstart',\n\t            'touchend',\n\t            'touchmove'\n\t        ];\n\t    function eventNameFix(name) {\n\t        return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n\t    }\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t        stage === 'start' && gestureMgr.clear();\n\t        var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null), proxy.dom);\n\t        stage === 'end' && gestureMgr.clear();\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t    var domHandlers = {\n\t            mousemove: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                this.trigger('mousemove', event);\n\t            },\n\t            mouseout: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                var element = event.toElement || event.relatedTarget;\n\t                if (element != this.dom) {\n\t                    while (element && element.nodeType != 9) {\n\t                        // rootdommouseOut\n\t                        if (element === this.dom) {\n\t                            return;\n\t                        }\n\t                        element = element.parentNode;\n\t                    }\n\t                }\n\t                this.trigger('mouseout', event);\n\t            },\n\t            touchstart: function (event) {\n\t                // Default mouse behaviour should not be disabled here.\n\t                // For example, page may needs to be slided.\n\t                event = normalizeEvent(this.dom, event);\n\t                this._lastTouchMoment = new Date();\n\t                processGesture(this, event, 'start');\n\t                // findHover\n\t                // this._mobileFindFixed(event);\n\t                // Trigger mousemove and mousedown\n\t                domHandlers.mousemove.call(this, event);\n\t                domHandlers.mousedown.call(this, event);\n\t                setTouchTimer(this);\n\t            },\n\t            touchmove: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                processGesture(this, event, 'change');\n\t                // Mouse move should always be triggered no matter whether\n\t                // there is gestrue event, because mouse move and pinch may\n\t                // be used at the same time.\n\t                domHandlers.mousemove.call(this, event);\n\t                setTouchTimer(this);\n\t            },\n\t            touchend: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                processGesture(this, event, 'end');\n\t                domHandlers.mouseup.call(this, event);\n\t                // click event should always be triggered no matter whether\n\t                // there is gestrue event. System click can not be prevented.\n\t                if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                    domHandlers.click.call(this, event);\n\t                }\n\t                setTouchTimer(this);\n\t            }\n\t        };\n\t    // Common handlers\n\t    zrUtil.each([\n\t        'click',\n\t        'mousedown',\n\t        'mouseup',\n\t        'mousewheel',\n\t        'dblclick'\n\t    ], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t    /**\n\t     * dom \n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance \n\t     */\n\t    function initDomHandler(instance) {\n\t        for (var i = 0; i < touchHandlerNames.length; i++) {\n\t            var name = touchHandlerNames[i];\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        }\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t        this.dom = dom;\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t        this._handlers = {};\n\t        initDomHandler(this);\n\t        if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);    // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t                                                       // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t    return HandlerDomProxy;\n\t});\n\tdefine('zrender/Painter', ['require', './config', './core/util', './core/log', './core/BoundingRect', './core/timsort', './Layer', './animation/requestAnimationFrame', './graphic/Image'], function (require) {\n\t    'use strict';\n\t    var config = require('./config');\n\t    var util = require('./core/util');\n\t    var log = require('./core/log');\n\t    var BoundingRect = require('./core/BoundingRect');\n\t    var timsort = require('./core/timsort');\n\t    var Layer = require('./Layer');\n\t    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t        if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n\t            return false;\n\t        }\n\t        return true;\n\t    }\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) {\n\t            // Can both be null or undefined\n\t            return false;\n\t        }\n\t        if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t        var domRootStyle = domRoot.style;\n\t        // domRoot.onselectstart = returnFalse; // \n\t        domRootStyle.position = 'relative';\n\t        domRootStyle.overflow = 'hidden';\n\t        domRootStyle.width = width + 'px';\n\t        domRootStyle.height = height + 'px';\n\t        return domRoot;\n\t    }\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root \n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';\n\t        opts = opts || {};\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * \n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t        var rootStyle = root.style;\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n\t            root.innerHTML = '';\n\t        }\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t        if (!singleCanvas) {\n\t            this._width = this._getWidth();\n\t            this._height = this._getHeight();\n\t            var domRoot = this._domRoot = createRoot(this._width, this._height);\n\t            root.appendChild(domRoot);\n\t        } else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t        }\n\t        this.pathToImage = this._createPathToImage();\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t        this._hoverElements = [];\n\t    };\n\t    Painter.prototype = {\n\t        constructor: Painter,\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t        refresh: function (paintAll) {\n\t            var list = this.storage.getDisplayList(true);\n\t            var zlevelList = this._zlevelList;\n\t            this._paintList(list, paintAll);\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t            this.refreshHover();\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t            return this;\n\t        },\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                    style: el.style,\n\t                    shape: el.shape\n\t                });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(100000);\n\t            }\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t        _startProgessive: function () {\n\t            var self = this;\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    } else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t        _paintList: function (list, paintAll) {\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t            this._updateLayerStatus(list);\n\t            this._clearProgressive();\n\t            this.eachBuildinLayer(preProcessLayer);\n\t            this._doPaintList(list, paintAll);\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t            // var invTransform = [];\n\t            var scope;\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var elFrame = el.__frame;\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t                    // Reset scope\n\t                    scope = {};\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t                    if (!currentLayer.isBuildin) {\n\t                        log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n\t                    }\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t                        if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                } else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n\t                var clipPaths = el.__clipPaths;\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t                this.insertLayer(zlevel, layer);\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t            return layer;\n\t        },\n\t        insertLayer: function (zlevel, layer) {\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n\t                } else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            } else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                } else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            layersMap[zlevel] = layer;\n\t        },\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (!layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t        _updateLayerStatus: function (list) {\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t                    currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                } else {\n\t                    el.__frame = -1;\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t            // \n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                } else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t                var layer = this._layers[zlevel];\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t            width = width || this._getWidth();\n\t            height = height || this._getHeight();\n\t            domRoot.style.display = '';\n\t            // resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t                for (var id in this._layers) {\n\t                    this._layers[id].resize(width, height);\n\t                }\n\t                this.refresh(true);\n\t            }\n\t            this._width = width;\n\t            this._height = height;\n\t            return this;\n\t        },\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t            this.root = this.storage = this._domRoot = this._layers = null;\n\t        },\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t            var displayList = this.storage.getDisplayList(true);\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t            return imageLayer.dom;\n\t        },\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t            // FIXME Better way to get the width and height when element has not been append to the document\n\t            return (root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0) | 0;\n\t        },\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t            return (root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0) | 0;\n\t        },\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t            var pathTransform = {\n\t                    position: path.position,\n\t                    rotation: path.rotation,\n\t                    scale: path.scale\n\t                };\n\t            path.position = [\n\t                0,\n\t                0,\n\t                0\n\t            ];\n\t            path.rotation = 0;\n\t            path.scale = [\n\t                1,\n\t                1\n\t            ];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t            var ImageShape = require('./graphic/Image');\n\t            var imgShape = new ImageShape({\n\t                    id: id,\n\t                    style: {\n\t                        x: 0,\n\t                        y: 0,\n\t                        image: canvas\n\t                    }\n\t                });\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t            return imgShape;\n\t        },\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(id, e, width, height, me.dpr);\n\t            };\n\t        }\n\t    };\n\t    return Painter;\n\t});\n\tdefine('zrender/mixin/Draggable', ['require'], function (require) {\n\t    function Draggable() {\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);    // this._dropTarget = null;\n\t                                                      // this._draggingTarget = null;\n\t                                                      // this._x = 0;\n\t                                                      // this._y = 0;\n\t    }\n\t    Draggable.prototype = {\n\t        constructor: Draggable,\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t    };\n\t    return Draggable;\n\t});\n\tdefine('zrender/core/event', ['require', '../mixin/Eventful'], function (require) {\n\t    'use strict';\n\t    var Eventful = require('../mixin/Eventful');\n\t    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n\t            left: 0,\n\t            top: 0\n\t        };\n\t    }\n\t    function clientToLocal(el, e, out) {\n\t        // clientX/clientY is according to view port.\n\t        var box = getBoundingClientRect(el);\n\t        out = out || {};\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t        return out;\n\t    }\n\t    /**\n\t     * domtouch\n\t     */\n\t    function normalizeEvent(el, e) {\n\t        e = e || window.event;\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e);\n\t            e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        } else {\n\t            var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e);\n\t        }\n\t        return e;\n\t    }\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        } else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        } else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event\n\t     */\n\t    var stop = isDomLevel2 ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        } : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t    return {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t        stop: stop,\n\t        Dispatcher: Eventful\n\t    };\n\t});\n\tdefine('zrender/animation/requestAnimationFrame', ['require'], function (require) {\n\t    return typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n\t        setTimeout(func, 16);\n\t    };\n\t});\n\tdefine('zrender/core/GestureMgr', ['require', './event'], function (require) {\n\t    'use strict';\n\t    var eventUtil = require('./event');\n\t    var GestureMgr = function () {\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t    GestureMgr.prototype = {\n\t        constructor: GestureMgr,\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t            if (!touches) {\n\t                return;\n\t            }\n\t            var trackItem = {\n\t                    points: [],\n\t                    touches: [],\n\t                    target: target,\n\t                    event: event\n\t                };\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch);\n\t                trackItem.points.push([\n\t                    pos.zrX,\n\t                    pos.zrY\n\t                ]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t            this._track.push(trackItem);\n\t        },\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t    var recognizers = {\n\t            pinch: function (track, event) {\n\t                var trackLen = track.length;\n\t                if (!trackLen) {\n\t                    return;\n\t                }\n\t                var pinchEnd = (track[trackLen - 1] || {}).points;\n\t                var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t                if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n\t                    var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                    !isFinite(pinchScale) && (pinchScale = 1);\n\t                    event.pinchScale = pinchScale;\n\t                    var pinchCenter = center(pinchEnd);\n\t                    event.pinchX = pinchCenter[0];\n\t                    event.pinchY = pinchCenter[1];\n\t                    return {\n\t                        type: 'pinch',\n\t                        target: track[0].target,\n\t                        event: event\n\t                    };\n\t                }\n\t            }    // Only pinch currently.\n\t        };\n\t    return GestureMgr;\n\t});\n\tdefine('zrender/Layer', ['require', './core/util', './config', './graphic/Style', './graphic/Pattern'], function (require) {\n\t    var util = require('./core/util');\n\t    var config = require('./config');\n\t    var Style = require('./graphic/Style');\n\t    var Pattern = require('./graphic/Pattern');\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t    /**\n\t     * dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id \n\t     * @param {string} type dom typesuch as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t        var newDomStyle = newDom.style;\n\t        // append~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t        // id\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function (id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }    // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t        var domStyle = dom.style;\n\t        if (domStyle) {\n\t            // Not in node\n\t            dom.onselectstart = returnFalse;\n\t            // \n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t        }\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t        this.painter = painter;\n\t        this.config = null;\n\t        // Configs\n\t        /**\n\t         * \n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * \n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * alpha\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t    Layer.prototype = {\n\t        constructor: Layer,\n\t        elCount: 0,\n\t        __dirty: true,\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t            var dpr = this.dpr;\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n\t            }\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }    // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t    return Layer;\n\t});\n\tdefine('echarts/preprocessor/helper/compatStyle', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var POSSIBLE_STYLES = [\n\t            'areaStyle',\n\t            'lineStyle',\n\t            'nodeStyle',\n\t            'linkStyle',\n\t            'chordStyle',\n\t            'label',\n\t            'labelLine'\n\t        ];\n\t    function compatItemStyle(opt) {\n\t        var itemStyleOpt = opt && opt.itemStyle;\n\t        if (itemStyleOpt) {\n\t            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n\t                var normalItemStyleOpt = itemStyleOpt.normal;\n\t                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\t                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].normal) {\n\t                        opt[styleName].normal = normalItemStyleOpt[styleName];\n\t                    } else {\n\t                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n\t                    }\n\t                    normalItemStyleOpt[styleName] = null;\n\t                }\n\t                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].emphasis) {\n\t                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n\t                    } else {\n\t                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n\t                    }\n\t                    emphasisItemStyleOpt[styleName] = null;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    return function (seriesOpt) {\n\t        if (!seriesOpt) {\n\t            return;\n\t        }\n\t        compatItemStyle(seriesOpt);\n\t        compatItemStyle(seriesOpt.markPoint);\n\t        compatItemStyle(seriesOpt.markLine);\n\t        var data = seriesOpt.data;\n\t        if (data) {\n\t            for (var i = 0; i < data.length; i++) {\n\t                compatItemStyle(data[i]);\n\t            }\n\t            // mark point data\n\t            var markPoint = seriesOpt.markPoint;\n\t            if (markPoint && markPoint.data) {\n\t                var mpData = markPoint.data;\n\t                for (var i = 0; i < mpData.length; i++) {\n\t                    compatItemStyle(mpData[i]);\n\t                }\n\t            }\n\t            // mark line data\n\t            var markLine = seriesOpt.markLine;\n\t            if (markLine && markLine.data) {\n\t                var mlData = markLine.data;\n\t                for (var i = 0; i < mlData.length; i++) {\n\t                    if (zrUtil.isArray(mlData[i])) {\n\t                        compatItemStyle(mlData[i][0]);\n\t                        compatItemStyle(mlData[i][1]);\n\t                    } else {\n\t                        compatItemStyle(mlData[i]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/helper/selectableMixin', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    return {\n\t        updateSelectedMap: function (targetList) {\n\t            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n\t                targetMap[target.name] = target;\n\t                return targetMap;\n\t            }, {});\n\t        },\n\t        select: function (name) {\n\t            var targetMap = this._selectTargetMap;\n\t            var target = targetMap[name];\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                zrUtil.each(targetMap, function (target) {\n\t                    target.selected = false;\n\t                });\n\t            }\n\t            target && (target.selected = true);\n\t        },\n\t        unSelect: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            // var selectedMode = this.get('selectedMode');\n\t            // selectedMode !== 'single' && target && (target.selected = false);\n\t            target && (target.selected = false);\n\t        },\n\t        toggleSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            if (target != null) {\n\t                this[target.selected ? 'unSelect' : 'select'](name);\n\t                return target.selected;\n\t            }\n\t        },\n\t        isSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            return target && target.selected;\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/axis/AxisView', ['require', 'zrender/core/util', '../../util/graphic', './AxisBuilder', '../../echarts'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var graphic = require('../../util/graphic');\n\t    var AxisBuilder = require('./AxisBuilder');\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n\t    var getInterval = AxisBuilder.getInterval;\n\t    var axisBuilderAttrs = [\n\t            'axisLine',\n\t            'axisLabel',\n\t            'axisTick',\n\t            'axisName'\n\t        ];\n\t    var selfBuilderAttrs = [\n\t            'splitArea',\n\t            'splitLine'\n\t        ];\n\t    // function getAlignWithLabel(model, axisModel) {\n\t    //     var alignWithLabel = model.get('alignWithLabel');\n\t    //     if (alignWithLabel === 'auto') {\n\t    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n\t    //     }\n\t    //     return alignWithLabel;\n\t    // }\n\t    var AxisView = require('../../echarts').extendComponentView({\n\t            type: 'axis',\n\t            render: function (axisModel, ecModel) {\n\t                this.group.removeAll();\n\t                var oldAxisGroup = this._axisGroup;\n\t                this._axisGroup = new graphic.Group();\n\t                this.group.add(this._axisGroup);\n\t                if (!axisModel.get('show')) {\n\t                    return;\n\t                }\n\t                var gridModel = axisModel.findGridModel();\n\t                var layout = layoutAxis(gridModel, axisModel);\n\t                var axisBuilder = new AxisBuilder(axisModel, layout);\n\t                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\t                this._axisGroup.add(axisBuilder.getGroup());\n\t                zrUtil.each(selfBuilderAttrs, function (name) {\n\t                    if (axisModel.get(name + '.show')) {\n\t                        this['_' + name](axisModel, gridModel, layout.labelInterval);\n\t                    }\n\t                }, this);\n\t                graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\t            },\n\t            _splitLine: function (axisModel, gridModel, labelInterval) {\n\t                var axis = axisModel.axis;\n\t                var splitLineModel = axisModel.getModel('splitLine');\n\t                var lineStyleModel = splitLineModel.getModel('lineStyle');\n\t                var lineColors = lineStyleModel.get('color');\n\t                var lineInterval = getInterval(splitLineModel, labelInterval);\n\t                lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\t                var gridRect = gridModel.coordinateSystem.getRect();\n\t                var isHorizontal = axis.isHorizontal();\n\t                var lineCount = 0;\n\t                var ticksCoords = axis.getTicksCoords();\n\t                var ticks = axis.scale.getTicks();\n\t                var p1 = [];\n\t                var p2 = [];\n\t                // Simple optimization\n\t                // Batching the lines if color are the same\n\t                var lineStyle = lineStyleModel.getLineStyle();\n\t                for (var i = 0; i < ticksCoords.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, lineInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t                    if (isHorizontal) {\n\t                        p1[0] = tickCoord;\n\t                        p1[1] = gridRect.y;\n\t                        p2[0] = tickCoord;\n\t                        p2[1] = gridRect.y + gridRect.height;\n\t                    } else {\n\t                        p1[0] = gridRect.x;\n\t                        p1[1] = tickCoord;\n\t                        p2[0] = gridRect.x + gridRect.width;\n\t                        p2[1] = tickCoord;\n\t                    }\n\t                    var colorIndex = lineCount++ % lineColors.length;\n\t                    this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                        anid: 'line_' + ticks[i],\n\t                        shape: {\n\t                            x1: p1[0],\n\t                            y1: p1[1],\n\t                            x2: p2[0],\n\t                            y2: p2[1]\n\t                        },\n\t                        style: zrUtil.defaults({ stroke: lineColors[colorIndex] }, lineStyle),\n\t                        silent: true\n\t                    })));\n\t                }\n\t            },\n\t            _splitArea: function (axisModel, gridModel, labelInterval) {\n\t                var axis = axisModel.axis;\n\t                var splitAreaModel = axisModel.getModel('splitArea');\n\t                var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\t                var areaColors = areaStyleModel.get('color');\n\t                var gridRect = gridModel.coordinateSystem.getRect();\n\t                var ticksCoords = axis.getTicksCoords();\n\t                var ticks = axis.scale.getTicks();\n\t                var prevX = axis.toGlobalCoord(ticksCoords[0]);\n\t                var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\t                var count = 0;\n\t                var areaInterval = getInterval(splitAreaModel, labelInterval);\n\t                var areaStyle = areaStyleModel.getAreaStyle();\n\t                areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\t                for (var i = 1; i < ticksCoords.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, areaInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t                    var x;\n\t                    var y;\n\t                    var width;\n\t                    var height;\n\t                    if (axis.isHorizontal()) {\n\t                        x = prevX;\n\t                        y = gridRect.y;\n\t                        width = tickCoord - x;\n\t                        height = gridRect.height;\n\t                    } else {\n\t                        x = gridRect.x;\n\t                        y = prevY;\n\t                        width = gridRect.width;\n\t                        height = tickCoord - y;\n\t                    }\n\t                    var colorIndex = count++ % areaColors.length;\n\t                    this._axisGroup.add(new graphic.Rect({\n\t                        anid: 'area_' + ticks[i],\n\t                        shape: {\n\t                            x: x,\n\t                            y: y,\n\t                            width: width,\n\t                            height: height\n\t                        },\n\t                        style: zrUtil.defaults({ fill: areaColors[colorIndex] }, areaStyle),\n\t                        silent: true\n\t                    }));\n\t                    prevX = x + width;\n\t                    prevY = y + height;\n\t                }\n\t            }\n\t        });\n\t    AxisView.extend({ type: 'xAxis' });\n\t    AxisView.extend({ type: 'yAxis' });\n\t    /**\n\t     * @inner\n\t     */\n\t    function layoutAxis(gridModel, axisModel) {\n\t        var grid = gridModel.coordinateSystem;\n\t        var axis = axisModel.axis;\n\t        var layout = {};\n\t        var rawAxisPosition = axis.position;\n\t        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n\t        var axisDim = axis.dim;\n\t        // [left, right, top, bottom]\n\t        var rect = grid.getRect();\n\t        var rectBound = [\n\t                rect.x,\n\t                rect.x + rect.width,\n\t                rect.y,\n\t                rect.y + rect.height\n\t            ];\n\t        var axisOffset = axisModel.get('offset') || 0;\n\t        var posMap = {\n\t                x: {\n\t                    top: rectBound[2] - axisOffset,\n\t                    bottom: rectBound[3] + axisOffset\n\t                },\n\t                y: {\n\t                    left: rectBound[0] - axisOffset,\n\t                    right: rectBound[1] + axisOffset\n\t                }\n\t            };\n\t        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n\t        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\t        function getZero(dim, val) {\n\t            var theAxis = grid.getAxis(dim);\n\t            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n\t        }\n\t        // Axis position\n\t        layout.position = [\n\t            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n\t            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n\t        ];\n\t        // Axis rotation\n\t        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\t        // Tick and label direction, x y is axisDim\n\t        var dirMap = {\n\t                top: -1,\n\t                bottom: 1,\n\t                left: -1,\n\t                right: 1\n\t            };\n\t        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n\t        if (axis.onZero) {\n\t            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n\t        }\n\t        if (axisModel.getModel('axisTick').get('inside')) {\n\t            layout.tickDirection = -layout.tickDirection;\n\t        }\n\t        if (axisModel.getModel('axisLabel').get('inside')) {\n\t            layout.labelDirection = -layout.labelDirection;\n\t        }\n\t        // Special label rotation\n\t        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n\t        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\t        // label interval when auto mode.\n\t        layout.labelInterval = axis.getLabelInterval();\n\t        // Over splitLine and splitArea\n\t        layout.z2 = 1;\n\t        return layout;\n\t    }\n\t});\n\tdefine('echarts/chart/pie/labelLayout', ['require', 'zrender/contain/text'], function (require) {\n\t    'use strict';\n\t    var textContain = require('zrender/contain/text');\n\t    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n\t        list.sort(function (a, b) {\n\t            return a.y - b.y;\n\t        });\n\t        // \n\t        function shiftDown(start, end, delta, dir) {\n\t            for (var j = start; j < end; j++) {\n\t                list[j].y += delta;\n\t                if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n\t                    shiftUp(j, delta / 2);\n\t                    return;\n\t                }\n\t            }\n\t            shiftUp(end - 1, delta / 2);\n\t        }\n\t        // \n\t        function shiftUp(end, delta) {\n\t            for (var j = end; j >= 0; j--) {\n\t                list[j].y -= delta;\n\t                if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        function changeX(list, isDownList, cx, cy, r, dir) {\n\t            var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;\n\t            // \n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                // Not change x for center label\n\t                if (list[i].position === 'center') {\n\t                    continue;\n\t                }\n\t                var deltaY = Math.abs(list[i].y - cy);\n\t                var length = list[i].len;\n\t                var length2 = list[i].len2;\n\t                var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\t                if (isDownList && deltaX >= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX - 10;\n\t                }\n\t                if (!isDownList && deltaX <= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX + 10;\n\t                }\n\t                list[i].x = cx + deltaX * dir;\n\t                lastDeltaX = deltaX;\n\t            }\n\t        }\n\t        var lastY = 0;\n\t        var delta;\n\t        var len = list.length;\n\t        var upList = [];\n\t        var downList = [];\n\t        for (var i = 0; i < len; i++) {\n\t            delta = list[i].y - lastY;\n\t            if (delta < 0) {\n\t                shiftDown(i, len, -delta, dir);\n\t            }\n\t            lastY = list[i].y + list[i].height;\n\t        }\n\t        if (viewHeight - lastY < 0) {\n\t            shiftUp(len - 1, lastY - viewHeight);\n\t        }\n\t        for (var i = 0; i < len; i++) {\n\t            if (list[i].y >= cy) {\n\t                downList.push(list[i]);\n\t            } else {\n\t                upList.push(list[i]);\n\t            }\n\t        }\n\t        changeX(upList, false, cx, cy, r, dir);\n\t        changeX(downList, true, cx, cy, r, dir);\n\t    }\n\t    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n\t        var leftList = [];\n\t        var rightList = [];\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            if (labelLayoutList[i].x < cx) {\n\t                leftList.push(labelLayoutList[i]);\n\t            } else {\n\t                rightList.push(labelLayoutList[i]);\n\t            }\n\t        }\n\t        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n\t        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            var linePoints = labelLayoutList[i].linePoints;\n\t            if (linePoints) {\n\t                var dist = linePoints[1][0] - linePoints[2][0];\n\t                if (labelLayoutList[i].x < cx) {\n\t                    linePoints[2][0] = labelLayoutList[i].x + 3;\n\t                } else {\n\t                    linePoints[2][0] = labelLayoutList[i].x - 3;\n\t                }\n\t                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n\t                linePoints[1][0] = linePoints[2][0] + dist;\n\t            }\n\t        }\n\t    }\n\t    return function (seriesModel, r, viewWidth, viewHeight) {\n\t        var data = seriesModel.getData();\n\t        var labelLayoutList = [];\n\t        var cx;\n\t        var cy;\n\t        var hasLabelRotate = false;\n\t        data.each(function (idx) {\n\t            var layout = data.getItemLayout(idx);\n\t            var itemModel = data.getItemModel(idx);\n\t            var labelModel = itemModel.getModel('label.normal');\n\t            // Use position in normal or emphasis\n\t            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\t            var labelLineModel = itemModel.getModel('labelLine.normal');\n\t            var labelLineLen = labelLineModel.get('length');\n\t            var labelLineLen2 = labelLineModel.get('length2');\n\t            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t            var dx = Math.cos(midAngle);\n\t            var dy = Math.sin(midAngle);\n\t            var textX;\n\t            var textY;\n\t            var linePoints;\n\t            var textAlign;\n\t            cx = layout.cx;\n\t            cy = layout.cy;\n\t            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t            if (labelPosition === 'center') {\n\t                textX = layout.cx;\n\t                textY = layout.cy;\n\t                textAlign = 'center';\n\t            } else {\n\t                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n\t                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\t                textX = x1 + dx * 3;\n\t                textY = y1 + dy * 3;\n\t                if (!isLabelInside) {\n\t                    // For roseType\n\t                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n\t                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n\t                    var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n\t                    var y3 = y2;\n\t                    textX = x3 + (dx < 0 ? -5 : 5);\n\t                    textY = y3;\n\t                    linePoints = [\n\t                        [\n\t                            x1,\n\t                            y1\n\t                        ],\n\t                        [\n\t                            x2,\n\t                            y2\n\t                        ],\n\t                        [\n\t                            x3,\n\t                            y3\n\t                        ]\n\t                    ];\n\t                }\n\t                textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n\t            }\n\t            var font = labelModel.getModel('textStyle').getFont();\n\t            var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n\t            var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n\t            var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n\t            hasLabelRotate = !!labelRotate;\n\t            layout.label = {\n\t                x: textX,\n\t                y: textY,\n\t                position: labelPosition,\n\t                height: textRect.height,\n\t                len: labelLineLen,\n\t                len2: labelLineLen2,\n\t                linePoints: linePoints,\n\t                textAlign: textAlign,\n\t                verticalAlign: 'middle',\n\t                font: font,\n\t                rotation: labelRotate\n\t            };\n\t            // Not layout the inside label\n\t            if (!isLabelInside) {\n\t                labelLayoutList.push(layout.label);\n\t            }\n\t        });\n\t        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n\t            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/axis/AxisBuilder', ['require', 'zrender/core/util', '../../util/format', '../../util/graphic', '../../model/Model', '../../util/number', 'zrender/core/vector'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var formatUtil = require('../../util/format');\n\t    var graphic = require('../../util/graphic');\n\t    var Model = require('../../model/Model');\n\t    var numberUtil = require('../../util/number');\n\t    var remRadian = numberUtil.remRadian;\n\t    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n\t    var vec2 = require('zrender/core/vector');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var retrieve = zrUtil.retrieve;\n\t    var PI = Math.PI;\n\t    function makeAxisEventDataBase(axisModel) {\n\t        var eventData = { componentType: axisModel.mainType };\n\t        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n\t        return eventData;\n\t    }\n\t    /**\n\t     * A final axis is translated and rotated from a \"standard axis\".\n\t     * So opt.position and opt.rotation is required.\n\t     *\n\t     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n\t     * for example: (0, 0) ------------> (0, 50)\n\t     *\n\t     * nameDirection or tickDirection or labelDirection is 1 means tick\n\t     * or label is below the standard axis, whereas is -1 means above\n\t     * the standard axis. labelOffset means offset between label and axis,\n\t     * which is useful when 'onZero', where axisLabel is in the grid and\n\t     * label in outside grid.\n\t     *\n\t     * Tips: like always,\n\t     * positive rotation represents anticlockwise, and negative rotation\n\t     * represents clockwise.\n\t     * The direction of position coordinate is the same as the direction\n\t     * of screen coordinate.\n\t     *\n\t     * Do not need to consider axis 'inverse', which is auto processed by\n\t     * axis extent.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} axisModel\n\t     * @param {Object} opt Standard axis parameters.\n\t     * @param {Array.<number>} opt.position [x, y]\n\t     * @param {number} opt.rotation by radian\n\t     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n\t     * @param {number} [opt.tickDirection=1] 1 or -1\n\t     * @param {number} [opt.labelDirection=1] 1 or -1\n\t     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n\t     * @param {string} [opt.axisLabelShow] default get from axisModel.\n\t     * @param {string} [opt.axisName] default get from axisModel.\n\t     * @param {number} [opt.axisNameAvailableWidth]\n\t     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n\t     * @param {number} [opt.labelInterval] Default label interval when label\n\t     *                                     interval from model is null or 'auto'.\n\t     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n\t     */\n\t    var AxisBuilder = function (axisModel, opt) {\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.opt = opt;\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.axisModel = axisModel;\n\t        // Default value\n\t        zrUtil.defaults(opt, {\n\t            labelOffset: 0,\n\t            nameDirection: 1,\n\t            tickDirection: 1,\n\t            labelDirection: 1,\n\t            silent: true\n\t        });\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.group = new graphic.Group();\n\t        // FIXME Not use a seperate text group?\n\t        var dumbGroup = new graphic.Group({\n\t                position: opt.position.slice(),\n\t                rotation: opt.rotation\n\t            });\n\t        // this.group.add(dumbGroup);\n\t        // this._dumbGroup = dumbGroup;\n\t        dumbGroup.updateTransform();\n\t        this._transform = dumbGroup.transform;\n\t        this._dumbGroup = dumbGroup;\n\t    };\n\t    AxisBuilder.prototype = {\n\t        constructor: AxisBuilder,\n\t        hasBuilder: function (name) {\n\t            return !!builders[name];\n\t        },\n\t        add: function (name) {\n\t            builders[name].call(this);\n\t        },\n\t        getGroup: function () {\n\t            return this.group;\n\t        }\n\t    };\n\t    var builders = {\n\t            axisLine: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                if (!axisModel.get('axisLine.show')) {\n\t                    return;\n\t                }\n\t                var extent = this.axisModel.axis.getExtent();\n\t                var matrix = this._transform;\n\t                var pt1 = [\n\t                        extent[0],\n\t                        0\n\t                    ];\n\t                var pt2 = [\n\t                        extent[1],\n\t                        0\n\t                    ];\n\t                if (matrix) {\n\t                    v2ApplyTransform(pt1, pt1, matrix);\n\t                    v2ApplyTransform(pt2, pt2, matrix);\n\t                }\n\t                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                    anid: 'line',\n\t                    shape: {\n\t                        x1: pt1[0],\n\t                        y1: pt1[1],\n\t                        x2: pt2[0],\n\t                        y2: pt2[1]\n\t                    },\n\t                    style: zrUtil.extend({ lineCap: 'round' }, axisModel.getModel('axisLine.lineStyle').getLineStyle()),\n\t                    strokeContainThreshold: opt.strokeContainThreshold || 5,\n\t                    silent: true,\n\t                    z2: 1\n\t                })));\n\t            },\n\t            axisTick: function () {\n\t                var axisModel = this.axisModel;\n\t                if (!axisModel.get('axisTick.show')) {\n\t                    return;\n\t                }\n\t                var axis = axisModel.axis;\n\t                var tickModel = axisModel.getModel('axisTick');\n\t                var opt = this.opt;\n\t                var lineStyleModel = tickModel.getModel('lineStyle');\n\t                var tickLen = tickModel.get('length');\n\t                var tickInterval = getInterval(tickModel, opt.labelInterval);\n\t                var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n\t                var ticks = axis.scale.getTicks();\n\t                var pt1 = [];\n\t                var pt2 = [];\n\t                var matrix = this._transform;\n\t                for (var i = 0; i < ticksCoords.length; i++) {\n\t                    // Only ordinal scale support tick interval\n\t                    if (ifIgnoreOnTick(axis, i, tickInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = ticksCoords[i];\n\t                    pt1[0] = tickCoord;\n\t                    pt1[1] = 0;\n\t                    pt2[0] = tickCoord;\n\t                    pt2[1] = opt.tickDirection * tickLen;\n\t                    if (matrix) {\n\t                        v2ApplyTransform(pt1, pt1, matrix);\n\t                        v2ApplyTransform(pt2, pt2, matrix);\n\t                    }\n\t                    // Tick line, Not use group transform to have better line draw\n\t                    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                        anid: 'tick_' + ticks[i],\n\t                        shape: {\n\t                            x1: pt1[0],\n\t                            y1: pt1[1],\n\t                            x2: pt2[0],\n\t                            y2: pt2[1]\n\t                        },\n\t                        style: zrUtil.defaults(lineStyleModel.getLineStyle(), { stroke: axisModel.get('axisLine.lineStyle.color') }),\n\t                        z2: 2,\n\t                        silent: true\n\t                    })));\n\t                }\n\t            },\n\t            axisLabel: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\t                if (!show) {\n\t                    return;\n\t                }\n\t                var axis = axisModel.axis;\n\t                var labelModel = axisModel.getModel('axisLabel');\n\t                var textStyleModel = labelModel.getModel('textStyle');\n\t                var labelMargin = labelModel.get('margin');\n\t                var ticks = axis.scale.getTicks();\n\t                var labels = axisModel.getFormattedLabels();\n\t                // Special label rotate.\n\t                var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n\t                // To radian.\n\t                labelRotation = labelRotation * PI / 180;\n\t                var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n\t                var categoryData = axisModel.get('data');\n\t                var textEls = [];\n\t                var silent = isSilent(axisModel);\n\t                var triggerEvent = axisModel.get('triggerEvent');\n\t                for (var i = 0; i < ticks.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n\t                        continue;\n\t                    }\n\t                    var itemTextStyleModel = textStyleModel;\n\t                    if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n\t                        itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);\n\t                    }\n\t                    var textColor = itemTextStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n\t                    var tickCoord = axis.dataToCoord(ticks[i]);\n\t                    var pos = [\n\t                            tickCoord,\n\t                            opt.labelOffset + opt.labelDirection * labelMargin\n\t                        ];\n\t                    var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\t                    var textEl = new graphic.Text({\n\t                            anid: 'label_' + ticks[i],\n\t                            style: {\n\t                                text: labels[i],\n\t                                textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n\t                                textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n\t                                textFont: itemTextStyleModel.getFont(),\n\t                                fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n\t                            },\n\t                            position: pos,\n\t                            rotation: labelLayout.rotation,\n\t                            silent: silent,\n\t                            z2: 10\n\t                        });\n\t                    // Pack data for mouse event\n\t                    if (triggerEvent) {\n\t                        textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                        textEl.eventData.targetType = 'axisLabel';\n\t                        textEl.eventData.value = labelBeforeFormat;\n\t                    }\n\t                    // FIXME\n\t                    this._dumbGroup.add(textEl);\n\t                    textEl.updateTransform();\n\t                    textEls.push(textEl);\n\t                    this.group.add(textEl);\n\t                    textEl.decomposeTransform();\n\t                }\n\t                function isTwoLabelOverlapped(current, next) {\n\t                    var firstRect = current && current.getBoundingRect().clone();\n\t                    var nextRect = next && next.getBoundingRect().clone();\n\t                    if (firstRect && nextRect) {\n\t                        firstRect.applyTransform(current.getLocalTransform());\n\t                        nextRect.applyTransform(next.getLocalTransform());\n\t                        return firstRect.intersect(nextRect);\n\t                    }\n\t                }\n\t                if (axis.type !== 'category') {\n\t                    // If min or max are user set, we need to check\n\t                    // If the tick on min(max) are overlap on their neighbour tick\n\t                    // If they are overlapped, we need to hide the min(max) tick label\n\t                    if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n\t                        var firstLabel = textEls[0];\n\t                        var nextLabel = textEls[1];\n\t                        if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n\t                            firstLabel.ignore = true;\n\t                        }\n\t                    }\n\t                    if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n\t                        var lastLabel = textEls[textEls.length - 1];\n\t                        var prevLabel = textEls[textEls.length - 2];\n\t                        if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n\t                            lastLabel.ignore = true;\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            axisName: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                var name = retrieve(opt.axisName, axisModel.get('name'));\n\t                if (!name) {\n\t                    return;\n\t                }\n\t                var nameLocation = axisModel.get('nameLocation');\n\t                var nameDirection = opt.nameDirection;\n\t                var textStyleModel = axisModel.getModel('nameTextStyle');\n\t                var gap = axisModel.get('nameGap') || 0;\n\t                var extent = this.axisModel.axis.getExtent();\n\t                var gapSignal = extent[0] > extent[1] ? -1 : 1;\n\t                var pos = [\n\t                        nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n\t                        nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n\t                    ];\n\t                var labelLayout;\n\t                var nameRotation = axisModel.get('nameRotate');\n\t                if (nameRotation != null) {\n\t                    nameRotation = nameRotation * PI / 180;    // To radian.\n\t                }\n\t                var axisNameAvailableWidth;\n\t                if (nameLocation === 'middle') {\n\t                    labelLayout = innerTextLayout(opt, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n\t                } else {\n\t                    labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n\t                    axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\t                    if (axisNameAvailableWidth != null) {\n\t                        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n\t                        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n\t                    }\n\t                }\n\t                var textFont = textStyleModel.getFont();\n\t                var truncateOpt = axisModel.get('nameTruncate', true) || {};\n\t                var ellipsis = truncateOpt.ellipsis;\n\t                var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n\t                var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n\t                        minChar: 2,\n\t                        placeholder: truncateOpt.placeholder\n\t                    }) : name;\n\t                var tooltipOpt = axisModel.get('tooltip', true);\n\t                var mainType = axisModel.mainType;\n\t                var formatterParams = {\n\t                        componentType: mainType,\n\t                        name: name,\n\t                        $vars: ['name']\n\t                    };\n\t                formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\t                var textEl = new graphic.Text({\n\t                        anid: 'name',\n\t                        __fullText: name,\n\t                        __truncatedText: truncatedText,\n\t                        style: {\n\t                            text: truncatedText,\n\t                            textFont: textFont,\n\t                            fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n\t                            textAlign: labelLayout.textAlign,\n\t                            textVerticalAlign: labelLayout.verticalAlign\n\t                        },\n\t                        position: pos,\n\t                        rotation: labelLayout.rotation,\n\t                        silent: isSilent(axisModel),\n\t                        z2: 1,\n\t                        tooltip: tooltipOpt && tooltipOpt.show ? zrUtil.extend({\n\t                            content: name,\n\t                            formatter: function () {\n\t                                return name;\n\t                            },\n\t                            formatterParams: formatterParams\n\t                        }, tooltipOpt) : null\n\t                    });\n\t                if (axisModel.get('triggerEvent')) {\n\t                    textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                    textEl.eventData.targetType = 'axisName';\n\t                    textEl.eventData.name = name;\n\t                }\n\t                // FIXME\n\t                this._dumbGroup.add(textEl);\n\t                textEl.updateTransform();\n\t                this.group.add(textEl);\n\t                textEl.decomposeTransform();\n\t            }\n\t        };\n\t    /**\n\t     * @inner\n\t     */\n\t    function innerTextLayout(opt, textRotation, direction) {\n\t        var rotationDiff = remRadian(textRotation - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        if (isRadianAroundZero(rotationDiff)) {\n\t            // Label is parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        } else if (isRadianAroundZero(rotationDiff - PI)) {\n\t            // Label is inverse parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        } else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff > 0 && rotationDiff < PI) {\n\t                textAlign = direction > 0 ? 'right' : 'left';\n\t            } else {\n\t                textAlign = direction > 0 ? 'left' : 'right';\n\t            }\n\t        }\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function endTextLayout(opt, textPosition, textRotate, extent) {\n\t        var rotationDiff = remRadian(textRotate - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        var inverse = extent[0] > extent[1];\n\t        var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\t        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n\t            verticalAlign = onLeft ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n\t            verticalAlign = onLeft ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        } else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n\t                textAlign = onLeft ? 'left' : 'right';\n\t            } else {\n\t                textAlign = onLeft ? 'right' : 'left';\n\t            }\n\t        }\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function isSilent(axisModel) {\n\t        var tooltipOpt = axisModel.get('tooltip');\n\t        return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n\t    }\n\t    /**\n\t     * @static\n\t     */\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n\t            var rawTick;\n\t            var scale = axis.scale;\n\t            return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n\t        };\n\t    /**\n\t     * @static\n\t     */\n\t    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n\t            var interval = model.get('interval');\n\t            if (interval == null || interval == 'auto') {\n\t                interval = labelInterval;\n\t            }\n\t            return interval;\n\t        };\n\t    return AxisBuilder;\n\t});\n\tdefine('zrender', ['zrender/zrender'], function (zrender) { return zrender;});\n\tdefine('echarts', ['echarts/echarts'], function (echarts) { return echarts;});\n\tvar echarts = require('echarts');\n\t\n\techarts.graphic = require('echarts/util/graphic');\n\techarts.number = require('echarts/util/number');\n\techarts.format = require('echarts/util/format');\n\t\n\t\n\trequire('echarts/chart/bar');\n\t\n\trequire('echarts/chart/pie');\n\t\n\t\n\trequire('echarts/component/grid');\n\t\n\trequire('echarts/component/title');\n\t\n\t\n\t\n\t\n\treturn echarts;\n\t}));\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/2.cdf123478cd95191923c.js","<template>\n    <div id=\"create\" v-if=\"!$loadingRouteData\">\n        <div class=\"quest\">\n            <div class=\"quest-title\">\n                <h2 v-text=\"questionnaire.title\" class=\"quest-title_preview\"></h2>\n            </div>\n            <div v-for=\"questItem in questionnaire.questItemList\" class=\"questItem-data\" track-by=\"$index\">\n                <div class=\"chart\" v-echarts=\"questItem\"></div>\n            </div>\n        </div>\n        <p class=\"preview-deadline\">{{new Date(questionnaire.deadline).toLocaleDateString()}}</p>\n    </div>\n</template>\n<script>\n    import echarts from '../echarts'\n\n    export default{\n        data() {\n            return {\n                typeMap: {\n                    radio: '',\n                    checkbox: '',\n                    textarea: ''\n                }\n            }\n        },\n        vuex: {\n            getters: {\n                questionnaire: state => state.currentQuestionnaire,\n                questionnaireList: state => state.questionnaireList\n            },\n            actions: {\n                setCurrentQuest({dispatch}, item) {\n                    dispatch(\"SET_QUEST\", item)\n                }\n            }\n        },\n        route: {\n            data({to, next}) {\n                let id = to.params.questId\n                if(!this.questionnaire) {\n                    this.questionnaireList.forEach(item => {\n                        if(parseInt(item.id) === parseInt(id)) {\n                            this.setCurrentQuest(item)\n                            return\n                        }\n                    })\n                }\n                // \n                next()\n            }\n        },\n        directives: {\n            'echarts': {\n                bind: function() {\n                    let self = this\n                    this.vm.$nextTick(function() {\n                        self.instance = echarts.init(self.el)\n                    })\n                },\n                update: function(newVal, oldVal) {\n                    let self = this\n                    let seriesData = []\n                    let option = {}\n                    // \n                    if(newVal.type !== 'textarea') {\n                        newVal.selections.forEach(item => {\n                            seriesData.push(parseInt(Math.random()*100))\n                        })\n                        option = {\n                            grid: {\n                                top: 40,\n                                bottom: 25\n                            },\n                            title: {\n                                text: self.vm.typeMap[newVal.type] + '.' +  newVal.title,\n                                textAlign: \"left\"\n                            },\n                            yAxis: {\n\n                            },\n                            xAxis: {\n                                data: newVal.selections\n                            },\n                            series:[{\n                                type: 'bar',\n                                data: seriesData\n                            }]\n                        }\n                    } else {\n                        seriesData.push(parseInt(Math.random()*100))\n                        seriesData.push(100 - seriesData[0])\n                        option = {\n                            title: {\n                                text: self.vm.typeMap[newVal.type] + '.' +  newVal.title,\n                                textAlign: \"left\"\n                            },\n                            series : [{\n                                type: 'pie',\n                                radius: \"60%\",\n                                data: [\n                                    {name: '', value: seriesData[0]},\n                                    {name: '', value: seriesData[1]}\n                                ]\n                            }]\n                        }\n                    }\n                    this.vm.$nextTick(function() {\n                        self.instance.setOption(option)\n                    })\n                    \n                },\n                unbind: function() {\n                    this.instance.dispose()\n                }\n            }\n        }\n    }\n</script>\n<style lang=\"less\">\n    #create{\n        .preview-deadline{\n            font-size: .14rem;\n            margin-top: .2rem;\n            text-align: center;\n        }\n        .quest-title_preview{\n            text-align: center;\n            letter-spacing: .05rem;\n            font-size: .28rem;\n            font-weight: bold;\n        }\n         .questItem-data{\n            margin: .1rem 0;\n            border: 1px solid #ccc;\n            border-radius: .03rem;\n        } \n        .chart{\n            min-height: 2rem;\n            width: 4rem;\n            margin: 0 auto;\n        }\n    }\n</style>\n\n\n\n\n// WEBPACK FOOTER //\n// Data.vue?42d7526c","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/Data.vue\"],\"names\":[],\"mappings\":\"AAAA,0BAA0B,iBAAiB,iBAAiB,iBAAiB,CAAC,6BAA6B,kBAAkB,sBAAsB,iBAAiB,eAAgB,CAAC,wBAAwB,eAAe,sBAAsB,oBAAoB,CAAC,eAAe,gBAAgB,WAAW,aAAa,CAAC\",\"file\":\"Data.vue\",\"sourcesContent\":[\"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:bold}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js!./~/less-loader?sourceMap!./~/vue-loader/lib/selector.js?type=style&index=0!./~/eslint-loader!./src/components/Data.vue\n// module id = 23\n// module chunks = 2","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js!../../node_modules/less-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/selector.js?type=style&index=0!../../node_modules/eslint-loader/index.js!./Data.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js!../../node_modules/less-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/selector.js?type=style&index=0!../../node_modules/eslint-loader/index.js!./Data.vue\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js!../../node_modules/less-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/selector.js?type=style&index=0!../../node_modules/eslint-loader/index.js!./Data.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js!./~/less-loader?sourceMap!./~/vue-loader/lib/selector.js?type=style&index=0!./~/eslint-loader!./src/components/Data.vue\n// module id = 27\n// module chunks = 2","module.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem-data track-by=$index> <div class=chart v-echarts=questItem></div> </div> </div> <p class=preview-deadline>{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-html-loader!./~/vue-loader/lib/selector.js?type=template&index=0!./~/eslint-loader!./src/components/Data.vue\n// module id = 34\n// module chunks = 2","var __vue_script__, __vue_template__\nvar __vue_styles__ = {}\nrequire(\"!!../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js!less-loader?sourceMap!../../node_modules/vue-loader/lib/selector.js?type=style&index=0!../../node_modules/eslint-loader/index.js!./Data.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!../../node_modules/vue-loader/lib/selector.js?type=script&index=0!../../node_modules/eslint-loader/index.js!./Data.vue\")\n__vue_template__ = require(\"!!vue-html-loader!../../node_modules/vue-loader/lib/selector.js?type=template&index=0!../../node_modules/eslint-loader/index.js!./Data.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nvar __vue_options__ = typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports\nif (__vue_template__) {\n__vue_options__.template = __vue_template__\n}\nif (!__vue_options__.computed) __vue_options__.computed = {}\nObject.keys(__vue_styles__).forEach(function (key) {\nvar module = __vue_styles__[key]\n__vue_options__.computed[key] = function () { return module }\n})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Data.vue\n// module id = 41\n// module chunks = 2","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.echarts = factory();\n    }\n}(this, function () {var require, define;\n(function () {\n    var mods = {};\n\n    define = function (id, deps, factory) {\n        mods[id] = {\n            id: id,\n            deps: deps,\n            factory: factory,\n            defined: 0,\n            exports: {},\n            require: createRequire(id)\n        };\n    };\n\n    require = createRequire('');\n\n    function normalize(id, baseId) {\n        if (!baseId) {\n            return id;\n        }\n\n        if (id.indexOf('.') === 0) {\n            var basePath = baseId.split('/');\n            var namePath = id.split('/');\n            var baseLen = basePath.length - 1;\n            var nameLen = namePath.length;\n            var cutBaseTerms = 0;\n            var cutNameTerms = 0;\n\n            pathLoop: for (var i = 0; i < nameLen; i++) {\n                switch (namePath[i]) {\n                    case '..':\n                        if (cutBaseTerms < baseLen) {\n                            cutBaseTerms++;\n                            cutNameTerms++;\n                        }\n                        else {\n                            break pathLoop;\n                        }\n                        break;\n                    case '.':\n                        cutNameTerms++;\n                        break;\n                    default:\n                        break pathLoop;\n                }\n            }\n\n            basePath.length = baseLen - cutBaseTerms;\n            namePath = namePath.slice(cutNameTerms);\n\n            return basePath.concat(namePath).join('/');\n        }\n\n        return id;\n    }\n\n    function createRequire(baseId) {\n        var cacheMods = {};\n\n        function localRequire(id, callback) {\n            if (typeof id === 'string') {\n                var exports = cacheMods[id];\n                if (!exports) {\n                    exports = getModExports(normalize(id, baseId));\n                    cacheMods[id] = exports;\n                }\n\n                return exports;\n            }\n            else if (id instanceof Array) {\n                callback = callback || function () {};\n                callback.apply(this, getModsExports(id, callback, baseId));\n            }\n        };\n\n        return localRequire;\n    }\n\n    function getModsExports(ids, factory, baseId) {\n        var es = [];\n        var mod = mods[baseId];\n\n        for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {\n            var id = normalize(ids[i], baseId);\n            var arg;\n            switch (id) {\n                case 'require':\n                    arg = (mod && mod.require) || require;\n                    break;\n                case 'exports':\n                    arg = mod.exports;\n                    break;\n                case 'module':\n                    arg = mod;\n                    break;\n                default:\n                    arg = getModExports(id);\n            }\n            es.push(arg);\n        }\n\n        return es;\n    }\n\n    function getModExports(id) {\n        var mod = mods[id];\n        if (!mod) {\n            throw new Error('No ' + id);\n        }\n\n        if (!mod.defined) {\n            var factory = mod.factory;\n            var factoryReturn = factory.apply(\n                this,\n                getModsExports(mod.deps || [], factory, id)\n            );\n            if (typeof factoryReturn !== 'undefined') {\n                mod.exports = factoryReturn;\n            }\n            mod.defined = 1;\n        }\n\n        return mod.exports;\n    }\n}());\ndefine('echarts/chart/pie', ['require', 'zrender/core/util', '../echarts', './pie/PieSeries', './pie/PieView', '../action/createDataSelectAction', '../visual/dataColor', './pie/pieLayout', '../processor/dataFilter'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var echarts = require('../echarts');\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n    require('../action/createDataSelectAction')('pie', [\n        {\n            type: 'pieToggleSelect',\n            event: 'pieselectchanged',\n            method: 'toggleSelected'\n        },\n        {\n            type: 'pieSelect',\n            event: 'pieselected',\n            method: 'select'\n        },\n        {\n            type: 'pieUnSelect',\n            event: 'pieunselected',\n            method: 'unSelect'\n        }\n    ]);\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n    echarts.registerLayout(zrUtil.curry(require('./pie/pieLayout'), 'pie'));\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n});\ndefine('echarts/chart/bar', ['require', 'zrender/core/util', '../coord/cartesian/Grid', './bar/BarSeries', './bar/BarView', '../layout/barGrid', '../echarts', '../component/grid'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    require('../coord/cartesian/Grid');\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n    // In case developer forget to include grid component\n    require('../component/grid');\n});\ndefine('echarts/component/title', ['require', '../echarts', '../util/graphic', '../util/layout'], function (require) {\n    'use strict';\n    var echarts = require('../echarts');\n    var graphic = require('../util/graphic');\n    var layout = require('../util/layout');\n    // Model\n    echarts.extendComponentModel({\n        type: 'title',\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n        defaultOption: {\n            zlevel: 0,\n            z: 6,\n            show: true,\n            text: '',\n            target: 'blank',\n            subtext: '',\n            subtarget: 'blank',\n            left: 0,\n            top: 0,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderColor: '#ccc',\n            borderWidth: 0,\n            padding: 5,\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: { color: '#aaa' }\n        }\n    });\n    // View\n    echarts.extendComponentView({\n        type: 'title',\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n            if (!titleModel.get('show')) {\n                return;\n            }\n            var group = this.group;\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n            var textEl = new graphic.Text({\n                    style: {\n                        text: titleModel.get('text'),\n                        textFont: textStyleModel.getFont(),\n                        fill: textStyleModel.getTextColor()\n                    },\n                    z2: 10\n                });\n            var textRect = textEl.getBoundingRect();\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                    style: {\n                        text: subText,\n                        textFont: subtextStyleModel.getFont(),\n                        fill: subtextStyleModel.getTextColor(),\n                        y: textRect.height + titleModel.get('itemGap'),\n                        textBaseline: 'top'\n                    },\n                    z2: 10\n                });\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding'));\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                } else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                } else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n                textBaseline = textBaseline || 'top';\n            }\n            group.attr('position', [\n                layoutRect.x,\n                layoutRect.y\n            ]);\n            var alignStyle = {\n                    textAlign: textAlign,\n                    textVerticalAlign: textBaseline\n                };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle([\n                    'color',\n                    'opacity'\n                ]);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                    shape: {\n                        x: groupRect.x - padding[3],\n                        y: groupRect.y - padding[0],\n                        width: groupRect.width + padding[1] + padding[3],\n                        height: groupRect.height + padding[0] + padding[2]\n                    },\n                    style: style,\n                    silent: true\n                });\n            graphic.subPixelOptimizeRect(rect);\n            group.add(rect);\n        }\n    });\n});\ndefine('echarts/component/grid', ['require', '../util/graphic', 'zrender/core/util', '../echarts', '../coord/cartesian/Grid', './axis'], function (require) {\n    'use strict';\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    var echarts = require('../echarts');\n    require('../coord/cartesian/Grid');\n    require('./axis');\n    // Grid view\n    echarts.extendComponentView({\n        type: 'grid',\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()),\n                    silent: true\n                }));\n            }\n        }\n    });\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n});\ndefine('echarts/scale/Time', ['require', 'zrender/core/util', '../util/number', '../util/format', './Interval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var IntervalScale = require('./Interval');\n    var intervalScaleProto = IntervalScale.prototype;\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return lo;\n    };\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n            type: 'time',\n            getLabel: function (val) {\n                var stepLvl = this._stepLvl;\n                var date = new Date(val);\n                return formatUtil.formatTime(stepLvl[0], date);\n            },\n            niceExtent: function (approxTickNum, fixMin, fixMax) {\n                var extent = this._extent;\n                // If extent start and end are same, expand them\n                if (extent[0] === extent[1]) {\n                    // Expand extent\n                    extent[0] -= ONE_DAY;\n                    extent[1] += ONE_DAY;\n                }\n                // If there are no data and extent are [Infinity, -Infinity]\n                if (extent[1] === -Infinity && extent[0] === Infinity) {\n                    var d = new Date();\n                    extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                    extent[0] = extent[1] - ONE_DAY;\n                }\n                this.niceTicks(approxTickNum);\n                // var extent = this._extent;\n                var interval = this._interval;\n                if (!fixMin) {\n                    extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n                }\n                if (!fixMax) {\n                    extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n                }\n            },\n            niceTicks: function (approxTickNum) {\n                approxTickNum = approxTickNum || 10;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                var approxInterval = span / approxTickNum;\n                var scaleLevelsLen = scaleLevels.length;\n                var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n                var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n                var interval = level[2];\n                // Same with interval scale if span is much larger than 1 year\n                if (level[0] === 'year') {\n                    var yearSpan = span / interval;\n                    // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                    // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                    var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n                    interval *= yearStep;\n                }\n                var niceExtent = [\n                        mathCeil(extent[0] / interval) * interval,\n                        mathFloor(extent[1] / interval) * interval\n                    ];\n                this._stepLvl = level;\n                // Interval will be used in getTicks\n                this._interval = interval;\n                this._niceExtent = niceExtent;\n            },\n            parse: function (val) {\n                // val might be float.\n                return +numberUtil.parseDate(val);\n            }\n        });\n    zrUtil.each([\n        'contain',\n        'normalize'\n    ], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n    // Steps from d3\n    var scaleLevels = [\n            [\n                'hh:mm:ss',\n                1,\n                ONE_SECOND\n            ],\n            [\n                'hh:mm:ss',\n                5,\n                ONE_SECOND * 5\n            ],\n            [\n                'hh:mm:ss',\n                10,\n                ONE_SECOND * 10\n            ],\n            [\n                'hh:mm:ss',\n                15,\n                ONE_SECOND * 15\n            ],\n            [\n                'hh:mm:ss',\n                30,\n                ONE_SECOND * 30\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                1,\n                ONE_MINUTE\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                5,\n                ONE_MINUTE * 5\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                10,\n                ONE_MINUTE * 10\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                15,\n                ONE_MINUTE * 15\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                30,\n                ONE_MINUTE * 30\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                1,\n                ONE_HOUR\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                2,\n                ONE_HOUR * 2\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                6,\n                ONE_HOUR * 6\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                12,\n                ONE_HOUR * 12\n            ],\n            [\n                'MM-dd\\nyyyy',\n                1,\n                ONE_DAY\n            ],\n            [\n                'week',\n                7,\n                ONE_DAY * 7\n            ],\n            [\n                'month',\n                1,\n                ONE_DAY * 31\n            ],\n            [\n                'quarter',\n                3,\n                ONE_DAY * 380 / 4\n            ],\n            [\n                'half-year',\n                6,\n                ONE_DAY * 380 / 2\n            ],\n            [\n                'year',\n                1,\n                ONE_DAY * 380\n            ]\n        ];\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n    return TimeScale;\n});\ndefine('echarts/echarts', ['require', 'zrender/core/env', './model/Global', './ExtensionAPI', './CoordinateSystem', './model/OptionManager', './model/Component', './model/Series', './view/Component', './view/Chart', './util/graphic', 'zrender', 'zrender/core/util', 'zrender/tool/color', 'zrender/mixin/Eventful', 'zrender/core/timsort', './visual/seriesColor', './preprocessor/backwardCompat', './loading/default', './data/List', './model/Model', './util/number', './util/format', 'zrender/core/matrix', 'zrender/core/vector'], function (require) {\n    var env = require('zrender/core/env');\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/core/util');\n    var colorTool = require('zrender/tool/color');\n    var Eventful = require('zrender/mixin/Eventful');\n    var timsort = require('zrender/core/timsort');\n    var each = zrUtil.each;\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    var PRIORITY_VISUAL_BRUSH = 5000;\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flag_in_main_process';\n    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n    var OPTION_UPDATED = '_optionUpdated';\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio\n        });\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n        Eventful.call(this);\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n        // Init mouse events\n        this._initEvents();\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n        this._zr.animation.on('frame', this._onframe, this);\n    }\n    var echartsProto = ECharts.prototype;\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            this[IN_MAIN_PROCESS] = true;\n            updateMethods.prepareAndUpdate.call(this);\n            this[IN_MAIN_PROCESS] = false;\n            this[OPTION_UPDATED] = false;\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n    /**\n     * @param {Object} option\n     * @param {boolean} notMerge\n     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n        this[IN_MAIN_PROCESS] = true;\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n        this._model.setOption(option, optionPreprocessorFuncs);\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = true;\n        } else {\n            updateMethods.prepareAndUpdate.call(this);\n            this._zr.refreshImmediately();\n            this[OPTION_UPDATED] = false;\n        }\n        this[IN_MAIN_PROCESS] = false;\n        this._flushPendingActions();\n    };\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({ mainType: componentType }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n        var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = opts && opts.pixelRatio || 1;\n            for (var id in instances) {\n                var chart = instances[id];\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            }\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                        style: {\n                            x: item.left * dpr - left,\n                            y: item.top * dpr - top,\n                            image: item.dom\n                        }\n                    });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        } else {\n            return this.getDataURL(opts);\n        }\n    };\n    var updateMethods = {\n            update: function (payload) {\n                // console.time && console.time('update');\n                var ecModel = this._model;\n                var api = this._api;\n                var coordSysMgr = this._coordSysMgr;\n                var zr = this._zr;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                // Fixme First time update ?\n                ecModel.restoreData();\n                // TODO\n                // Save total ecModel here for undo/redo (after restoring data and before processing data).\n                // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n                // Create new coordinate system each update\n                // In LineView may save the old coordinate system and use it to get the orignal point\n                coordSysMgr.create(this._model, this._api);\n                processData.call(this, ecModel, api);\n                stackSeriesData.call(this, ecModel);\n                coordSysMgr.update(ecModel, api);\n                doVisualEncoding.call(this, ecModel, payload);\n                doRender.call(this, ecModel, payload);\n                // Set background\n                var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n                var painter = zr.painter;\n                // TODO all use clearColor ?\n                if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                    zr.configLayer(0, { clearColor: backgroundColor });\n                } else {\n                    // In IE8\n                    if (!env.canvasSupported) {\n                        var colorArr = colorTool.parse(backgroundColor);\n                        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                        if (colorArr[3] === 0) {\n                            backgroundColor = 'transparent';\n                        }\n                    }\n                    if (backgroundColor.colorStops || backgroundColor.image) {\n                        // Gradient background\n                        // FIXME Fixed layer\n                        zr.configLayer(0, { clearColor: backgroundColor });\n                        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n                        this._dom.style.background = 'transparent';\n                    } else {\n                        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                            zr.configLayer(0, { clearColor: null });\n                        }\n                        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n                        this._dom.style.background = backgroundColor;\n                    }\n                }    // console.time && console.timeEnd('update');\n            },\n            updateView: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                ecModel.eachSeries(function (seriesModel) {\n                    seriesModel.getData().clearAllVisual();\n                });\n                doVisualEncoding.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n            },\n            updateVisual: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                ecModel.eachSeries(function (seriesModel) {\n                    seriesModel.getData().clearAllVisual();\n                });\n                doVisualEncoding.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n            },\n            updateLayout: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                doLayout.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n            },\n            highlight: function (payload) {\n                toggleHighlight.call(this, 'highlight', payload);\n            },\n            downplay: function (payload) {\n                toggleHighlight.call(this, 'downplay', payload);\n            },\n            prepareAndUpdate: function (payload) {\n                var ecModel = this._model;\n                prepareView.call(this, 'component', ecModel);\n                prepareView.call(this, 'chart', ecModel);\n                updateMethods.update.call(this, payload);\n            }\n        };\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    function toggleHighlight(method, payload) {\n        var ecModel = this._model;\n        // dispatchAction before setOption\n        if (!ecModel) {\n            return;\n        }\n        ecModel.eachComponent({\n            mainType: 'series',\n            query: payload\n        }, function (seriesModel, index) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            if (chartView && chartView.__alive) {\n                chartView[method](seriesModel, ecModel, this._api, payload);\n            }\n        }, this);\n    }\n    /**\n     * Resize the chart\n     */\n    echartsProto.resize = function () {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n        this[IN_MAIN_PROCESS] = true;\n        this._zr.resize();\n        var optionChanged = this._model && this._model.resetOption('media');\n        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n        this[IN_MAIN_PROCESS] = false;\n        this._flushPendingActions();\n    };\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (true) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n        zr.add(el);\n    };\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {boolean} [silent=false] Whether trigger event.\n     */\n    echartsProto.dispatchAction = function (payload, silent) {\n        var actionWrap = actions[payload.type];\n        if (!actionWrap) {\n            return;\n        }\n        var actionInfo = actionWrap.actionInfo;\n        var updateMethod = actionInfo.update || 'update';\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n        this[IN_MAIN_PROCESS] = true;\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n            // Highlight and downplay are special.\n            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n        }\n        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            } else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payload.type,\n                batch: eventObjBatch\n            };\n        } else {\n            eventObj = eventObjBatch[0];\n        }\n        this[IN_MAIN_PROCESS] = false;\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n        this._flushPendingActions();\n    };\n    echartsProto._flushPendingActions = function () {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            this.dispatchAction(payload);\n        }\n    };\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n            updateZ(componentModel, component);\n        }, this);\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n            updateZ(seriesModel, chart);\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            } else {\n                model = componentType;\n            }\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = ComponentModel.parseClassType(model.type);\n                var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                } else {\n                    // Error\n                    return;\n                }\n            }\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            } else {\n                i++;\n            }\n        }\n    }\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            visual.func(ecModel, api, payload);\n        });\n    }\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n            updateZ(componentModel, componentView);\n        }, this);\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n            chartView.group.silent = !!seriesModel.get('silent');\n            updateZ(seriesModel, chartView);\n            updateProgressiveAndBlend(seriesModel, chartView);\n        }, this);\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n    var MOUSE_EVENT_NAMES = [\n            'click',\n            'dblclick',\n            'mouseover',\n            'mouseout',\n            'mousemove',\n            'mousedown',\n            'mouseup',\n            'globalout'\n        ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }    // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    this.trigger(eveName, el.eventData);\n                }\n            }, this);\n        }, this);\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (true) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n        var api = this._api;\n        var ecModel = this._model;\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n        // Dispose after all views disposed\n        this._zr.dispose();\n        delete instances[this.id];\n    };\n    zrUtil.mixin(ECharts, Eventful);\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (true) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n    var instances = {};\n    var connectedGroups = {};\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n            version: '3.2.3',\n            dependencies: { zrender: '3.1.3' }\n        };\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n                    for (var id in instances) {\n                        var otherChart = instances[id];\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    }\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (true) {\n            // Check version\n            if (zrender.version.replace('.', '') - 0 < echarts.dependencies.zrender.replace('.', '') - 0) {\n                throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        enableConnect(chart);\n        return chart;\n    };\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || 'g_' + groupIdBase++;\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        } else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if (chart instanceof ECharts && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [\n                actionInfo,\n                actionInfo = { event: eventName }\n            ][0];\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n        if (!actions[actionType]) {\n            actions[actionType] = {\n                action: action,\n                actionInfo: actionInfo\n            };\n        }\n        eventActionMap[eventName] = actionType;\n    };\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n    var parseClassType = ComponentModel.parseClassType;\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts, superClass) {\n        var Clazz = ComponentModel;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts, superClass) {\n        var Clazz = ComponentView;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts, superClass) {\n        var Clazz = SeriesModel;\n        if (superClass) {\n            superClass = 'series.' + superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts, superClass) {\n        var Clazz = ChartView;\n        if (superClass) {\n            superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = ChartView.getClass(classType.main, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.matrix = require('zrender/core/matrix');\n    echarts.vector = require('zrender/core/vector');\n    echarts.color = require('zrender/tool/color');\n    echarts.util = {};\n    each([\n        'map',\n        'each',\n        'filter',\n        'indexOf',\n        'inherits',\n        'reduce',\n        'filter',\n        'bind',\n        'curry',\n        'isArray',\n        'isString',\n        'isObject',\n        'isFunction',\n        'extend',\n        'defaults'\n    ], function (name) {\n        echarts.util[name] = zrUtil[name];\n    });\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n    return echarts;\n});\ndefine('echarts/scale/Log', ['require', 'zrender/core/util', './Scale', '../util/number', './Interval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n    var mathLog = Math.log;\n    var LogScale = Scale.extend({\n            type: 'log',\n            base: 10,\n            getTicks: function () {\n                return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                    return numberUtil.round(mathPow(this.base, val));\n                }, this);\n            },\n            getLabel: intervalScaleProto.getLabel,\n            scale: function (val) {\n                val = scaleProto.scale.call(this, val);\n                return mathPow(this.base, val);\n            },\n            setExtent: function (start, end) {\n                var base = this.base;\n                start = mathLog(start) / mathLog(base);\n                end = mathLog(end) / mathLog(base);\n                intervalScaleProto.setExtent.call(this, start, end);\n            },\n            getExtent: function () {\n                var base = this.base;\n                var extent = scaleProto.getExtent.call(this);\n                extent[0] = mathPow(base, extent[0]);\n                extent[1] = mathPow(base, extent[1]);\n                return extent;\n            },\n            unionExtent: function (extent) {\n                var base = this.base;\n                extent[0] = mathLog(extent[0]) / mathLog(base);\n                extent[1] = mathLog(extent[1]) / mathLog(base);\n                scaleProto.unionExtent.call(this, extent);\n            },\n            niceTicks: function (approxTickNum) {\n                approxTickNum = approxTickNum || 10;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                if (span === Infinity || span <= 0) {\n                    return;\n                }\n                var interval = numberUtil.quantity(span);\n                var err = approxTickNum / span * interval;\n                // Filter ticks to get closer to the desired count.\n                if (err <= 0.5) {\n                    interval *= 10;\n                }\n                // Interval should be integer\n                while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                    interval *= 10;\n                }\n                var niceExtent = [\n                        numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                        numberUtil.round(mathFloor(extent[1] / interval) * interval)\n                    ];\n                this._interval = interval;\n                this._niceExtent = niceExtent;\n            },\n            niceExtent: intervalScaleProto.niceExtent\n        });\n    zrUtil.each([\n        'contain',\n        'normalize'\n    ], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n    LogScale.create = function () {\n        return new LogScale();\n    };\n    return LogScale;\n});\ndefine('echarts/chart/pie/PieView', ['require', '../../util/graphic', 'zrender/core/util', '../../view/Chart'], function (require) {\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n        data.each(function (idx) {\n            toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n        });\n    }\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [\n                dx * offset,\n                dy * offset\n            ];\n        hasAnimation ? el.animate().when(200, { position: position }).start('bounceOut') : el.attr('position', position);\n    }\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n        graphic.Group.call(this);\n        var sector = new graphic.Sector({ z2: 2 });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n        this.updateData(data, idx, true);\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n    }\n    var piePieceProto = PiePiece.prototype;\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))\n        };\n    }\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n        var sector = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n            sector.shape.endAngle = layout.startAngle;\n            graphic.updateProps(sector, { shape: { endAngle: layout.endAngle } }, seriesModel, idx);\n        } else {\n            graphic.updateProps(sector, { shape: sectorShape }, seriesModel, idx);\n        }\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n        sector.useStyle(zrUtil.defaults({\n            lineJoin: 'bevel',\n            fill: visualColor\n        }, itemStyleModel.getModel('normal').getItemStyle()));\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n        // Toggle selected\n        toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({ shape: { r: layout.r + 10 } }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({ shape: { r: layout.r } }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n            sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n        }\n        this._updateLabel(data, idx);\n        graphic.setHoverStyle(this);\n    };\n    piePieceProto._updateLabel = function (data, idx) {\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ],\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ],\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ]\n                ]\n            }\n        }, seriesModel, idx);\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [\n                labelLayout.x,\n                labelLayout.y\n            ],\n            z2: 10\n        });\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({ smooth: smooth });\n    };\n    zrUtil.inherits(PiePiece, graphic.Group);\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n            type: 'pie',\n            init: function () {\n                var sectorGroup = new graphic.Group();\n                this._sectorGroup = sectorGroup;\n            },\n            render: function (seriesModel, ecModel, api, payload) {\n                if (payload && payload.from === this.uid) {\n                    return;\n                }\n                var data = seriesModel.getData();\n                var oldData = this._data;\n                var group = this.group;\n                var hasAnimation = ecModel.get('animation');\n                var isFirstRender = !oldData;\n                var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n                var selectedMode = seriesModel.get('selectedMode');\n                data.diff(oldData).add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    if (isFirstRender) {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    data.setItemGraphicEl(idx, piePiece);\n                    group.add(piePiece);\n                }).update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n                    piePiece.updateData(data, newIdx);\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                }).remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                }).execute();\n                if (hasAnimation && isFirstRender && data.count() > 0) {\n                    var shape = data.getItemLayout(0);\n                    var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n                    var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                    group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n                }\n                this._data = data;\n            },\n            _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n                var clipPath = new graphic.Sector({\n                        shape: {\n                            cx: cx,\n                            cy: cy,\n                            r0: 0,\n                            r: r,\n                            startAngle: startAngle,\n                            endAngle: startAngle,\n                            clockwise: clockwise\n                        }\n                    });\n                graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb);\n                return clipPath;\n            }\n        });\n    return Pie;\n});\ndefine('echarts/chart/pie/PieSeries', ['require', '../../data/List', 'zrender/core/util', '../../util/model', '../../data/helper/completeDimensions', '../../component/helper/selectableMixin', '../../echarts'], function (require) {\n    'use strict';\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n    var PieSeries = require('../../echarts').extendSeriesModel({\n            type: 'series.pie',\n            init: function (option) {\n                PieSeries.superApply(this, 'init', arguments);\n                // Enable legend selection for each data item\n                // Use a function instead of direct access because data reference may changed\n                this.legendDataProvider = function () {\n                    return this._dataBeforeProcessed;\n                };\n                this.updateSelectedMap(option.data);\n                this._defaultLabelLine(option);\n            },\n            mergeOption: function (newOption) {\n                PieSeries.superCall(this, 'mergeOption', newOption);\n                this.updateSelectedMap(this.option.data);\n            },\n            getInitialData: function (option, ecModel) {\n                var dimensions = completeDimensions(['value'], option.data);\n                var list = new List(dimensions, this);\n                list.initData(option.data);\n                return list;\n            },\n            getDataParams: function (dataIndex) {\n                var data = this._data;\n                var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n                var sum = data.getSum('value');\n                // FIXME toFixed?\n                //\n                // Percent is 0 if sum is 0\n                params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n                params.$vars.push('percent');\n                return params;\n            },\n            _defaultLabelLine: function (option) {\n                // Extend labelLine emphasis\n                modelUtil.defaultEmphasis(option.labelLine, ['show']);\n                var labelLineNormalOpt = option.labelLine.normal;\n                var labelLineEmphasisOpt = option.labelLine.emphasis;\n                // Not show label line if `label.normal.show = false`\n                labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;\n                labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;\n            },\n            defaultOption: {\n                zlevel: 0,\n                z: 2,\n                legendHoverLink: true,\n                hoverAnimation: true,\n                center: [\n                    '50%',\n                    '50%'\n                ],\n                radius: [\n                    0,\n                    '75%'\n                ],\n                clockwise: true,\n                startAngle: 90,\n                minAngle: 0,\n                selectedOffset: 10,\n                avoidLabelOverlap: true,\n                label: {\n                    normal: {\n                        rotate: false,\n                        show: true,\n                        position: 'outer'\n                    },\n                    emphasis: {}\n                },\n                labelLine: {\n                    normal: {\n                        show: true,\n                        length: 15,\n                        length2: 15,\n                        smooth: false,\n                        lineStyle: {\n                            width: 1,\n                            type: 'solid'\n                        }\n                    }\n                },\n                itemStyle: {\n                    normal: { borderWidth: 1 },\n                    emphasis: {}\n                },\n                animationEasing: 'cubicOut',\n                data: []\n            }\n        });\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n    return PieSeries;\n});\ndefine('echarts/action/createDataSelectAction', ['require', '../echarts', 'zrender/core/util'], function (require) {\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/core/util');\n    return function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent({\n                    mainType: 'series',\n                    subType: seriesType,\n                    query: payload\n                }, function (seriesModel) {\n                    if (seriesModel[actionInfo.method]) {\n                        seriesModel[actionInfo.method](payload.name);\n                    }\n                    var data = seriesModel.getData();\n                    // Create selected map\n                    data.each(function (idx) {\n                        var name = data.getName(idx);\n                        selected[name] = seriesModel.isSelected(name) || false;\n                    });\n                });\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n});\ndefine('zrender/core/util', ['require'], function (require) {\n    // mergeDate\n    var BUILTIN_OBJECT = {\n            '[object Function]': 1,\n            '[object RegExp]': 1,\n            '[object Date]': 1,\n            '[object Error]': 1,\n            '[object CanvasGradient]': 1,\n            '[object CanvasPattern]': 1,\n            '[object Image]': 1\n        };\n    var objToString = Object.prototype.toString;\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n    /**\n     * @param {*} source\n     * @return {*} \n     */\n    function clone(source) {\n        if (typeof source == 'object' && source !== null) {\n            var result = source;\n            if (source instanceof Array) {\n                result = [];\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            } else if (!isBuildInObject(source) && !isDom(source)) {\n                result = {};\n                for (var key in source) {\n                    if (source.hasOwnProperty(key)) {\n                        result[key] = clone(source[key]);\n                    }\n                }\n            }\n            return result;\n        }\n        return source;\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n                if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                } else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n        return target;\n    }\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {\n        }\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n        defaults(target, source, overlay);\n    }\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (!data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        } else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        } else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        } else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        } else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || !!value && type == 'object';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return value && value.nodeType === 1 && typeof value.nodeName == 'string';\n    }\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n    var util = {\n            inherits: inherits,\n            mixin: mixin,\n            clone: clone,\n            merge: merge,\n            mergeAll: mergeAll,\n            extend: extend,\n            defaults: defaults,\n            getContext: getContext,\n            createCanvas: createCanvas,\n            indexOf: indexOf,\n            slice: slice,\n            find: find,\n            isArrayLike: isArrayLike,\n            each: each,\n            map: map,\n            reduce: reduce,\n            filter: filter,\n            bind: bind,\n            curry: curry,\n            isArray: isArray,\n            isString: isString,\n            isObject: isObject,\n            isFunction: isFunction,\n            isBuildInObject: isBuildInObject,\n            isDom: isDom,\n            retrieve: retrieve,\n            assert: assert,\n            noop: function () {\n            }\n        };\n    return util;\n});\ndefine('echarts/visual/dataColor', ['require'], function (require) {\n    return function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    // FIXME Performance\n                    var itemModel = dataAll.getItemModel(rawIdx);\n                    var filteredIdx = idxMap[rawIdx];\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n                    if (!singleDataColor) {\n                        var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    } else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n});\ndefine('echarts/chart/pie/pieLayout', ['require', '../../util/number', './labelLayout', 'zrender/core/util'], function (require) {\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/core/util');\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n    return function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n            if (!zrUtil.isArray(radius)) {\n                radius = [\n                    0,\n                    radius\n                ];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [\n                    center,\n                    center\n                ];\n            }\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n            var data = seriesModel.getData();\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n            var clockwise = seriesModel.get('clockwise');\n            var roseType = seriesModel.get('roseType');\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n            var currentAngle = startAngle;\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = sum === 0 ? unitRadian : value * unitRadian;\n                } else {\n                    angle = PI2 / (data.count() || 1);\n                }\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                } else {\n                    valueSumLargerThanMinAngle += value;\n                }\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType ? numberUtil.linearMap(value, extent, [\n                        r0,\n                        r\n                    ]) : r\n                });\n                currentAngle = endAngle;\n            }, true);\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 0.001) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                } else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += angle;\n                    });\n                }\n            }\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n});\ndefine('echarts/processor/dataFilter', [], function () {\n    return function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({ mainType: 'legend' });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n});\ndefine('echarts/coord/cartesian/Grid', ['require', 'exports', '../../util/layout', '../../coord/axisHelper', 'zrender/core/util', './Cartesian2D', './Axis2D', './GridModel', '../../CoordinateSystem'], function (require, factory) {\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n    var zrUtil = require('zrender/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n    var each = zrUtil.each;\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n    //  GridModel, AxisModel \n    require('./GridModel');\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.findGridModel() === gridModel;\n    }\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = axisModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : rect = singleRect;\n            }\n        }\n        return rect;\n    }\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n        this._initCartesian(gridModel, ecModel, api);\n        this._model = gridModel;\n    }\n    var gridProto = Grid.prototype;\n    gridProto.type = 'grid';\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n    gridProto.update = function (ecModel, api) {\n        var axesMap = this._axesMap;\n        this._updateScale(ecModel, this._model);\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                var axis = axes[idx];\n                if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n        var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        this._rect = gridRect;\n        var axesList = this._axesList;\n        adjustAxes();\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        } else if (axis.position === 'left') {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n            adjustAxes();\n        }\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [\n                        0,\n                        gridRect.width\n                    ] : [\n                        0,\n                        gridRect.height\n                    ];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    return axesMapOnDim[name];\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        } else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n                left: false,\n                right: false,\n                top: false,\n                bottom: false\n            };\n        var axesMap = {\n                x: {},\n                y: {}\n            };\n        var axesCount = {\n                x: 0,\n                y: 0\n            };\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n        this._axesMap = axesMap;\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n                cartesian.grid = this;\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                } else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n                var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [\n                        0,\n                        0\n                    ], axisModel.get('type'), axisPosition);\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n                axis.onZero = axisModel.get('axisLine.onZero');\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n                // Inject axisModel into axis\n                axis.model = axisModel;\n                // Inject grid info axis\n                axis.grid = this;\n                // Index of axis, can be used as key\n                axis.index = idx;\n                this._axesList.push(axis);\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n                    return;\n                }\n                var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));\n            });\n        }\n    };\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n            return coord + coordBase;\n        } : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n        axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n            return coord - coordBase;\n        } : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n    }\n    var axesTypes = [\n            'xAxis',\n            'yAxis'\n        ];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = ecModel.queryComponents({\n                    mainType: axisType,\n                    index: seriesModel.get(axisType + 'Index'),\n                    id: seriesModel.get(axisType + 'Id')\n                })[0];\n            if (true) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n            gridModel.coordinateSystem = grid;\n            grids.push(grid);\n        });\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n            var gridModel = xAxisModel.findGridModel();\n            if (true) {\n                if (!gridModel) {\n                    throw new Error('Grid \"' + zrUtil.retrieve(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n                }\n                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n            var grid = gridModel.coordinateSystem;\n            seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        });\n        return grids;\n    };\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n    return Grid;\n});\ndefine('echarts/chart/bar/BarSeries', ['require', '../../model/Series', '../helper/createListFromArray'], function (require) {\n    'use strict';\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n    return SeriesModel.extend({\n        type: 'series.bar',\n        dependencies: [\n            'grid',\n            'polar'\n        ],\n        getInitialData: function (option, ecModel) {\n            if (true) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [\n                NaN,\n                NaN\n            ];\n        },\n        brushSelector: 'rect',\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            barMinHeight: 0,\n            itemStyle: {\n                normal: {},\n                emphasis: {}\n            }\n        }\n    });\n});\ndefine('echarts/chart/bar/BarView', ['require', 'zrender/core/util', '../../util/graphic', '../../model/Model', './barItemStyle', '../../echarts'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var graphic = require('../../util/graphic');\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n    function fixLayoutWithLineWidth(layout, lineWidth) {\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        // In case width or height are too small.\n        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n        layout.x += signX * lineWidth / 2;\n        layout.y += signY * lineWidth / 2;\n        layout.width -= signX * lineWidth;\n        layout.height -= signY * lineWidth;\n    }\n    return require('../../echarts').extendChartView({\n        type: 'bar',\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n            return this.group;\n        },\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n            var enableAnimation = seriesModel.get('animation');\n            var barBorderWidthQuery = [\n                    'itemStyle',\n                    'normal',\n                    'barBorderWidth'\n                ];\n            function createRect(dataIndex, isUpdate) {\n                var layout = data.getItemLayout(dataIndex);\n                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n                var rect = new graphic.Rect({ shape: zrUtil.extend({}, layout) });\n                // Animation\n                if (enableAnimation) {\n                    var rectShape = rect.shape;\n                    var animateProperty = isHorizontal ? 'height' : 'width';\n                    var animateTarget = {};\n                    rectShape[animateProperty] = 0;\n                    animateTarget[animateProperty] = layout[animateProperty];\n                    graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, seriesModel, dataIndex);\n                }\n                return rect;\n            }\n            data.diff(oldData).add(function (dataIndex) {\n                // \n                if (!data.hasValue(dataIndex)) {\n                    return;\n                }\n                var rect = createRect(dataIndex);\n                data.setItemGraphicEl(dataIndex, rect);\n                group.add(rect);\n            }).update(function (newIndex, oldIndex) {\n                var rect = oldData.getItemGraphicEl(oldIndex);\n                // \n                if (!data.hasValue(newIndex)) {\n                    group.remove(rect);\n                    return;\n                }\n                if (!rect) {\n                    rect = createRect(newIndex, true);\n                }\n                var layout = data.getItemLayout(newIndex);\n                var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n                graphic.updateProps(rect, { shape: layout }, seriesModel, newIndex);\n                data.setItemGraphicEl(newIndex, rect);\n                // Add back\n                group.add(rect);\n            }).remove(function (idx) {\n                var rect = oldData.getItemGraphicEl(idx);\n                if (rect) {\n                    // Not show text when animating\n                    rect.style.text = '';\n                    graphic.updateProps(rect, { shape: { width: 0 } }, seriesModel, idx, function () {\n                        group.remove(rect);\n                    });\n                }\n            }).execute();\n            this._updateStyle(seriesModel, data, isHorizontal);\n            this._data = data;\n        },\n        _updateStyle: function (seriesModel, data, isHorizontal) {\n            function setLabel(style, model, color, labelText, labelPositionOutside) {\n                graphic.setText(style, model, color);\n                style.text = labelText;\n                if (style.textPosition === 'outside') {\n                    style.textPosition = labelPositionOutside;\n                }\n            }\n            data.eachItemGraphicEl(function (rect, idx) {\n                var itemModel = data.getItemModel(idx);\n                var color = data.getItemVisual(idx, 'color');\n                var opacity = data.getItemVisual(idx, 'opacity');\n                var layout = data.getItemLayout(idx);\n                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n                rect.useStyle(zrUtil.defaults({\n                    fill: color,\n                    opacity: opacity\n                }, itemStyleModel.getBarItemStyle()));\n                var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n                var labelModel = itemModel.getModel('label.normal');\n                var hoverLabelModel = itemModel.getModel('label.emphasis');\n                var rectStyle = rect.style;\n                if (labelModel.get('show')) {\n                    setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);\n                } else {\n                    rectStyle.text = '';\n                }\n                if (hoverLabelModel.get('show')) {\n                    setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);\n                } else {\n                    hoverStyle.text = '';\n                }\n                graphic.setHoverStyle(rect, hoverStyle);\n            });\n        },\n        remove: function (ecModel, api) {\n            var group = this.group;\n            if (ecModel.get('animation')) {\n                if (this._data) {\n                    this._data.eachItemGraphicEl(function (el) {\n                        // Not show text when animating\n                        el.style.text = '';\n                        graphic.updateProps(el, { shape: { width: 0 } }, ecModel, el.dataIndex, function () {\n                            group.remove(el);\n                        });\n                    });\n                }\n            } else {\n                group.removeAll();\n            }\n        }\n    });\n});\ndefine('echarts/layout/barGrid', ['require', 'zrender/core/util', '../util/number'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                    bandWidth: bandWidth,\n                    remainedWidth: bandWidth,\n                    autoWidthCount: 0,\n                    categoryGap: '20%',\n                    gap: '30%',\n                    stacks: {}\n                };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n            var stackId = getSeriesStackId(seriesModel);\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n            var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n            var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            barGap != null && (columnsOnAxis.gap = barGap);\n            barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n        var result = {};\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n            result[coordSysName] = {};\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n        return result;\n    }\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n        var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n                return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n            }));\n        var lastStackCoords = {};\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n            var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n            data.each(valueAxis.dim, function (value, idx) {\n                // \n                if (isNaN(value)) {\n                    return;\n                }\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart,\n                        n: valueAxisStart\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var x, y, width, height;\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoord;\n                    height = columnWidth;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                } else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoord;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n        }, this);\n    }\n    return barLayoutGrid;\n});\ndefine('echarts/util/graphic', ['require', 'zrender/core/util', 'zrender/tool/path', 'zrender/graphic/Path', 'zrender/tool/color', 'zrender/core/matrix', 'zrender/core/vector', 'zrender/graphic/Gradient', 'zrender/container/Group', 'zrender/graphic/Image', 'zrender/graphic/Text', 'zrender/graphic/shape/Circle', 'zrender/graphic/shape/Sector', 'zrender/graphic/shape/Ring', 'zrender/graphic/shape/Polygon', 'zrender/graphic/shape/Polyline', 'zrender/graphic/shape/Rect', 'zrender/graphic/shape/Line', 'zrender/graphic/shape/BezierCurve', 'zrender/graphic/shape/Arc', 'zrender/graphic/CompoundPath', 'zrender/graphic/LinearGradient', 'zrender/graphic/RadialGradient', 'zrender/core/BoundingRect'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var pathTool = require('zrender/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/graphic/Path');\n    var colorTool = require('zrender/tool/color');\n    var matrix = require('zrender/core/matrix');\n    var vector = require('zrender/core/vector');\n    var Gradient = require('zrender/graphic/Gradient');\n    var graphic = {};\n    graphic.Group = require('zrender/container/Group');\n    graphic.Image = require('zrender/graphic/Image');\n    graphic.Text = require('zrender/graphic/Text');\n    graphic.Circle = require('zrender/graphic/shape/Circle');\n    graphic.Sector = require('zrender/graphic/shape/Sector');\n    graphic.Ring = require('zrender/graphic/shape/Ring');\n    graphic.Polygon = require('zrender/graphic/shape/Polygon');\n    graphic.Polyline = require('zrender/graphic/shape/Polyline');\n    graphic.Rect = require('zrender/graphic/shape/Rect');\n    graphic.Line = require('zrender/graphic/shape/Line');\n    graphic.BezierCurve = require('zrender/graphic/shape/BezierCurve');\n    graphic.Arc = require('zrender/graphic/shape/Arc');\n    graphic.CompoundPath = require('zrender/graphic/CompoundPath');\n    graphic.LinearGradient = require('zrender/graphic/LinearGradient');\n    graphic.RadialGradient = require('zrender/graphic/RadialGradient');\n    graphic.BoundingRect = require('zrender/core/BoundingRect');\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                } else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n            this.resizePath(path, rect);\n        }\n        return path;\n    };\n    graphic.mergePath = pathTool.mergePath, graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n        var pathRect = path.getBoundingRect();\n        var m = pathRect.calculateTransform(rect);\n        path.applyTransform(m);\n    };\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n        shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n        return param;\n    };\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n            el.__normalStl = normalStyle;\n            el.__hoverStlDirty = false;\n        }\n    }\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n        cacheElementStl(el);\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        } else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n        el.__isHover = true;\n    }\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        } else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n        el.__isHover = false;\n    }\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleEnterHover(child);\n            }\n        }) : doSingleEnterHover(el);\n    }\n    function doLeaveHover(el) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleLeaveHover(child);\n            }\n        }) : doSingleLeaveHover(el);\n    }\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n    /**\n     * @inner\n     */\n    function onElementMouseOver() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n    /**\n     * @inner\n     */\n    function onElementMouseOut() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     */\n    graphic.setHoverStyle = function (el, hoverStyle) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                setElementHoverStl(child, hoverStyle);\n            }\n        }) : setElementHoverStl(el, hoverStyle);\n        // Remove previous bound handlers\n        el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n    };\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        var animationEnabled = animatableModel && (animatableModel.ifEnableAnimation ? animatableModel.ifEnableAnimation() : animatableModel.getShallow('animation'));\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel && animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(dataIndex);\n            }\n            duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb) : (el.attr(props), cb && cb());\n        } else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n        return mat;\n    };\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n        var vertex = [\n                direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n                direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n            ];\n        vertex = graphic.applyTransform(vertex, transform, invert);\n        return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n    };\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                    position: vector.clone(el.position),\n                    rotation: el.rotation\n                };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }    // else {\n                     //     if (el.previousProps) {\n                     //         graphic.updateProps\n                     //     }\n                     // }\n            }\n        });\n    };\n    return graphic;\n});\ndefine('echarts/component/axis', ['require', '../coord/cartesian/AxisModel', './axis/AxisView'], function (require) {\n    'use strict';\n    require('../coord/cartesian/AxisModel');\n    require('./axis/AxisView');\n});\ndefine('echarts/util/layout', ['require', 'zrender/core/util', 'zrender/core/BoundingRect', './number', './format'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var BoundingRect = require('zrender/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n    var layout = {};\n    var LOCATION_PARAMS = [\n            'left',\n            'right',\n            'top',\n            'bottom',\n            'width',\n            'height'\n        ];\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                } else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            } else {\n                var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                } else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n            if (child.newline) {\n                return;\n            }\n            position[0] = x;\n            position[1] = y;\n            orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n        });\n    }\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n        margin = formatUtil.normalizeCssArray(margin || 0);\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            } else {\n                height = containerHeight * 0.8;\n            }\n        }\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n        case 'center':\n            left = containerWidth / 2 - width / 2 - margin[3];\n            break;\n        case 'right':\n            left = containerWidth - width - horizontalMargin;\n            break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n        case 'middle':\n        case 'center':\n            top = containerHeight / 2 - height / 2 - margin[0];\n            break;\n        case 'bottom':\n            top = containerHeight - height - verticalMargin;\n            break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n    /**\n     * Position group of component in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     */\n    layout.positionGroup = function (group, positionInfo, containerRect, margin) {\n        var groupRect = group.getBoundingRect();\n        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n            width: groupRect.width,\n            height: groupRect.height\n        });\n        positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);\n        group.attr('position', [\n            positionInfo.x - groupRect.x,\n            positionInfo.y - groupRect.y\n        ]);\n    };\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = [\n                'width',\n                'left',\n                'right'\n            ];\n        // Order by priority.\n        var vNames = [\n                'height',\n                'top',\n                'bottom'\n            ];\n        // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }    // Case: newOption: {width: ..., right: ...},\n                 // Than we can make sure user only want those two, and ignore\n                 // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            } else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n    return layout;\n});\ndefine('echarts/util/number', ['require'], function (require) {\n    var number = {};\n    var RADIAN_EPSILON = 0.0001;\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n        if (subDomain === 0) {\n            return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n        }\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                } else if (val >= domain[1]) {\n                    return range[1];\n                }\n            } else {\n                if (val >= domain[0]) {\n                    return range[0];\n                } else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        } else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function (percent, all) {\n        switch (percent) {\n        case 'center':\n        case 'middle':\n            percent = '50%';\n            break;\n        case 'left':\n        case 'top':\n            percent = '0%';\n            break;\n        case 'right':\n        case 'bottom':\n            percent = '100%';\n            break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n            return parseFloat(percent);\n        }\n        return percent == null ? NaN : +percent;\n    };\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // PENDING\n        return +(+x).toFixed(precision);\n    };\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n    /**\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number}  precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        return Math.max(-dataQuantity + sizeQuantity, 0);\n    };\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        } else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n        return new Date(Math.round(value));\n    };\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10;\n        // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) {\n                nf = 1;\n            } else if (f < 2.5) {\n                nf = 2;\n            } else if (f < 4) {\n                nf = 3;\n            } else if (f < 7) {\n                nf = 5;\n            } else {\n                nf = 10;\n            }\n        } else {\n            if (f < 1) {\n                nf = 1;\n            } else if (f < 2) {\n                nf = 2;\n            } else if (f < 3) {\n                nf = 3;\n            } else if (f < 5) {\n                nf = 5;\n            } else {\n                nf = 10;\n            }\n        }\n        return nf * exp10;\n    };\n    return number;\n});\ndefine('echarts/util/format', ['require', 'zrender/core/util', './number', 'zrender/contain/text'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/contain/text');\n    var formatUtil = {};\n    /**\n     * ,\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n    };\n    /**\n     * @param {string} str\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str) {\n        return str.toLowerCase().replace(/-(.)/g, function (match, group1) {\n            return group1.toUpperCase();\n        });\n    };\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof val === 'number') {\n            return [\n                val,\n                val,\n                val,\n                val\n            ];\n        } else if (len === 2) {\n            // vertical | horizontal\n            return [\n                val[0],\n                val[1],\n                val[0],\n                val[1]\n            ];\n        } else if (len === 3) {\n            // top | horizontal | bottom\n            return [\n                val[0],\n                val[1],\n                val[2],\n                val[1]\n            ];\n        }\n        return val;\n    };\n    formatUtil.encodeHTML = function (source) {\n        return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n    };\n    var TPL_VAR_ALIAS = [\n            'a',\n            'b',\n            'c',\n            'd',\n            'e',\n            'f',\n            'g'\n        ];\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n    /**\n     * Template formatter\n     * @param  {string} tpl\n     * @param  {Array.<Object>|Object} paramsList\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);\n            }\n        }\n        return tpl;\n    };\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? '0' + str : str;\n    };\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n            tpl = 'MM-dd\\nyyyy';\n        }\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n        tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n        return tpl;\n    };\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n    formatUtil.truncateText = textContain.truncateText;\n    return formatUtil;\n});\ndefine('echarts/scale/Interval', ['require', '../util/number', '../util/format', './Scale'], function (require) {\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n            type: 'interval',\n            _interval: 0,\n            setExtent: function (start, end) {\n                var thisExtent = this._extent;\n                //start,end may be a Number like '25',so...\n                if (!isNaN(start)) {\n                    thisExtent[0] = parseFloat(start);\n                }\n                if (!isNaN(end)) {\n                    thisExtent[1] = parseFloat(end);\n                }\n            },\n            unionExtent: function (other) {\n                var extent = this._extent;\n                other[0] < extent[0] && (extent[0] = other[0]);\n                other[1] > extent[1] && (extent[1] = other[1]);\n                // unionExtent may called by it's sub classes\n                IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n            },\n            getInterval: function () {\n                if (!this._interval) {\n                    this.niceTicks();\n                }\n                return this._interval;\n            },\n            setInterval: function (interval) {\n                this._interval = interval;\n                // Dropped auto calculated niceExtent and use user setted extent\n                // We assume user wan't to set both interval, min, max to get a better result\n                this._niceExtent = this._extent.slice();\n            },\n            getTicks: function () {\n                if (!this._interval) {\n                    this.niceTicks();\n                }\n                var interval = this._interval;\n                var extent = this._extent;\n                var ticks = [];\n                // Consider this case: using dataZoom toolbox, zoom and zoom.\n                var safeLimit = 10000;\n                if (interval) {\n                    var niceExtent = this._niceExtent;\n                    var precision = getPrecisionSafe(interval) + 2;\n                    if (extent[0] < niceExtent[0]) {\n                        ticks.push(extent[0]);\n                    }\n                    var tick = niceExtent[0];\n                    while (tick <= niceExtent[1]) {\n                        ticks.push(tick);\n                        // Avoid rounding error\n                        tick = roundingErrorFix(tick + interval, precision);\n                        if (ticks.length > safeLimit) {\n                            return [];\n                        }\n                    }\n                    if (extent[1] > niceExtent[1]) {\n                        ticks.push(extent[1]);\n                    }\n                }\n                return ticks;\n            },\n            getTicksLabels: function () {\n                var labels = [];\n                var ticks = this.getTicks();\n                for (var i = 0; i < ticks.length; i++) {\n                    labels.push(this.getLabel(ticks[i]));\n                }\n                return labels;\n            },\n            getLabel: function (data) {\n                return formatUtil.addCommas(data);\n            },\n            niceTicks: function (splitNumber) {\n                splitNumber = splitNumber || 5;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                if (!isFinite(span)) {\n                    return;\n                }\n                // User may set axis min 0 and data are all negative\n                // FIXME If it needs to reverse ?\n                if (span < 0) {\n                    span = -span;\n                    extent.reverse();\n                }\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceSpan = numberUtil.nice(span, false);\n                var step = roundingErrorFix(numberUtil.nice(span / splitNumber, true), Math.max(getPrecisionSafe(extent[0]), getPrecisionSafe(extent[1])) + 2);\n                var precision = getPrecisionSafe(step) + 2;\n                // Niced extent inside original extent\n                var niceExtent = [\n                        roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                        roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n                    ];\n                this._interval = step;\n                this._niceExtent = niceExtent;\n            },\n            niceExtent: function (splitNumber, fixMin, fixMax) {\n                var extent = this._extent;\n                // If extent start and end are same, expand them\n                if (extent[0] === extent[1]) {\n                    if (extent[0] !== 0) {\n                        // Expand extent\n                        var expandSize = extent[0];\n                        // In the fowllowing case\n                        //      Axis has been fixed max 100\n                        //      Plus data are all 100 and axis extent are [100, 100].\n                        // Extend to the both side will cause expanded max is larger than fixed max.\n                        // So only expand to the smaller side.\n                        if (!fixMax) {\n                            extent[1] += expandSize / 2;\n                            extent[0] -= expandSize / 2;\n                        } else {\n                            extent[0] -= expandSize / 2;\n                        }\n                    } else {\n                        extent[1] = 1;\n                    }\n                }\n                var span = extent[1] - extent[0];\n                // If there are no data and extent are [Infinity, -Infinity]\n                if (!isFinite(span)) {\n                    extent[0] = 0;\n                    extent[1] = 1;\n                }\n                this.niceTicks(splitNumber);\n                // var extent = this._extent;\n                var interval = this._interval;\n                if (!fixMin) {\n                    extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n                }\n                if (!fixMax) {\n                    extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n                }\n            }\n        });\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n    return IntervalScale;\n});\ndefine('zrender/core/env', [], function () {\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            canvasSupported: true\n        };\n    } else {\n        env = detect(navigator.userAgent);\n    }\n    return env;\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/) || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/);\n        // IE 12 and 12+\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox)\n            browser.firefox = true, browser.version = firefox[1];\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            canvasSupported: document.createElement('canvas').getContext ? true : false,\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 10)\n        };\n    }\n});\ndefine('echarts/ExtensionAPI', ['require', 'zrender/core/util'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var echartsAPIList = [\n            'getDom',\n            'getZr',\n            'getWidth',\n            'getHeight',\n            'dispatchAction',\n            'isDisposed',\n            'on',\n            'off',\n            'getDataURL',\n            'getConnectedDataURL',\n            'getModel',\n            'getOption'\n        ];\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n    return ExtensionAPI;\n});\ndefine('echarts/model/Global', ['require', 'zrender/core/util', '../util/model', './Model', './Component', './globalDefault', './mixin/colorPalette'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n    var ComponentModel = require('./Component');\n    var globalDefault = require('./globalDefault');\n    var OPTION_INNER_KEY = '\u0000_ec_inner';\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n            constructor: GlobalModel,\n            init: function (option, parentModel, theme, optionManager) {\n                theme = theme || {};\n                this.option = null;\n                // Mark as not initialized.\n                /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n                this._theme = new Model(theme);\n                /**\n             * @type {module:echarts/model/OptionManager}\n             */\n                this._optionManager = optionManager;\n            },\n            setOption: function (option, optionPreprocessorFuncs) {\n                zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n                this._optionManager.setOption(option, optionPreprocessorFuncs);\n                this.resetOption();\n            },\n            resetOption: function (type) {\n                var optionChanged = false;\n                var optionManager = this._optionManager;\n                if (!type || type === 'recreate') {\n                    var baseOption = optionManager.mountOption(type === 'recreate');\n                    if (!this.option || type === 'recreate') {\n                        initBase.call(this, baseOption);\n                    } else {\n                        this.restoreData();\n                        this.mergeOption(baseOption);\n                    }\n                    optionChanged = true;\n                }\n                if (type === 'timeline' || type === 'media') {\n                    this.restoreData();\n                }\n                if (!type || type === 'recreate' || type === 'timeline') {\n                    var timelineOption = optionManager.getTimelineOption(this);\n                    timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n                }\n                if (!type || type === 'recreate' || type === 'media') {\n                    var mediaOptions = optionManager.getMediaOption(this, this._api);\n                    if (mediaOptions.length) {\n                        each(mediaOptions, function (mediaOption) {\n                            this.mergeOption(mediaOption, optionChanged = true);\n                        }, this);\n                    }\n                }\n                return optionChanged;\n            },\n            mergeOption: function (newOption) {\n                var option = this.option;\n                var componentsMap = this._componentsMap;\n                var newCptTypes = [];\n                //  component model  merge\n                each(newOption, function (componentOption, mainType) {\n                    if (componentOption == null) {\n                        return;\n                    }\n                    if (!ComponentModel.hasClass(mainType)) {\n                        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n                    } else {\n                        newCptTypes.push(mainType);\n                    }\n                });\n                // FIXME OPTION \n                ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n                this._seriesIndices = this._seriesIndices || [];\n                function visitComponent(mainType, dependencies) {\n                    var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n                    var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);\n                    makeKeyInfo(mainType, mapResult);\n                    var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n                    option[mainType] = [];\n                    componentsMap[mainType] = [];\n                    each(mapResult, function (resultItem, index) {\n                        var componentModel = resultItem.exist;\n                        var newCptOption = resultItem.option;\n                        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');\n                        // Consider where is no new option and should be merged using {},\n                        // see removeEdgeAndAdd in topologicalTravel and\n                        // ComponentModel.getAllClassMainTypes.\n                        if (!newCptOption) {\n                            componentModel.mergeOption({}, this);\n                            componentModel.optionUpdated({}, false);\n                        } else {\n                            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n                            if (componentModel && componentModel instanceof ComponentModelClass) {\n                                componentModel.mergeOption(newCptOption, this);\n                                componentModel.optionUpdated(newCptOption, false);\n                            } else {\n                                // PENDING Global as parent ?\n                                var extraOpt = zrUtil.extend({\n                                        dependentModels: dependentModels,\n                                        componentIndex: index\n                                    }, resultItem.keyInfo);\n                                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n                                componentModel.init(newCptOption, this, this, extraOpt);\n                                // Call optionUpdated after init.\n                                // newCptOption has been used as componentModel.option\n                                // and may be merged with theme and default, so pass null\n                                // to avoid confusion.\n                                componentModel.optionUpdated(null, true);\n                            }\n                        }\n                        componentsMap[mainType][index] = componentModel;\n                        option[mainType][index] = componentModel.option;\n                    }, this);\n                    // Backup series for filtering.\n                    if (mainType === 'series') {\n                        this._seriesIndices = createSeriesIndices(componentsMap.series);\n                    }\n                }\n            },\n            getOption: function () {\n                var option = zrUtil.clone(this.option);\n                each(option, function (opts, mainType) {\n                    if (ComponentModel.hasClass(mainType)) {\n                        var opts = modelUtil.normalizeToArray(opts);\n                        for (var i = opts.length - 1; i >= 0; i--) {\n                            // Remove options with inner id.\n                            if (modelUtil.isIdInner(opts[i])) {\n                                opts.splice(i, 1);\n                            }\n                        }\n                        option[mainType] = opts;\n                    }\n                });\n                delete option[OPTION_INNER_KEY];\n                return option;\n            },\n            getTheme: function () {\n                return this._theme;\n            },\n            getComponent: function (mainType, idx) {\n                var list = this._componentsMap[mainType];\n                if (list) {\n                    return list[idx || 0];\n                }\n            },\n            queryComponents: function (condition) {\n                var mainType = condition.mainType;\n                if (!mainType) {\n                    return [];\n                }\n                var index = condition.index;\n                var id = condition.id;\n                var name = condition.name;\n                var cpts = this._componentsMap[mainType];\n                if (!cpts || !cpts.length) {\n                    return [];\n                }\n                var result;\n                if (index != null) {\n                    if (!isArray(index)) {\n                        index = [index];\n                    }\n                    result = filter(map(index, function (idx) {\n                        return cpts[idx];\n                    }), function (val) {\n                        return !!val;\n                    });\n                } else if (id != null) {\n                    var isIdArray = isArray(id);\n                    result = filter(cpts, function (cpt) {\n                        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n                    });\n                } else if (name != null) {\n                    var isNameArray = isArray(name);\n                    result = filter(cpts, function (cpt) {\n                        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n                    });\n                } else {\n                    // Return all components with mainType\n                    result = cpts;\n                }\n                return filterBySubType(result, condition);\n            },\n            findComponents: function (condition) {\n                var query = condition.query;\n                var mainType = condition.mainType;\n                var queryCond = getQueryCond(query);\n                var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];\n                return doFilter(filterBySubType(result, condition));\n                function getQueryCond(q) {\n                    var indexAttr = mainType + 'Index';\n                    var idAttr = mainType + 'Id';\n                    var nameAttr = mainType + 'Name';\n                    return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {\n                        mainType: mainType,\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    } : null;\n                }\n                function doFilter(res) {\n                    return condition.filter ? filter(res, condition.filter) : res;\n                }\n            },\n            eachComponent: function (mainType, cb, context) {\n                var componentsMap = this._componentsMap;\n                if (typeof mainType === 'function') {\n                    context = cb;\n                    cb = mainType;\n                    each(componentsMap, function (components, componentType) {\n                        each(components, function (component, index) {\n                            cb.call(context, componentType, component, index);\n                        });\n                    });\n                } else if (zrUtil.isString(mainType)) {\n                    each(componentsMap[mainType], cb, context);\n                } else if (isObject(mainType)) {\n                    var queryResult = this.findComponents(mainType);\n                    each(queryResult, cb, context);\n                }\n            },\n            getSeriesByName: function (name) {\n                var series = this._componentsMap.series;\n                return filter(series, function (oneSeries) {\n                    return oneSeries.name === name;\n                });\n            },\n            getSeriesByIndex: function (seriesIndex) {\n                return this._componentsMap.series[seriesIndex];\n            },\n            getSeriesByType: function (subType) {\n                var series = this._componentsMap.series;\n                return filter(series, function (oneSeries) {\n                    return oneSeries.subType === subType;\n                });\n            },\n            getSeries: function () {\n                return this._componentsMap.series.slice();\n            },\n            eachSeries: function (cb, context) {\n                assertSeriesInitialized(this);\n                each(this._seriesIndices, function (rawSeriesIndex) {\n                    var series = this._componentsMap.series[rawSeriesIndex];\n                    cb.call(context, series, rawSeriesIndex);\n                }, this);\n            },\n            eachRawSeries: function (cb, context) {\n                each(this._componentsMap.series, cb, context);\n            },\n            eachSeriesByType: function (subType, cb, context) {\n                assertSeriesInitialized(this);\n                each(this._seriesIndices, function (rawSeriesIndex) {\n                    var series = this._componentsMap.series[rawSeriesIndex];\n                    if (series.subType === subType) {\n                        cb.call(context, series, rawSeriesIndex);\n                    }\n                }, this);\n            },\n            eachRawSeriesByType: function (subType, cb, context) {\n                return each(this.getSeriesByType(subType), cb, context);\n            },\n            isSeriesFiltered: function (seriesModel) {\n                assertSeriesInitialized(this);\n                return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n            },\n            filterSeries: function (cb, context) {\n                assertSeriesInitialized(this);\n                var filteredSeries = filter(this._componentsMap.series, cb, context);\n                this._seriesIndices = createSeriesIndices(filteredSeries);\n            },\n            restoreData: function () {\n                var componentsMap = this._componentsMap;\n                this._seriesIndices = createSeriesIndices(componentsMap.series);\n                var componentTypes = [];\n                each(componentsMap, function (components, componentType) {\n                    componentTypes.push(componentType);\n                });\n                ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                });\n            }\n        });\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        for (var name in theme) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof theme[name] === 'object') {\n                    option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);\n                } else {\n                    if (option[name] == null) {\n                        option[name] = theme[name];\n                    }\n                }\n            }\n        }\n    }\n    function initBase(baseOption) {\n        baseOption = baseOption;\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n        mergeTheme(baseOption, this._theme.option);\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n        this.mergeOption(baseOption);\n    }\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n        return ret;\n    }\n    /**\n     * @inner\n     */\n    function makeKeyInfo(mainType, mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n        // Ensure that each id is distinct.\n        var idMap = {};\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n            zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));\n            opt && opt.id != null && (idMap[opt.id] = item);\n            // Complete subType\n            if (isObject(opt)) {\n                var subType = determineSubType(mainType, opt, item.exist);\n                item.keyInfo = {\n                    mainType: mainType,\n                    subType: subType\n                };\n            }\n        });\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n            if (!isObject(opt)) {\n                return;\n            }\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\u0000-';\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            } else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            } else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\u0000' + keyInfo.name + '\u0000' + idNum++;\n                } while (idMap[keyInfo.id]);\n            }\n            idMap[keyInfo.id] = item;\n        });\n    }\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n            return cpt.subType === condition.subType;\n        }) : components;\n    }\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (true) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n    return GlobalModel;\n});\ndefine('echarts/model/OptionManager', ['require', 'zrender/core/util', '../util/model', './Component'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n    var QUERY_REG = /^(min|max)?(.+)$/;\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n    OptionManager.prototype = {\n        constructor: OptionManager,\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n            // FIXME\n            //  timeline options  media baseOption\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n            this._newBaseOption = newParsedOption.baseOption;\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            } else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n            // TODO\n            // resetclone\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n            return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);\n        },\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n                }\n            }\n            return option;\n        },\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n                });\n            }\n            // Otherwise return nothing.\n            this._currentMediaIndices = indices;\n            return result;\n        }\n    };\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    } else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n        // Preprocess.\n        each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n            return media.option;\n        })), function (option) {\n            each(optionPreprocessorFuncs, function (preProcess) {\n                preProcess(option, isNew);\n            });\n        });\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n                width: ecWidth,\n                height: ecHeight,\n                aspectratio: ecWidth / ecHeight\n            };\n        var applicatable = true;\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n        return applicatable;\n    }\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        } else if (operator === 'max') {\n            return real <= expect;\n        } else {\n            // Equals\n            return real === expect;\n        }\n    }\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n            var oldCptOpt = oldOption[mainType];\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            } else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n                });\n            }\n        });\n    }\n    return OptionManager;\n});\ndefine('echarts/CoordinateSystem', ['require'], function (require) {\n    'use strict';\n    var coordinateSystemCreators = {};\n    function CoordinateSystemManager() {\n        this._coordinateSystems = [];\n    }\n    CoordinateSystemManager.prototype = {\n        constructor: CoordinateSystemManager,\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            for (var type in coordinateSystemCreators) {\n                var list = coordinateSystemCreators[type].create(ecModel, api);\n                list && (coordinateSystems = coordinateSystems.concat(list));\n            }\n            this._coordinateSystems = coordinateSystems;\n        },\n        update: function (ecModel, api) {\n            var coordinateSystems = this._coordinateSystems;\n            for (var i = 0; i < coordinateSystems.length; i++) {\n                // FIXME MUST have\n                coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);\n            }\n        }\n    };\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n    return CoordinateSystemManager;\n});\ndefine('echarts/model/Series', ['require', 'zrender/core/util', '../util/format', '../util/model', './Component', './mixin/colorPalette', 'zrender/core/env'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var formatUtil = require('../util/format');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/core/env');\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n    var SeriesModel = ComponentModel.extend({\n            type: 'series.__base__',\n            seriesIndex: 0,\n            coordinateSystem: null,\n            defaultOption: null,\n            legendDataProvider: null,\n            visualColorAccessPath: 'itemStyle.normal.color',\n            init: function (option, parentModel, ecModel, extraOpt) {\n                /**\n             * @type {number}\n             * @readOnly\n             */\n                this.seriesIndex = this.componentIndex;\n                this.mergeDefaultAndTheme(option, ecModel);\n                /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n                this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n                // If we reverse the order (make this._data firstly, and then make\n                // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n                // cause this._data.graph.data !== this._data when using\n                // module:echarts/data/Graph or module:echarts/data/Tree.\n                // See module:echarts/data/helper/linkList\n                this._data = this._dataBeforeProcessed.cloneShallow();\n            },\n            mergeDefaultAndTheme: function (option, ecModel) {\n                zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n                zrUtil.merge(option, this.getDefaultOption());\n                // Default label emphasis `position` and `show`\n                // FIXME Set label in mergeOption\n                modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n                this.fillDataTextStyle(option.data);\n            },\n            mergeOption: function (newSeriesOption, ecModel) {\n                newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n                this.fillDataTextStyle(newSeriesOption.data);\n                var data = this.getInitialData(newSeriesOption, ecModel);\n                // TODO Merge data?\n                if (data) {\n                    this._data = data;\n                    this._dataBeforeProcessed = data.cloneShallow();\n                }\n            },\n            fillDataTextStyle: function (data) {\n                // Default data label emphasis `position` and `show`\n                // FIXME Tree structure data ?\n                // FIXME Performance ?\n                if (data) {\n                    for (var i = 0; i < data.length; i++) {\n                        if (data[i] && data[i].label) {\n                            modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                        }\n                    }\n                }\n            },\n            getInitialData: function () {\n            },\n            getData: function (dataType) {\n                return dataType == null ? this._data : this._data.getLinkedData(dataType);\n            },\n            setData: function (data) {\n                this._data = data;\n            },\n            getRawData: function () {\n                return this._dataBeforeProcessed;\n            },\n            coordDimToDataDim: function (coordDim) {\n                return [coordDim];\n            },\n            dataDimToCoordDim: function (dataDim) {\n                return dataDim;\n            },\n            getBaseAxis: function () {\n                var coordSys = this.coordinateSystem;\n                return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n            },\n            formatTooltip: function (dataIndex, multipleSeries, dataType) {\n                function formatArrayValue(value) {\n                    return zrUtil.map(value, function (val, idx) {\n                        var dimInfo = data.getDimensionInfo(idx);\n                        var dimType = dimInfo && dimInfo.type;\n                        if (dimType === 'ordinal') {\n                            return val;\n                        } else if (dimType === 'time') {\n                            return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n                        } else {\n                            return addCommas(val);\n                        }\n                    }).filter(function (val) {\n                        return !!val;\n                    }).join(', ');\n                }\n                var data = this._data;\n                var value = this.getRawValue(dataIndex);\n                var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value);\n                var name = data.getName(dataIndex);\n                var color = data.getItemVisual(dataIndex, 'color');\n                var colorEl = '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n                var seriesName = this.name;\n                // FIXME\n                if (seriesName === '\u0000-') {\n                    // Not show '-'\n                    seriesName = '';\n                }\n                return !multipleSeries ? (seriesName && encodeHTML(seriesName) + '<br />') + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue) : colorEl + encodeHTML(this.name) + ' : ' + formattedValue;\n            },\n            ifEnableAnimation: function () {\n                if (env.node) {\n                    return false;\n                }\n                var animationEnabled = this.getShallow('animation');\n                if (animationEnabled) {\n                    if (this.getData().count() > this.getShallow('animationThreshold')) {\n                        animationEnabled = false;\n                    }\n                }\n                return animationEnabled;\n            },\n            restoreData: function () {\n                this._data = this._dataBeforeProcessed.cloneShallow();\n            },\n            getColorFromPalette: function (name, scope) {\n                var ecModel = this.ecModel;\n                // PENDING\n                var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n                if (!color) {\n                    color = ecModel.getColorFromPalette(name, scope);\n                }\n                return color;\n            },\n            getAxisTooltipDataIndex: null\n        });\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n    return SeriesModel;\n});\ndefine('echarts/model/Component', ['require', './Model', 'zrender/core/util', '../util/component', '../util/clazz', '../util/layout', './mixin/boxLayout'], function (require) {\n    var Model = require('./Model');\n    var zrUtil = require('zrender/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n            type: 'component',\n            id: '',\n            name: '',\n            mainType: '',\n            subType: '',\n            componentIndex: 0,\n            defaultOption: null,\n            ecModel: null,\n            dependentModels: [],\n            uid: null,\n            layoutMode: null,\n            $constructor: function (option, parentModel, ecModel, extraOpt) {\n                Model.call(this, option, parentModel, ecModel, extraOpt);\n                // Set dependentModels, componentIndex, name, id, mainType, subType.\n                zrUtil.extend(this, extraOpt);\n                this.uid = componentUtil.getUID('componentModel');\n            },\n            init: function (option, parentModel, ecModel, extraOpt) {\n                this.mergeDefaultAndTheme(option, ecModel);\n            },\n            mergeDefaultAndTheme: function (option, ecModel) {\n                var layoutMode = this.layoutMode;\n                var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n                var themeModel = ecModel.getTheme();\n                zrUtil.merge(option, themeModel.get(this.mainType));\n                zrUtil.merge(option, this.getDefaultOption());\n                if (layoutMode) {\n                    layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                }\n            },\n            mergeOption: function (option) {\n                zrUtil.merge(this.option, option, true);\n                var layoutMode = this.layoutMode;\n                if (layoutMode) {\n                    layout.mergeLayoutParam(this.option, option, layoutMode);\n                }\n            },\n            optionUpdated: function (newCptOption, isInit) {\n            },\n            getDefaultOption: function () {\n                if (!this.hasOwnProperty('__defaultOption')) {\n                    var optList = [];\n                    var Class = this.constructor;\n                    while (Class) {\n                        var opt = Class.prototype.defaultOption;\n                        opt && optList.push(opt);\n                        Class = Class.superClass;\n                    }\n                    var defaultOption = {};\n                    for (var i = optList.length - 1; i >= 0; i--) {\n                        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                    }\n                    this.__defaultOption = defaultOption;\n                }\n                return this.__defaultOption;\n            }\n        });\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n    //         this.uid = componentUtil.getUID('componentModel');\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(ComponentModel, { registerWhenExtend: true });\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n    return ComponentModel;\n});\ndefine('echarts/view/Component', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n    var Group = require('zrender/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n    Component.prototype = {\n        constructor: Component,\n        init: function (ecModel, api) {\n        },\n        render: function (componentModel, ecModel, api, payload) {\n        },\n        dispose: function () {\n        }\n    };\n    var componentProto = Component.prototype;\n    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n    };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, { registerWhenExtend: true });\n    return Component;\n});\ndefine('echarts/view/Chart', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n    var Group = require('zrender/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    function Chart() {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n    Chart.prototype = {\n        type: 'chart',\n        init: function (ecModel, api) {\n        },\n        render: function (seriesModel, ecModel, api, payload) {\n        },\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n        dispose: function () {\n        }\n    };\n    var chartProto = Chart.prototype;\n    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n        this.render(seriesModel, ecModel, api, payload);\n    };\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = payload && payload.dataIndex;\n        var name = payload && payload.name;\n        if (dataIndex != null) {\n            var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];\n            for (var i = 0, len = dataIndices.length; i < len; i++) {\n                elSetState(data.getItemGraphicEl(dataIndices[i]), state);\n            }\n        } else if (name) {\n            var names = name instanceof Array ? name : [name];\n            for (var i = 0, len = names.length; i < len; i++) {\n                var dataIndex = data.indexOfName(names[i]);\n                elSetState(data.getItemGraphicEl(dataIndex), state);\n            }\n        } else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart);\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, { registerWhenExtend: true });\n    return Chart;\n});\ndefine('zrender/zrender', ['require', './core/guid', './core/env', './Handler', './Storage', './animation/Animation', './dom/HandlerProxy', './Painter'], function (require) {\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n    var useVML = !env.canvasSupported;\n    var painterCtors = { canvas: require('./Painter') };\n    var instances = {};\n    // ZRendermap\n    var zrender = {};\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.1.3';\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function (dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        } else {\n            for (var key in instances) {\n                instances[key].dispose();\n            }\n            instances = {};\n        }\n        return zrender;\n    };\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n    function delInstance(id) {\n        delete instances[id];\n    }\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     */\n    var ZRender = function (id, dom, opts) {\n        opts = opts || {};\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n        /**\n         * @type {string}\n         */\n        this.id = id;\n        var self = this;\n        var storage = new Storage();\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        } else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n        this.storage = storage;\n        this.painter = painter;\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy);\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: function () {\n                    if (self._needsRefresh) {\n                        self.refreshImmediately();\n                    }\n                    if (self._needsRefreshHover) {\n                        self.refreshHoverImmediately();\n                    }\n                }\n            }\n        });\n        this.animation.start();\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n        //  storage.delFromMap, \n        // FIXME ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n            oldDelFromMap.call(storage, elId);\n            el && el.removeSelfFromZr(self);\n        };\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n            el.addSelfToZr(self);\n        };\n    };\n    ZRender.prototype = {\n        constructor: ZRender,\n        getId: function () {\n            return this.id;\n        },\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n        refresh: function () {\n            this._needsRefresh = true;\n        },\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n        resize: function () {\n            this.painter.resize();\n            this.handler.resize();\n        },\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n        getWidth: function () {\n            return this.painter.getWidth();\n        },\n        getHeight: function () {\n            return this.painter.getHeight();\n        },\n        pathToImage: function (e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n        on: function (eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n        off: function (eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n        dispose: function () {\n            this.animation.stop();\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n            this.animation = this.storage = this.painter = this.handler = null;\n            delInstance(this.id);\n        }\n    };\n    return zrender;\n});\ndefine('zrender/mixin/Eventful', ['require'], function (require) {\n    var arrySlice = Array.prototype.slice;\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n    Eventful.prototype = {\n        constructor: Eventful,\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n            if (!handler || !event) {\n                return this;\n            }\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n            return this;\n        },\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n            if (!handler || !event) {\n                return this;\n            }\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n            return this;\n        },\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n        off: function (event, handler) {\n            var _h = this._$handlers;\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            } else {\n                delete _h[event];\n            }\n            return this;\n        },\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(_h[i]['ctx']);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(_h[i]['ctx'], args);\n                        break;\n                    }\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    } else {\n                        i++;\n                    }\n                }\n            }\n            return this;\n        },\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(ctx);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(ctx, args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(ctx, args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(ctx, args);\n                        break;\n                    }\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    } else {\n                        i++;\n                    }\n                }\n            }\n            return this;\n        }\n    };\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n    return Eventful;\n});\ndefine('zrender/tool/color', ['require'], function (require) {\n    var kCSSColorTable = {\n            'transparent': [\n                0,\n                0,\n                0,\n                0\n            ],\n            'aliceblue': [\n                240,\n                248,\n                255,\n                1\n            ],\n            'antiquewhite': [\n                250,\n                235,\n                215,\n                1\n            ],\n            'aqua': [\n                0,\n                255,\n                255,\n                1\n            ],\n            'aquamarine': [\n                127,\n                255,\n                212,\n                1\n            ],\n            'azure': [\n                240,\n                255,\n                255,\n                1\n            ],\n            'beige': [\n                245,\n                245,\n                220,\n                1\n            ],\n            'bisque': [\n                255,\n                228,\n                196,\n                1\n            ],\n            'black': [\n                0,\n                0,\n                0,\n                1\n            ],\n            'blanchedalmond': [\n                255,\n                235,\n                205,\n                1\n            ],\n            'blue': [\n                0,\n                0,\n                255,\n                1\n            ],\n            'blueviolet': [\n                138,\n                43,\n                226,\n                1\n            ],\n            'brown': [\n                165,\n                42,\n                42,\n                1\n            ],\n            'burlywood': [\n                222,\n                184,\n                135,\n                1\n            ],\n            'cadetblue': [\n                95,\n                158,\n                160,\n                1\n            ],\n            'chartreuse': [\n                127,\n                255,\n                0,\n                1\n            ],\n            'chocolate': [\n                210,\n                105,\n                30,\n                1\n            ],\n            'coral': [\n                255,\n                127,\n                80,\n                1\n            ],\n            'cornflowerblue': [\n                100,\n                149,\n                237,\n                1\n            ],\n            'cornsilk': [\n                255,\n                248,\n                220,\n                1\n            ],\n            'crimson': [\n                220,\n                20,\n                60,\n                1\n            ],\n            'cyan': [\n                0,\n                255,\n                255,\n                1\n            ],\n            'darkblue': [\n                0,\n                0,\n                139,\n                1\n            ],\n            'darkcyan': [\n                0,\n                139,\n                139,\n                1\n            ],\n            'darkgoldenrod': [\n                184,\n                134,\n                11,\n                1\n            ],\n            'darkgray': [\n                169,\n                169,\n                169,\n                1\n            ],\n            'darkgreen': [\n                0,\n                100,\n                0,\n                1\n            ],\n            'darkgrey': [\n                169,\n                169,\n                169,\n                1\n            ],\n            'darkkhaki': [\n                189,\n                183,\n                107,\n                1\n            ],\n            'darkmagenta': [\n                139,\n                0,\n                139,\n                1\n            ],\n            'darkolivegreen': [\n                85,\n                107,\n                47,\n                1\n            ],\n            'darkorange': [\n                255,\n                140,\n                0,\n                1\n            ],\n            'darkorchid': [\n                153,\n                50,\n                204,\n                1\n            ],\n            'darkred': [\n                139,\n                0,\n                0,\n                1\n            ],\n            'darksalmon': [\n                233,\n                150,\n                122,\n                1\n            ],\n            'darkseagreen': [\n                143,\n                188,\n                143,\n                1\n            ],\n            'darkslateblue': [\n                72,\n                61,\n                139,\n                1\n            ],\n            'darkslategray': [\n                47,\n                79,\n                79,\n                1\n            ],\n            'darkslategrey': [\n                47,\n                79,\n                79,\n                1\n            ],\n            'darkturquoise': [\n                0,\n                206,\n                209,\n                1\n            ],\n            'darkviolet': [\n                148,\n                0,\n                211,\n                1\n            ],\n            'deeppink': [\n                255,\n                20,\n                147,\n                1\n            ],\n            'deepskyblue': [\n                0,\n                191,\n                255,\n                1\n            ],\n            'dimgray': [\n                105,\n                105,\n                105,\n                1\n            ],\n            'dimgrey': [\n                105,\n                105,\n                105,\n                1\n            ],\n            'dodgerblue': [\n                30,\n                144,\n                255,\n                1\n            ],\n            'firebrick': [\n                178,\n                34,\n                34,\n                1\n            ],\n            'floralwhite': [\n                255,\n                250,\n                240,\n                1\n            ],\n            'forestgreen': [\n                34,\n                139,\n                34,\n                1\n            ],\n            'fuchsia': [\n                255,\n                0,\n                255,\n                1\n            ],\n            'gainsboro': [\n                220,\n                220,\n                220,\n                1\n            ],\n            'ghostwhite': [\n                248,\n                248,\n                255,\n                1\n            ],\n            'gold': [\n                255,\n                215,\n                0,\n                1\n            ],\n            'goldenrod': [\n                218,\n                165,\n                32,\n                1\n            ],\n            'gray': [\n                128,\n                128,\n                128,\n                1\n            ],\n            'green': [\n                0,\n                128,\n                0,\n                1\n            ],\n            'greenyellow': [\n                173,\n                255,\n                47,\n                1\n            ],\n            'grey': [\n                128,\n                128,\n                128,\n                1\n            ],\n            'honeydew': [\n                240,\n                255,\n                240,\n                1\n            ],\n            'hotpink': [\n                255,\n                105,\n                180,\n                1\n            ],\n            'indianred': [\n                205,\n                92,\n                92,\n                1\n            ],\n            'indigo': [\n                75,\n                0,\n                130,\n                1\n            ],\n            'ivory': [\n                255,\n                255,\n                240,\n                1\n            ],\n            'khaki': [\n                240,\n                230,\n                140,\n                1\n            ],\n            'lavender': [\n                230,\n                230,\n                250,\n                1\n            ],\n            'lavenderblush': [\n                255,\n                240,\n                245,\n                1\n            ],\n            'lawngreen': [\n                124,\n                252,\n                0,\n                1\n            ],\n            'lemonchiffon': [\n                255,\n                250,\n                205,\n                1\n            ],\n            'lightblue': [\n                173,\n                216,\n                230,\n                1\n            ],\n            'lightcoral': [\n                240,\n                128,\n                128,\n                1\n            ],\n            'lightcyan': [\n                224,\n                255,\n                255,\n                1\n            ],\n            'lightgoldenrodyellow': [\n                250,\n                250,\n                210,\n                1\n            ],\n            'lightgray': [\n                211,\n                211,\n                211,\n                1\n            ],\n            'lightgreen': [\n                144,\n                238,\n                144,\n                1\n            ],\n            'lightgrey': [\n                211,\n                211,\n                211,\n                1\n            ],\n            'lightpink': [\n                255,\n                182,\n                193,\n                1\n            ],\n            'lightsalmon': [\n                255,\n                160,\n                122,\n                1\n            ],\n            'lightseagreen': [\n                32,\n                178,\n                170,\n                1\n            ],\n            'lightskyblue': [\n                135,\n                206,\n                250,\n                1\n            ],\n            'lightslategray': [\n                119,\n                136,\n                153,\n                1\n            ],\n            'lightslategrey': [\n                119,\n                136,\n                153,\n                1\n            ],\n            'lightsteelblue': [\n                176,\n                196,\n                222,\n                1\n            ],\n            'lightyellow': [\n                255,\n                255,\n                224,\n                1\n            ],\n            'lime': [\n                0,\n                255,\n                0,\n                1\n            ],\n            'limegreen': [\n                50,\n                205,\n                50,\n                1\n            ],\n            'linen': [\n                250,\n                240,\n                230,\n                1\n            ],\n            'magenta': [\n                255,\n                0,\n                255,\n                1\n            ],\n            'maroon': [\n                128,\n                0,\n                0,\n                1\n            ],\n            'mediumaquamarine': [\n                102,\n                205,\n                170,\n                1\n            ],\n            'mediumblue': [\n                0,\n                0,\n                205,\n                1\n            ],\n            'mediumorchid': [\n                186,\n                85,\n                211,\n                1\n            ],\n            'mediumpurple': [\n                147,\n                112,\n                219,\n                1\n            ],\n            'mediumseagreen': [\n                60,\n                179,\n                113,\n                1\n            ],\n            'mediumslateblue': [\n                123,\n                104,\n                238,\n                1\n            ],\n            'mediumspringgreen': [\n                0,\n                250,\n                154,\n                1\n            ],\n            'mediumturquoise': [\n                72,\n                209,\n                204,\n                1\n            ],\n            'mediumvioletred': [\n                199,\n                21,\n                133,\n                1\n            ],\n            'midnightblue': [\n                25,\n                25,\n                112,\n                1\n            ],\n            'mintcream': [\n                245,\n                255,\n                250,\n                1\n            ],\n            'mistyrose': [\n                255,\n                228,\n                225,\n                1\n            ],\n            'moccasin': [\n                255,\n                228,\n                181,\n                1\n            ],\n            'navajowhite': [\n                255,\n                222,\n                173,\n                1\n            ],\n            'navy': [\n                0,\n                0,\n                128,\n                1\n            ],\n            'oldlace': [\n                253,\n                245,\n                230,\n                1\n            ],\n            'olive': [\n                128,\n                128,\n                0,\n                1\n            ],\n            'olivedrab': [\n                107,\n                142,\n                35,\n                1\n            ],\n            'orange': [\n                255,\n                165,\n                0,\n                1\n            ],\n            'orangered': [\n                255,\n                69,\n                0,\n                1\n            ],\n            'orchid': [\n                218,\n                112,\n                214,\n                1\n            ],\n            'palegoldenrod': [\n                238,\n                232,\n                170,\n                1\n            ],\n            'palegreen': [\n                152,\n                251,\n                152,\n                1\n            ],\n            'paleturquoise': [\n                175,\n                238,\n                238,\n                1\n            ],\n            'palevioletred': [\n                219,\n                112,\n                147,\n                1\n            ],\n            'papayawhip': [\n                255,\n                239,\n                213,\n                1\n            ],\n            'peachpuff': [\n                255,\n                218,\n                185,\n                1\n            ],\n            'peru': [\n                205,\n                133,\n                63,\n                1\n            ],\n            'pink': [\n                255,\n                192,\n                203,\n                1\n            ],\n            'plum': [\n                221,\n                160,\n                221,\n                1\n            ],\n            'powderblue': [\n                176,\n                224,\n                230,\n                1\n            ],\n            'purple': [\n                128,\n                0,\n                128,\n                1\n            ],\n            'red': [\n                255,\n                0,\n                0,\n                1\n            ],\n            'rosybrown': [\n                188,\n                143,\n                143,\n                1\n            ],\n            'royalblue': [\n                65,\n                105,\n                225,\n                1\n            ],\n            'saddlebrown': [\n                139,\n                69,\n                19,\n                1\n            ],\n            'salmon': [\n                250,\n                128,\n                114,\n                1\n            ],\n            'sandybrown': [\n                244,\n                164,\n                96,\n                1\n            ],\n            'seagreen': [\n                46,\n                139,\n                87,\n                1\n            ],\n            'seashell': [\n                255,\n                245,\n                238,\n                1\n            ],\n            'sienna': [\n                160,\n                82,\n                45,\n                1\n            ],\n            'silver': [\n                192,\n                192,\n                192,\n                1\n            ],\n            'skyblue': [\n                135,\n                206,\n                235,\n                1\n            ],\n            'slateblue': [\n                106,\n                90,\n                205,\n                1\n            ],\n            'slategray': [\n                112,\n                128,\n                144,\n                1\n            ],\n            'slategrey': [\n                112,\n                128,\n                144,\n                1\n            ],\n            'snow': [\n                255,\n                250,\n                250,\n                1\n            ],\n            'springgreen': [\n                0,\n                255,\n                127,\n                1\n            ],\n            'steelblue': [\n                70,\n                130,\n                180,\n                1\n            ],\n            'tan': [\n                210,\n                180,\n                140,\n                1\n            ],\n            'teal': [\n                0,\n                128,\n                128,\n                1\n            ],\n            'thistle': [\n                216,\n                191,\n                216,\n                1\n            ],\n            'tomato': [\n                255,\n                99,\n                71,\n                1\n            ],\n            'turquoise': [\n                64,\n                224,\n                208,\n                1\n            ],\n            'violet': [\n                238,\n                130,\n                238,\n                1\n            ],\n            'wheat': [\n                245,\n                222,\n                179,\n                1\n            ],\n            'white': [\n                255,\n                255,\n                255,\n                1\n            ],\n            'whitesmoke': [\n                245,\n                245,\n                245,\n                1\n            ],\n            'yellow': [\n                255,\n                255,\n                0,\n                1\n            ],\n            'yellowgreen': [\n                154,\n                205,\n                50,\n                1\n            ]\n        };\n    function clampCssByte(i) {\n        // Clamp to integer 0 .. 255.\n        i = Math.round(i);\n        // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n    function clampCssAngle(i) {\n        // Clamp to integer 0 .. 360.\n        i = Math.round(i);\n        // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n    function clampCssFloat(f) {\n        // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n    function parseCssInt(str) {\n        // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n    function parseCssFloat(str) {\n        // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        } else if (h > 1) {\n            h -= 1;\n        }\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n        }\n        return m1;\n    }\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();    // dup.\n        }\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);\n                // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 4095)) {\n                    return;    // Covers NaN.\n                }\n                return [\n                    (iv & 3840) >> 4 | (iv & 3840) >> 8,\n                    iv & 240 | (iv & 240) >> 4,\n                    iv & 15 | (iv & 15) << 4,\n                    1\n                ];\n            } else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);\n                // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 16777215)) {\n                    return;    // Covers NaN.\n                }\n                return [\n                    (iv & 16711680) >> 16,\n                    (iv & 65280) >> 8,\n                    iv & 255,\n                    1\n                ];\n            }\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;\n            // To allow case fallthrough.\n            switch (fname) {\n            case 'rgba':\n                if (params.length !== 4) {\n                    return;\n                }\n                alpha = parseCssFloat(params.pop());\n            // jshint ignore:line\n            // Fall through.\n            case 'rgb':\n                if (params.length !== 3) {\n                    return;\n                }\n                return [\n                    parseCssInt(params[0]),\n                    parseCssInt(params[1]),\n                    parseCssInt(params[2]),\n                    alpha\n                ];\n            case 'hsla':\n                if (params.length !== 4) {\n                    return;\n                }\n                params[3] = parseCssFloat(params[3]);\n                return hsla2rgba(params);\n            case 'hsl':\n                if (params.length !== 3) {\n                    return;\n                }\n                return hsla2rgba(params);\n            default:\n                return;\n            }\n        }\n        return;\n    }\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;\n        // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        var rgba = [\n                clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n                clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n                clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n            ];\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n        return rgba;\n    }\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n        var vMin = Math.min(R, G, B);\n        // Min. value of RGB\n        var vMax = Math.max(R, G, B);\n        // Max. value of RGB\n        var delta = vMax - vMin;\n        // Delta RGB value\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        } else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            } else {\n                S = delta / (2 - vMax - vMin);\n            }\n            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            } else if (G === vMax) {\n                H = 1 / 3 + deltaR - deltaB;\n            } else if (B === vMax) {\n                H = 2 / 3 + deltaG - deltaR;\n            }\n            if (H < 0) {\n                H += 1;\n            }\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n        var hsla = [\n                H * 360,\n                S,\n                L\n            ];\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n        return hsla;\n    }\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                } else {\n                    colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n        }\n    }\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        out = out || [\n            0,\n            0,\n            0,\n            0\n        ];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n        var color = stringify([\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ], 'rgba');\n        return fullOutput ? {\n            color: color,\n            leftIndex: leftIndex,\n            rightIndex: rightIndex,\n            value: value\n        } : color;\n    }\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n    return {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n});\ndefine('zrender/core/timsort', [], function () {\n    var DEFAULT_MIN_MERGE = 32;\n    var DEFAULT_MIN_GALLOPING = 7;\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n    function minRunLength(n) {\n        var r = 0;\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n        return n + r;\n    }\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n        if (runHi === hi) {\n            return 1;\n        }\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n            reverseRun(array, lo, runHi);\n        } else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n        return runHi - lo;\n    }\n    function reverseRun(array, lo, hi) {\n        hi--;\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n        for (; start < hi; start++) {\n            var pivot = array[start];\n            var left = lo;\n            var right = start;\n            var mid;\n            while (left < right) {\n                mid = left + right >>> 1;\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            var n = start - left;\n            switch (n) {\n            case 3:\n                array[left + 3] = array[left + 2];\n            case 2:\n                array[left + 2] = array[left + 1];\n            case 1:\n                array[left + 1] = array[left];\n                break;\n            default:\n                while (n > 0) {\n                    array[left + n] = array[left + n - 1];\n                    n--;\n                }\n            }\n            array[left] = pivot;\n        }\n    }\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        } else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            } else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        } else {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            } else {\n                lastOffset = m + 1;\n            }\n        }\n        return offset;\n    }\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n        length = array.length;\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n        var tmp = [];\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n        runStart = [];\n        runLength = [];\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                } else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n                mergeAt(n);\n            }\n        }\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n            runLength[i] = length1 + length2;\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n            stackSize--;\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n            if (length1 === 0) {\n                return;\n            }\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n            if (length2 === 0) {\n                return;\n            }\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            } else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n            array[dest++] = array[cursor2++];\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    } else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = array[cursor2++];\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            minGallop < 1 && (minGallop = 1);\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            } else if (length1 === 0) {\n                throw new Error();    // throw new Error('mergeLow preconditions were not respected');\n            } else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n        function mergeHigh(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n            array[dest--] = array[cursor1--];\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n                return;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n                return;\n            }\n            var _minGallop = minGallop;\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    } else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = tmp[cursor2--];\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = array[cursor1--];\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n            } else if (length2 === 0) {\n                throw new Error();    // throw new Error('mergeHigh preconditions were not respected');\n            } else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n        var remaining = hi - lo;\n        if (remaining < 2) {\n            return;\n        }\n        var runLength = 0;\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n        var ts = new TimSort(array, compare);\n        var minRun = minRunLength(remaining);\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n        ts.forceMergeRuns();\n    }\n    return sort;\n});\ndefine('echarts/visual/seriesColor', ['require', 'zrender/graphic/Gradient'], function (require) {\n    var Gradient = require('zrender/graphic/Gradient');\n    return function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));\n            // Default color\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n                    });\n                }\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n});\ndefine('echarts/preprocessor/backwardCompat', ['require', 'zrender/core/util', './helper/compatStyle'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var compatStyle = require('./helper/compatStyle');\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n    var LAYOUT_PROPERTIES = [\n            [\n                'x',\n                'left'\n            ],\n            [\n                'y',\n                'top'\n            ],\n            [\n                'x2',\n                'right'\n            ],\n            [\n                'y2',\n                'bottom'\n            ]\n        ];\n    var COMPATITABLE_COMPONENTS = [\n            'grid',\n            'geo',\n            'parallel',\n            'legend',\n            'toolbox',\n            'title',\n            'visualMap',\n            'dataZoom',\n            'timeline'\n        ];\n    var COMPATITABLE_SERIES = [\n            'bar',\n            'boxplot',\n            'candlestick',\n            'chord',\n            'effectScatter',\n            'funnel',\n            'gauge',\n            'lines',\n            'graph',\n            'heatmap',\n            'line',\n            'map',\n            'parallel',\n            'pie',\n            'radar',\n            'sankey',\n            'scatter',\n            'treemap'\n        ];\n    var each = zrUtil.each;\n    return function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n            var seriesType = seriesOpt.type;\n            compatStyle(seriesOpt);\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n});\ndefine('echarts/loading/default', ['require', '../util/graphic', 'zrender/core/util'], function (require) {\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    return function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n                style: { fill: opts.maskColor },\n                zlevel: opts.zlevel,\n                z: 10000\n            });\n        var arc = new graphic.Arc({\n                shape: {\n                    startAngle: -PI / 2,\n                    endAngle: -PI / 2 + 0.1,\n                    r: 10\n                },\n                style: {\n                    stroke: opts.color,\n                    lineCap: 'round',\n                    lineWidth: 5\n                },\n                zlevel: opts.zlevel,\n                z: 10001\n            });\n        var labelRect = new graphic.Rect({\n                style: {\n                    fill: 'none',\n                    text: opts.text,\n                    textPosition: 'right',\n                    textDistance: 10,\n                    textFill: opts.textColor\n                },\n                zlevel: opts.zlevel,\n                z: 10001\n            });\n        arc.animateShape(true).when(1000, { endAngle: PI * 3 / 2 }).start('circularInOut');\n        arc.animateShape(true).when(1000, { startAngle: PI * 3 / 2 }).delay(300).start('circularInOut');\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n});\ndefine('zrender/core/matrix', [], function () {\n    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n            create: function () {\n                var out = new ArrayCtor(6);\n                matrix.identity(out);\n                return out;\n            },\n            identity: function (out) {\n                out[0] = 1;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 1;\n                out[4] = 0;\n                out[5] = 0;\n                return out;\n            },\n            copy: function (out, m) {\n                out[0] = m[0];\n                out[1] = m[1];\n                out[2] = m[2];\n                out[3] = m[3];\n                out[4] = m[4];\n                out[5] = m[5];\n                return out;\n            },\n            mul: function (out, m1, m2) {\n                // Consider matrix.mul(m, m2, m);\n                // where out is the same as m2.\n                // So use temp variable to escape error.\n                var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n                var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n                var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n                var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n                var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n                var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n                out[0] = out0;\n                out[1] = out1;\n                out[2] = out2;\n                out[3] = out3;\n                out[4] = out4;\n                out[5] = out5;\n                return out;\n            },\n            translate: function (out, a, v) {\n                out[0] = a[0];\n                out[1] = a[1];\n                out[2] = a[2];\n                out[3] = a[3];\n                out[4] = a[4] + v[0];\n                out[5] = a[5] + v[1];\n                return out;\n            },\n            rotate: function (out, a, rad) {\n                var aa = a[0];\n                var ac = a[2];\n                var atx = a[4];\n                var ab = a[1];\n                var ad = a[3];\n                var aty = a[5];\n                var st = Math.sin(rad);\n                var ct = Math.cos(rad);\n                out[0] = aa * ct + ab * st;\n                out[1] = -aa * st + ab * ct;\n                out[2] = ac * ct + ad * st;\n                out[3] = -ac * st + ct * ad;\n                out[4] = ct * atx + st * aty;\n                out[5] = ct * aty - st * atx;\n                return out;\n            },\n            scale: function (out, a, v) {\n                var vx = v[0];\n                var vy = v[1];\n                out[0] = a[0] * vx;\n                out[1] = a[1] * vy;\n                out[2] = a[2] * vx;\n                out[3] = a[3] * vy;\n                out[4] = a[4] * vx;\n                out[5] = a[5] * vy;\n                return out;\n            },\n            invert: function (out, a) {\n                var aa = a[0];\n                var ac = a[2];\n                var atx = a[4];\n                var ab = a[1];\n                var ad = a[3];\n                var aty = a[5];\n                var det = aa * ad - ab * ac;\n                if (!det) {\n                    return null;\n                }\n                det = 1 / det;\n                out[0] = ad * det;\n                out[1] = -ab * det;\n                out[2] = -ac * det;\n                out[3] = aa * det;\n                out[4] = (ac * aty - ad * atx) * det;\n                out[5] = (ab * atx - aa * aty) * det;\n                return out;\n            }\n        };\n    return matrix;\n});\ndefine('echarts/model/Model', ['require', 'zrender/core/util', '../util/clazz', './mixin/lineStyle', './mixin/areaStyle', './mixin/textStyle', './mixin/itemStyle'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazzUtil = require('../util/clazz');\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;    // Simple optimization\n                                 // if (this.init) {\n                                 //     if (arguments.length <= 4) {\n                                 //         this.init(option, parentModel, ecModel, extraOpt);\n                                 //     }\n                                 //     else {\n                                 //         this.init.apply(this, arguments);\n                                 //     }\n                                 // }\n    }\n    Model.prototype = {\n        constructor: Model,\n        init: null,\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n        get: function (path, ignoreParent) {\n            if (!path) {\n                return this.option;\n            }\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            var obj = this.option;\n            var parentModel = this.parentModel;\n            for (var i = 0; i < path.length; i++) {\n                // Ignore empty\n                if (!path[i]) {\n                    continue;\n                }\n                // obj could be number/string/... (like 0)\n                obj = obj && typeof obj === 'object' ? obj[path[i]] : null;\n                if (obj == null) {\n                    break;\n                }\n            }\n            if (obj == null && parentModel && !ignoreParent) {\n                obj = parentModel.get(path);\n            }\n            return obj;\n        },\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n            var val = option == null ? option : option[key];\n            var parentModel = this.parentModel;\n            if (val == null && parentModel && !ignoreParent) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n        getModel: function (path, parentModel) {\n            var obj = this.get(path, true);\n            var thisParentModel = this.parentModel;\n            var model = new Model(obj, parentModel || thisParentModel && thisParentModel.getModel(path), this.ecModel);\n            return model;\n        },\n        isEmpty: function () {\n            return this.option == null;\n        },\n        restoreData: function () {\n        },\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        }\n    };\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n    return Model;\n});\ndefine('echarts/data/List', ['require', '../model/Model', './DataDiffer', 'zrender/core/util', '../util/model'], function (require) {\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;\n    var dataCtors = {\n            'float': Float64Array,\n            'int': Int32Array,\n            'ordinal': Array,\n            'number': Array,\n            'time': Array\n        };\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n    var TRANSFERABLE_PROPERTIES = [\n            'stackedOn',\n            'hasItemOption',\n            '_nameList',\n            '_idList',\n            '_rawData'\n        ];\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n        dimensions = dimensions || [\n            'x',\n            'y'\n        ];\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    type: 'number'\n                };\n            } else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n    var listProto = List.prototype;\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n        this._rawData = data;\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n        var idList = [];\n        var nameRepeatCount = {};\n        nameList = nameList || [];\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] : value, dimensionInfoMap[dimName]);\n        };\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n            indices.push(idx);\n        }\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n        return values;\n    };\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getDataExtent = function (dim, stack) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = dimInfo && dimInfo.stackable && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                value < min && (min = value);\n                value > max && (max = value);\n            }\n            return this._extent[dim + !!stack] = [\n                min,\n                max\n            ];\n        } else {\n            return [\n                Infinity,\n                -Infinity\n            ];\n        }\n    };\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            } else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (diff <= maxDistance && (dist < minDist || dist === minDist && diff > 0)) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n    };\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n        context = context || this;\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n            case 0:\n                cb.call(context, i);\n                break;\n            case 1:\n                cb.call(context, this.get(dims[0], i, stack), i);\n                break;\n            case 2:\n                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                break;\n            default:\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dims[k], i, stack);\n                }\n                // Index\n                value[k] = i;\n                cb.apply(context, value);\n            }\n        }\n    };\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n        context = context || this;\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n            } else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n        this.indices = newIndices;\n        // Reset data extent\n        this._extent = {};\n        return this;\n    };\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n            } else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n        var storage = list._storage;\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n        return list;\n    };\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n        return list;\n    };\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n            return otherIdList[idx] || idx + '';\n        }, function (idx) {\n            return idList[idx] || idx + '';\n        });\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n    };\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n        this._graphicEls[idx] = el;\n    };\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n        // FIXME\n        list._storage = this._storage;\n        transferProperties(list, this);\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n        return list;\n    };\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = [\n        'cloneShallow',\n        'downSample',\n        'map'\n    ];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n    return List;\n});\ndefine('zrender/core/vector', [], function () {\n    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n            create: function (x, y) {\n                var out = new ArrayCtor(2);\n                if (x == null) {\n                    x = 0;\n                }\n                if (y == null) {\n                    y = 0;\n                }\n                out[0] = x;\n                out[1] = y;\n                return out;\n            },\n            copy: function (out, v) {\n                out[0] = v[0];\n                out[1] = v[1];\n                return out;\n            },\n            clone: function (v) {\n                var out = new ArrayCtor(2);\n                out[0] = v[0];\n                out[1] = v[1];\n                return out;\n            },\n            set: function (out, a, b) {\n                out[0] = a;\n                out[1] = b;\n                return out;\n            },\n            add: function (out, v1, v2) {\n                out[0] = v1[0] + v2[0];\n                out[1] = v1[1] + v2[1];\n                return out;\n            },\n            scaleAndAdd: function (out, v1, v2, a) {\n                out[0] = v1[0] + v2[0] * a;\n                out[1] = v1[1] + v2[1] * a;\n                return out;\n            },\n            sub: function (out, v1, v2) {\n                out[0] = v1[0] - v2[0];\n                out[1] = v1[1] - v2[1];\n                return out;\n            },\n            len: function (v) {\n                return Math.sqrt(this.lenSquare(v));\n            },\n            lenSquare: function (v) {\n                return v[0] * v[0] + v[1] * v[1];\n            },\n            mul: function (out, v1, v2) {\n                out[0] = v1[0] * v2[0];\n                out[1] = v1[1] * v2[1];\n                return out;\n            },\n            div: function (out, v1, v2) {\n                out[0] = v1[0] / v2[0];\n                out[1] = v1[1] / v2[1];\n                return out;\n            },\n            dot: function (v1, v2) {\n                return v1[0] * v2[0] + v1[1] * v2[1];\n            },\n            scale: function (out, v, s) {\n                out[0] = v[0] * s;\n                out[1] = v[1] * s;\n                return out;\n            },\n            normalize: function (out, v) {\n                var d = vector.len(v);\n                if (d === 0) {\n                    out[0] = 0;\n                    out[1] = 0;\n                } else {\n                    out[0] = v[0] / d;\n                    out[1] = v[1] / d;\n                }\n                return out;\n            },\n            distance: function (v1, v2) {\n                return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n            },\n            distanceSquare: function (v1, v2) {\n                return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n            },\n            negate: function (out, v) {\n                out[0] = -v[0];\n                out[1] = -v[1];\n                return out;\n            },\n            lerp: function (out, v1, v2, t) {\n                out[0] = v1[0] + t * (v2[0] - v1[0]);\n                out[1] = v1[1] + t * (v2[1] - v1[1]);\n                return out;\n            },\n            applyTransform: function (out, v, m) {\n                var x = v[0];\n                var y = v[1];\n                out[0] = m[0] * x + m[2] * y + m[4];\n                out[1] = m[1] * x + m[3] * y + m[5];\n                return out;\n            },\n            min: function (out, v1, v2) {\n                out[0] = Math.min(v1[0], v2[0]);\n                out[1] = Math.min(v1[1], v2[1]);\n                return out;\n            },\n            max: function (out, v1, v2) {\n                out[0] = Math.max(v1[0], v2[0]);\n                out[1] = Math.max(v1[1], v2[1]);\n                return out;\n            }\n        };\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n    return vector;\n});\ndefine('echarts/scale/Scale', ['require', '../util/clazz'], function (require) {\n    var clazzUtil = require('../util/clazz');\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [\n            Infinity,\n            -Infinity\n        ];\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n        this.init && this.init.apply(this, arguments);\n    }\n    var scaleProto = Scale.prototype;\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);    // not setExtent because in log axis it may transformed to power\n                                                           // this.setExtent(extent[0], extent[1]);\n    };\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true });\n    return Scale;\n});\ndefine('echarts/coord/axisHelper', ['require', '../scale/Ordinal', '../scale/Interval', '../scale/Time', '../scale/Log', '../scale/Scale', '../util/number', 'zrender/core/util', 'zrender/contain/text'], function (require) {\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/core/util');\n    var textContain = require('zrender/contain/text');\n    var axisHelper = {};\n    /**\n     * Get axis scale extent before niced.\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var originalExtent = scale.getExtent();\n        var span = originalExtent[1] - originalExtent[0];\n        if (scale.type === 'ordinal') {\n            // If series has no data, scale extent may be wrong\n            if (!isFinite(span)) {\n                return [\n                    0,\n                    0\n                ];\n            } else {\n                return originalExtent;\n            }\n        }\n        var min = model.getMin ? model.getMin() : model.get('min');\n        var max = model.getMax ? model.getMax() : model.get('max');\n        var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');\n        var boundaryGap = model.get('boundaryGap');\n        if (!zrUtil.isArray(boundaryGap)) {\n            boundaryGap = [\n                boundaryGap || 0,\n                boundaryGap || 0\n            ];\n        }\n        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n        var fixMin = true;\n        var fixMax = true;\n        // Add boundary gap\n        if (min == null) {\n            min = originalExtent[0] - boundaryGap[0] * span;\n            fixMin = false;\n        }\n        if (max == null) {\n            max = originalExtent[1] + boundaryGap[1] * span;\n            fixMax = false;\n        }\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n        // Evaluate if axis needs cross zero\n        if (crossZero) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n        return [\n            min,\n            max\n        ];\n    };\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n        var splitNumber = model.get('splitNumber');\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);\n            scale.niceExtent(splitNumber);\n        }\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function (model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n            // Buildin scale\n            case 'category':\n                return new OrdinalScale(model.getCategories(), [\n                    Infinity,\n                    -Infinity\n                ]);\n            case 'value':\n                return new IntervalScale();\n            // Extended scale, like time and log\n            default:\n                return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !(min > 0 && max > 0 || min < 0 && max < 0);\n    };\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }    // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            } else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val);\n                };\n            }(labelFormatter);\n            return zrUtil.map(labels, labelFormatter);\n        } else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);\n            }, this);\n        } else {\n            return labels;\n        }\n    };\n    return axisHelper;\n});\ndefine('echarts/coord/cartesian/Cartesian2D', ['require', 'zrender/core/util', './Cartesian'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var Cartesian = require('./Cartesian');\n    function Cartesian2D(name) {\n        Cartesian.call(this, name);\n    }\n    Cartesian2D.prototype = {\n        constructor: Cartesian2D,\n        type: 'cartesian2d',\n        dimensions: [\n            'x',\n            'y'\n        ],\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n        },\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n        },\n        dataToPoints: function (data, stack) {\n            return data.mapArray([\n                'x',\n                'y'\n            ], function (x, y) {\n                return this.dataToPoint([\n                    x,\n                    y\n                ]);\n            }, stack, this);\n        },\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n    zrUtil.inherits(Cartesian2D, Cartesian);\n    return Cartesian2D;\n});\ndefine('echarts/coord/cartesian/Axis2D', ['require', 'zrender/core/util', '../Axis', './axisLabelInterval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n    Axis2D.prototype = {\n        constructor: Axis2D,\n        index: 0,\n        onZero: false,\n        model: null,\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n            }\n        },\n        toLocalCoord: null,\n        toGlobalCoord: null\n    };\n    zrUtil.inherits(Axis2D, Axis);\n    return Axis2D;\n});\ndefine('echarts/coord/cartesian/GridModel', ['require', './AxisModel', '../../model/Component'], function (require) {\n    'use strict';\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n    return ComponentModel.extend({\n        type: 'grid',\n        dependencies: [\n            'xAxis',\n            'yAxis'\n        ],\n        layoutMode: 'box',\n        coordinateSystem: null,\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            containLabel: false,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n});\ndefine('zrender/tool/path', ['require', '../graphic/Path', '../core/PathProxy', './transformPath', '../core/matrix'], function (require) {\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n    // command chars\n    var cc = [\n            'm',\n            'M',\n            'l',\n            'L',\n            'v',\n            'V',\n            'h',\n            'H',\n            'z',\n            'Z',\n            'c',\n            'C',\n            'q',\n            'Q',\n            't',\n            'T',\n            's',\n            'S',\n            'a',\n            'A'\n        ];\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n    var vMag = function (v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function (u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function (u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n    };\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180);\n        var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;\n        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n        var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n        var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n        var theta = vAngle([\n                1,\n                0\n            ], [\n                (xp - cxp) / rx,\n                (yp - cyp) / ry\n            ]);\n        var u = [\n                (xp - cxp) / rx,\n                (yp - cyp) / ry\n            ];\n        var v = [\n                (-1 * xp - cxp) / rx,\n                (-1 * yp - cyp) / ry\n            ];\n        var dTheta = vAngle(u, v);\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n        // command string\n        var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n                var x1 = cpx;\n                var y1 = cpy;\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                case 'l':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'L':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'm':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'l';\n                    break;\n                case 'M':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'L';\n                    break;\n                case 'h':\n                    cpx += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'H':\n                    cpx = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'v':\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'V':\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'C':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n                    cpx = p[off - 2];\n                    cpy = p[off - 1];\n                    break;\n                case 'c':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n                    cpx += p[off - 2];\n                    cpy += p[off - 1];\n                    break;\n                case 'S':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 's':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = cpx + p[off++];\n                    y1 = cpy + p[off++];\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 'Q':\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'q':\n                    x1 = p[off++] + cpx;\n                    y1 = p[off++] + cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'T':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 't':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 'A':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n                case 'a':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n                }\n            }\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n            prevCmd = cmd;\n        }\n        path.toStatic();\n        return path;\n    }\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n        return opts;\n    }\n    return {\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n            return pathBundle;\n        }\n    };\n});\ndefine('zrender/graphic/Path', ['require', './Displayable', '../core/util', '../core/PathProxy', '../contain/path', './Pattern'], function (require) {\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n    var abs = Math.abs;\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n    Path.prototype = {\n        constructor: Path,\n        type: 'path',\n        __dirtyPath: true,\n        strokeContainThreshold: 5,\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!fill.colorStops;\n            var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n            var hasFillPattern = hasFill && !!fill.image;\n            var hasStrokePattern = hasStroke && !!stroke.image;\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            } else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            } else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n            var ctxLineDash = !!ctx.setLineDash;\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n                path = this.path.beginPath(ctx);\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n                this.buildPath(path, this.shape, false);\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            } else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n            hasFill && path.fill(ctx);\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n            hasStroke && path.stroke(ctx);\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n            this.restoreTransform(ctx);\n            // Draw rect text\n            if (style.text || style.text === 0) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n        buildPath: function (ctx, shapeCfg, inBundle) {\n        },\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n            return rect;\n        },\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            } else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        shape[name] = key[name];\n                    }\n                } else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n        }\n    };\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n            defaults.init && defaults.init.call(this, opts);\n        };\n        zrUtil.inherits(Sub, Path);\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n        return Sub;\n    };\n    zrUtil.inherits(Path, Displayable);\n    return Path;\n});\ndefine('zrender/graphic/Gradient', ['require'], function (require) {\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n        this.colorStops = colorStops || [];\n    };\n    Gradient.prototype = {\n        constructor: Gradient,\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n                offset: offset,\n                color: color\n            });\n        }\n    };\n    return Gradient;\n});\ndefine('zrender/container/Group', ['require', '../core/util', '../Element', '../core/BoundingRect'], function (require) {\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n        opts = opts || {};\n        Element.call(this, opts);\n        for (var key in opts) {\n            this[key] = opts[key];\n        }\n        this._children = [];\n        this.__storage = null;\n        this.__dirty = true;\n    };\n    Group.prototype = {\n        constructor: Group,\n        isGroup: true,\n        type: 'group',\n        silent: false,\n        children: function () {\n            return this._children.slice();\n        },\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n            }\n        },\n        childCount: function () {\n            return this._children.length;\n        },\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n                this._children.push(child);\n                this._doAdd(child);\n            }\n            return this;\n        },\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n            return this;\n        },\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n            child.parent = this;\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n            zr && zr.refresh();\n        },\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n            child.parent = null;\n            if (storage) {\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n            zr && zr.refresh();\n            return this;\n        },\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n            return this;\n        },\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            // TODO Transform\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                } else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n    zrUtil.inherits(Group, Element);\n    return Group;\n});\ndefine('zrender/graphic/Text', ['require', './Displayable', '../core/util', '../contain/text'], function (require) {\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n    Text.prototype = {\n        constructor: Text,\n        type: 'text',\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n            if (text) {\n                this.setTransform(ctx);\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(text, font, style.textAlign, 'top');\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                    case 'middle':\n                        y -= rect.height / 2 - rect.lineHeight / 2;\n                        break;\n                    case 'bottom':\n                        y -= rect.height - rect.lineHeight / 2;\n                        break;\n                    default:\n                        y += rect.lineHeight / 2;\n                    }\n                } else {\n                    textBaseline = style.textBaseline;\n                }\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n                var lineHeight = textContain.measureText('', ctx.font).width;\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n                this.restoreTransform(ctx);\n            }\n        },\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);\n                switch (textVerticalAlign) {\n                case 'middle':\n                    rect.y -= rect.height / 2;\n                    break;\n                case 'bottom':\n                    rect.y -= rect.height;\n                    break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n    zrUtil.inherits(Text, Displayable);\n    return Text;\n});\ndefine('zrender/graphic/Image', ['require', './Displayable', '../core/BoundingRect', '../core/util', '../core/LRU'], function (require) {\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n    ZImage.prototype = {\n        constructor: ZImage,\n        type: 'image',\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }    // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                } else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n                // transform\n                this.setTransform(ctx);\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n                } else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n                } else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n                // \n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n                this.restoreTransform(ctx);\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n            }\n        },\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n            }\n            return this._rect;\n        }\n    };\n    zrUtil.inherits(ZImage, Displayable);\n    return ZImage;\n});\ndefine('zrender/graphic/shape/Circle', ['require', '../Path'], function (require) {\n    'use strict';\n    return require('../Path').extend({\n        type: 'circle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n        buildPath: function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Ring', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'ring',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Sector', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'sector',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r0: 0,\n            r: 0,\n            startAngle: 0,\n            endAngle: Math.PI * 2,\n            clockwise: true\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n            ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n            ctx.closePath();\n        }\n    });\n});\ndefine('zrender/graphic/shape/Rect', ['require', '../helper/roundRect', '../Path'], function (require) {\n    var roundRectHelper = require('../helper/roundRect');\n    return require('../Path').extend({\n        type: 'rect',\n        shape: {\n            r: 0,\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            } else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n});\ndefine('zrender/graphic/shape/Polygon', ['require', '../helper/poly', '../Path'], function (require) {\n    var polyHelper = require('../helper/poly');\n    return require('../Path').extend({\n        type: 'polygon',\n        shape: {\n            points: null,\n            smooth: false,\n            smoothConstraint: null\n        },\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Polyline', ['require', '../helper/poly', '../Path'], function (require) {\n    var polyHelper = require('../helper/poly');\n    return require('../Path').extend({\n        type: 'polyline',\n        shape: {\n            points: null,\n            smooth: false,\n            smoothConstraint: null\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Line', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'line',\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            percent: 1\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n});\ndefine('zrender/graphic/shape/BezierCurve', ['require', '../../core/curve', '../../core/vector', '../Path'], function (require) {\n    'use strict';\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n    var out = [];\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        } else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    return require('../Path').extend({\n        type: 'bezier-curve',\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            percent: 1\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(x1, cpx1, x2, percent, out);\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(y1, cpy1, y2, percent, out);\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n                ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n            } else {\n                if (percent < 1) {\n                    cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n            }\n        },\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Arc', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'arc',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            startAngle: 0,\n            endAngle: Math.PI * 2,\n            clockwise: true\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n});\ndefine('zrender/graphic/RadialGradient', ['require', '../core/util', './Gradient'], function (require) {\n    'use strict';\n    var zrUtil = require('../core/util');\n    var Gradient = require('./Gradient');\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n        this.y = y == null ? 0.5 : y;\n        this.r = r == null ? 0.5 : r;\n        // Can be cloned\n        this.type = 'radial';\n        // If use global coord\n        this.global = globalCoord || false;\n        Gradient.call(this, colorStops);\n    };\n    RadialGradient.prototype = { constructor: RadialGradient };\n    zrUtil.inherits(RadialGradient, Gradient);\n    return RadialGradient;\n});\ndefine('zrender/graphic/LinearGradient', ['require', '../core/util', './Gradient'], function (require) {\n    'use strict';\n    var zrUtil = require('../core/util');\n    var Gradient = require('./Gradient');\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n        this.x2 = x2 == null ? 1 : x2;\n        this.y2 = y2 == null ? 0 : y2;\n        // Can be cloned\n        this.type = 'linear';\n        // If use global coord\n        this.global = globalCoord || false;\n        Gradient.call(this, colorStops);\n    };\n    LinearGradient.prototype = { constructor: LinearGradient };\n    zrUtil.inherits(LinearGradient, Gradient);\n    return LinearGradient;\n});\ndefine('zrender/graphic/CompoundPath', ['require', './Path'], function (require) {\n    var Path = require('./Path');\n    return Path.extend({\n        type: 'compound',\n        shape: { paths: null },\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n});\ndefine('zrender/core/BoundingRect', ['require', './vector', './matrix'], function (require) {\n    'use strict';\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathAbs = Math.abs;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n    BoundingRect.prototype = {\n        constructor: BoundingRect,\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n            this.x = x;\n            this.y = y;\n        },\n        applyTransform: function () {\n            var min = [];\n            var max = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                min[0] = this.x;\n                min[1] = this.y;\n                max[0] = this.x + this.width;\n                max[1] = this.y + this.height;\n                v2ApplyTransform(min, min, m);\n                v2ApplyTransform(max, max, m);\n                this.x = mathMin(min[0], max[0]);\n                this.y = mathMin(min[1], max[1]);\n                this.width = mathAbs(max[0] - min[0]);\n                this.height = mathAbs(max[1] - min[1]);\n            };\n        }(),\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n            var m = matrix.create();\n            // \n            matrix.translate(m, m, [\n                -a.x,\n                -a.y\n            ]);\n            matrix.scale(m, m, [\n                sx,\n                sy\n            ]);\n            matrix.translate(m, m, [\n                b.x,\n                b.y\n            ]);\n            return m;\n        },\n        intersect: function (b) {\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n            return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n        },\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        }\n    };\n    return BoundingRect;\n});\ndefine('zrender/contain/text', ['require', '../core/util', '../core/BoundingRect'], function (require) {\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n        return width;\n    }\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n        switch (textBaseline) {\n        case 'bottom':\n        case 'alphabetic':\n            rect.y -= lineHeight;\n            break;\n        case 'middle':\n            rect.y -= lineHeight / 2;\n            break;    // case 'hanging':\n                      // case 'top':\n        }\n        // FIXME Right to left language\n        switch (textAlign) {\n        case 'end':\n        case 'right':\n            rect.x -= rect.width;\n            break;\n        case 'center':\n            rect.x -= rect.width / 2;\n            break;    // case 'start':\n                      // case 'left':\n        }\n        return rect;\n    }\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n        var x = rect.x;\n        var y = rect.y;\n        var height = rect.height;\n        var width = rect.width;\n        var textHeight = textRect.height;\n        var halfHeight = height / 2 - textHeight / 2;\n        var textAlign = 'left';\n        switch (textPosition) {\n        case 'left':\n            x -= distance;\n            y += halfHeight;\n            textAlign = 'right';\n            break;\n        case 'right':\n            x += distance + width;\n            y += halfHeight;\n            textAlign = 'left';\n            break;\n        case 'top':\n            x += width / 2;\n            y -= distance + textHeight;\n            textAlign = 'center';\n            break;\n        case 'bottom':\n            x += width / 2;\n            y += height + distance;\n            textAlign = 'center';\n            break;\n        case 'inside':\n            x += width / 2;\n            y += halfHeight;\n            textAlign = 'center';\n            break;\n        case 'insideLeft':\n            x += distance;\n            y += halfHeight;\n            textAlign = 'left';\n            break;\n        case 'insideRight':\n            x += width - distance;\n            y += halfHeight;\n            textAlign = 'right';\n            break;\n        case 'insideTop':\n            x += width / 2;\n            y += distance;\n            textAlign = 'center';\n            break;\n        case 'insideBottom':\n            x += width / 2;\n            y += height - textHeight - distance;\n            textAlign = 'center';\n            break;\n        case 'insideTopLeft':\n            x += distance;\n            y += distance;\n            textAlign = 'left';\n            break;\n        case 'insideTopRight':\n            x += width - distance;\n            y += distance;\n            textAlign = 'right';\n            break;\n        case 'insideBottomLeft':\n            x += distance;\n            y += height - textHeight - distance;\n            break;\n        case 'insideBottomRight':\n            x += width - distance;\n            y += height - textHeight - distance;\n            textAlign = 'right';\n            break;\n        }\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n        options = options || {};\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n        // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n        contentWidth = containerWidth - ellipsisWidth;\n        var textLines = (text + '').split('\\n');\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n                var subLength = j === 0 ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n            textLines[i] = textLine;\n        }\n        return textLines.join('\\n');\n    }\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n    var textContain = {\n            getWidth: getTextWidth,\n            getBoundingRect: getTextRect,\n            adjustTextPositionOnRect: adjustTextPositionOnRect,\n            truncateText: truncateText,\n            measureText: function (text, textFont) {\n                var ctx = util.getContext();\n                ctx.font = textFont || '12px sans-serif';\n                return ctx.measureText(text);\n            }\n        };\n    return textContain;\n});\ndefine('echarts/util/model', ['require', './format', './number', '../model/Model', 'zrender/core/util'], function (require) {\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = {};\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array ? value : value == null ? [] : [value];\n    };\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n    modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n            // Default emphasis option from normal\n            zrUtil.each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n    modelUtil.LABEL_OPTIONS = [\n        'position',\n        'show',\n        'textStyle',\n        'distance',\n        'formatter'\n    ];\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return zrUtil.isObject(dataItem) && !(dataItem instanceof Array);    // // markLine data can be array\n                                                                             // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return value == null || value === '' ? NaN : +value;    // If string (like '-'), using '+' parse to NaN\n    };\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n                $vars: [\n                    'seriesName',\n                    'name',\n                    'value'\n                ]\n            };\n        },\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && params.value instanceof Array) {\n                params.value = params.value[dimIndex];\n            }\n            var formatter = itemModel.get([\n                    'label',\n                    status,\n                    'formatter'\n                ]);\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            } else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return zrUtil.isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n            }\n        },\n        formatTooltip: zrUtil.noop\n    };\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n        var result = zrUtil.map(exists || [], function (obj, index) {\n                return { exist: obj };\n            });\n        // Mapping by id or name if specified.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '') {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n        // Otherwise mapping by index.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n            if (i >= result.length) {\n                result.push({ option: cptOption });\n            }\n        });\n        return result;\n    };\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\u0000_ec_\u0000') === 0;\n    };\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n        return [\n            mapToArray(mapA),\n            mapToArray(mapB)\n        ];\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    } else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    } else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({\n                            seriesId: i,\n                            dataIndex: dataIndices\n                        });\n                    }\n                }\n            }\n            return result;\n        }\n    };\n    return modelUtil;\n});\ndefine('echarts/model/globalDefault', [], function () {\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    return {\n        color: [\n            '#c23531',\n            '#2f4554',\n            '#61a0a8',\n            '#d48265',\n            '#91c7ae',\n            '#749f83',\n            '#ca8622',\n            '#bda29a',\n            '#6e7074',\n            '#546570',\n            '#c4ccd3'\n        ],\n        textStyle: {\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n        blendMode: null,\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n        animationThreshold: 2000,\n        progressiveThreshold: 3000,\n        progressive: 400,\n        hoverLayerThreshold: 3000\n    };\n});\ndefine('echarts/model/mixin/colorPalette', [], function () {\n    return {\n        clearColorPalette: function () {\n            this._colorIdx = 0;\n            this._colorNameMap = {};\n        },\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = scope._colorIdx || 0;\n            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n            return color;\n        }\n    };\n});\ndefine('zrender/core/PathProxy', ['require', './curve', './vector', './bbox', './BoundingRect', '../config'], function (require) {\n    'use strict';\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n    var CMD = {\n            M: 1,\n            L: 2,\n            C: 3,\n            Q: 4,\n            A: 5,\n            Z: 6,\n            R: 7\n        };\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n    var hasTypedArray = typeof Float32Array != 'undefined';\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n        this._len = 0;\n        this._ctx = null;\n        this._xi = 0;\n        this._yi = 0;\n        this._x0 = 0;\n        this._y0 = 0;\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n        constructor: PathProxy,\n        _lineDash: null,\n        _dashOffset: 0,\n        _dashIdx: 0,\n        _dashSum: 0,\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n        getContext: function () {\n            return this._ctx;\n        },\n        beginPath: function (ctx) {\n            this._ctx = ctx;\n            ctx && ctx.beginPath();\n            ctx && (this.dpr = ctx.dpr);\n            // Reset\n            this._len = 0;\n            if (this._lineDash) {\n                this._lineDash = null;\n                this._dashOffset = 0;\n            }\n            return this;\n        },\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n            this._xi = x;\n            this._yi = y;\n            return this;\n        },\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;\n            this.addData(CMD.L, x, y);\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n            return this;\n        },\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n        closePath: function () {\n            this.addData(CMD.Z);\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n                this._dashIdx = 0;\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n        len: function () {\n            return this._len;\n        },\n        setData: function (data) {\n            var len = data.length;\n            if (!(this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n            this._len = len;\n        },\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && this.data instanceof Float32Array) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n            this._prevCmd = cmd;\n        },\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n        _needsDash: function () {\n            return this._lineDash;\n        },\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n            while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n            var x;\n            var y;\n            var tmpLen = 0;\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n            while (t <= 1) {\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n                t += lineDash[idx] / bezierLen;\n                idx = (idx + 1) % nDash;\n            }\n            // Finish the last segment and calculate the new offset\n            idx % 2 !== 0 && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    min2[0] = x0;\n                    min2[1] = y0;\n                    max2[0] = x0;\n                    max2[1] = y0;\n                    break;\n                case CMD.L:\n                    bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++];\n                    var endAngle = data[i++] + startAngle;\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    if (i == 1) {\n                        //  arc \n                        // \n                        x0 = mathCos(startAngle) * rx + cx;\n                        y0 = mathSin(startAngle) * ry + cy;\n                    }\n                    bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    // Use fromLine\n                    bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                    break;\n                case CMD.Z:\n                    xi = x0;\n                    yi = y0;\n                    break;\n                }\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n            return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n        },\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                case CMD.M:\n                    x0 = xi = d[i++];\n                    y0 = yi = d[i++];\n                    ctx.moveTo(xi, yi);\n                    break;\n                case CMD.L:\n                    x = d[i++];\n                    y = d[i++];\n                    // Not draw too small seg between\n                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                        ctx.lineTo(x, y);\n                        xi = x;\n                        yi = y;\n                    }\n                    break;\n                case CMD.C:\n                    ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.Q:\n                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.A:\n                    var cx = d[i++];\n                    var cy = d[i++];\n                    var rx = d[i++];\n                    var ry = d[i++];\n                    var theta = d[i++];\n                    var dTheta = d[i++];\n                    var psi = d[i++];\n                    var fs = d[i++];\n                    var r = rx > ry ? rx : ry;\n                    var scaleX = rx > ry ? 1 : rx / ry;\n                    var scaleY = rx > ry ? ry / rx : 1;\n                    var isEllipse = Math.abs(rx - ry) > 0.001;\n                    var endAngle = theta + dTheta;\n                    if (isEllipse) {\n                        ctx.translate(cx, cy);\n                        ctx.rotate(psi);\n                        ctx.scale(scaleX, scaleY);\n                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                        ctx.scale(1 / scaleX, 1 / scaleY);\n                        ctx.rotate(-psi);\n                        ctx.translate(-cx, -cy);\n                    } else {\n                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                    }\n                    if (i == 1) {\n                        //  arc \n                        // \n                        x0 = mathCos(theta) * rx + cx;\n                        y0 = mathSin(theta) * ry + cy;\n                    }\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = d[i];\n                    y0 = yi = d[i + 1];\n                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                    break;\n                case CMD.Z:\n                    ctx.closePath();\n                    xi = x0;\n                    yi = y0;\n                }\n            }\n        }\n    };\n    PathProxy.CMD = CMD;\n    return PathProxy;\n});\ndefine('zrender/tool/transformPath', ['require', '../core/PathProxy', '../core/vector'], function (require) {\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var points = [\n            [],\n            [],\n            []\n        ];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n            switch (cmd) {\n            case M:\n                nPoint = 1;\n                break;\n            case L:\n                nPoint = 1;\n                break;\n            case C:\n                nPoint = 3;\n                break;\n            case Q:\n                nPoint = 2;\n                break;\n            case A:\n                var x = m[4];\n                var y = m[5];\n                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                // cx\n                data[i++] += x;\n                // cy\n                data[i++] += y;\n                // Scale rx and ry\n                // FIXME Assume psi is 0 here\n                data[i++] *= sx;\n                data[i++] *= sy;\n                // Start angle\n                data[i++] += angle;\n                // end angle\n                data[i++] += angle;\n                // FIXME psi\n                i += 2;\n                j = i;\n                break;\n            case R:\n                // x0, y0\n                p[0] = data[i++];\n                p[1] = data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n                // x1, y1\n                p[0] += data[i++];\n                p[1] += data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n    return transformPath;\n});\ndefine('echarts/util/clazz', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazz = {};\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n            var ret = {\n                    main: '',\n                    sub: ''\n                };\n            if (componentType) {\n                componentType = componentType.split(TYPE_DELIMITER);\n                ret.main = componentType[0] || '';\n                ret.sub = componentType[1] || '';\n            }\n            return ret;\n        };\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass) {\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                } else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n            zrUtil.extend(ExtendedClass.prototype, proto);\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n            return ExtendedClass;\n        };\n    };\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                componentType = parseClassType(componentType);\n                if (!componentType.sub) {\n                    if (true) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                } else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n            var Clazz = storage[componentTypeMain];\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');\n            }\n            return Clazz;\n        };\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n            var result = [];\n            var obj = storage[componentType.main];\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            } else {\n                result.push(obj);\n            }\n            return result;\n        };\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n        entity.parseClassType = parseClassType;\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n        return entity;\n    };\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n    };\n    return clazz;\n});\ndefine('zrender/graphic/Displayable', ['require', '../core/util', './Style', '../Element', './mixin/RectText'], function (require) {\n    var zrUtil = require('../core/util');\n    var Style = require('./Style');\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n        opts = opts || {};\n        Element.call(this, opts);\n        // Extend properties\n        for (var name in opts) {\n            if (opts.hasOwnProperty(name) && name !== 'style') {\n                this[name] = opts[name];\n            }\n        }\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];    // FIXME Stateful must be mixined after style is setted\n                                  // Stateful.call(this, opts);\n    }\n    Displayable.prototype = {\n        constructor: Displayable,\n        type: 'displayable',\n        __dirty: true,\n        invisible: false,\n        z: 0,\n        z2: 0,\n        zlevel: 0,\n        draggable: false,\n        dragging: false,\n        silent: false,\n        culling: false,\n        cursor: 'pointer',\n        rectHover: false,\n        progressive: -1,\n        beforeBrush: function (ctx) {\n        },\n        afterBrush: function (ctx) {\n        },\n        brush: function (ctx, prevEl) {\n        },\n        getBoundingRect: function () {\n        },\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n        dirty: function () {\n            this.__dirty = true;\n            this._rect = null;\n            this.__zr && this.__zr.refresh();\n        },\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            } else {\n                this.style.set(value);\n            }\n        },\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n    zrUtil.inherits(Displayable, Element);\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n    return Displayable;\n});\ndefine('zrender/contain/path', ['require', '../core/PathProxy', './line', './cubic', './quadratic', './arc', './util', '../core/curve', './windingLine'], function (require) {\n    'use strict';\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n    var windingLine = require('./windingLine');\n    var containStroke = line.containStroke;\n    var PI2 = Math.PI * 2;\n    var EPSILON = 0.0001;\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n    // \n    var roots = [\n            -1,\n            -1,\n            -1\n        ];\n    var extrema = [\n            -1,\n            -1\n        ];\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        } else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = t === 0 || t === 1 ? 0.5 : 1;\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) {\n                    // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    } else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    } else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                } else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    } else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        } else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {\n                        // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    } else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            } else {\n                // Remove one endpoint.\n                var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {\n                    // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n    // TODO\n    // Arc \n    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 0.0001) {\n            return 0;\n        }\n        if (diff % PI2 < 0.0001) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        } else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }    //  subpath \n                     // if (w !== 0) {\n                     //     return true;\n                     // }\n            }\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n                x0 = xi;\n                y0 = yi;\n            }\n            switch (cmd) {\n            case CMD.M:\n                // moveTo  subpath, \n                //  closePath \n                x0 = data[i++];\n                y0 = data[i++];\n                xi = x0;\n                yi = y0;\n                break;\n            case CMD.L:\n                if (isStroke) {\n                    if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // NOTE  L, C, Q  NaN\n                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.C:\n                if (isStroke) {\n                    if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.Q:\n                if (isStroke) {\n                    if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.A:\n                // TODO Arc \n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var theta = data[i++];\n                var dTheta = data[i++];\n                // TODO Arc \n                var psi = data[i++];\n                var anticlockwise = 1 - data[i++];\n                var x1 = Math.cos(theta) * rx + cx;\n                var y1 = Math.sin(theta) * ry + cy;\n                //  arc \n                if (i > 1) {\n                    w += windingLine(xi, yi, x1, y1, x, y);\n                } else {\n                    // \n                    x0 = x1;\n                    y0 = y1;\n                }\n                // zr scale, x\n                var _x = (x - cx) * ry / rx + cx;\n                if (isStroke) {\n                    if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n                }\n                xi = Math.cos(theta + dTheta) * rx + cx;\n                yi = Math.sin(theta + dTheta) * ry + cy;\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                var width = data[i++];\n                var height = data[i++];\n                var x1 = x0 + width;\n                var y1 = y0 + height;\n                if (isStroke) {\n                    if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // FIXME Clockwise ?\n                    w += windingLine(x1, y0, x1, y1, x, y);\n                    w += windingLine(x0, y1, x0, y0, x, y);\n                }\n                break;\n            case CMD.Z:\n                if (isStroke) {\n                    if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // Close a subpath\n                    w += windingLine(xi, yi, x0, y0, x, y);    //  subpath \n                                                               // FIXME subpaths may overlap\n                                                               // if (w !== 0) {\n                                                               //     return true;\n                                                               // }\n                }\n                xi = x0;\n                yi = y0;\n                break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n    return {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n});\ndefine('echarts/model/mixin/lineStyle', ['require', './makeStyleMapper'], function (require) {\n    var getLineStyle = require('./makeStyleMapper')([\n            [\n                'lineWidth',\n                'width'\n            ],\n            [\n                'stroke',\n                'color'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n        getLineDash: function () {\n            var lineType = this.get('type');\n            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n                5,\n                5\n            ] : [\n                2,\n                2\n            ];\n        }\n    };\n});\ndefine('echarts/scale/Ordinal', ['require', 'zrender/core/util', './Scale'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Scale = require('./Scale');\n    var scaleProto = Scale.prototype;\n    var OrdinalScale = Scale.extend({\n            type: 'ordinal',\n            init: function (data, extent) {\n                this._data = data;\n                this._extent = extent || [\n                    0,\n                    data.length - 1\n                ];\n            },\n            parse: function (val) {\n                return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);\n            },\n            contain: function (rank) {\n                rank = this.parse(rank);\n                return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n            },\n            normalize: function (val) {\n                return scaleProto.normalize.call(this, this.parse(val));\n            },\n            scale: function (val) {\n                return Math.round(scaleProto.scale.call(this, val));\n            },\n            getTicks: function () {\n                var ticks = [];\n                var extent = this._extent;\n                var rank = extent[0];\n                while (rank <= extent[1]) {\n                    ticks.push(rank);\n                    rank++;\n                }\n                return ticks;\n            },\n            getLabel: function (n) {\n                return this._data[n];\n            },\n            count: function () {\n                return this._extent[1] - this._extent[0] + 1;\n            },\n            niceTicks: zrUtil.noop,\n            niceExtent: zrUtil.noop\n        });\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n    return OrdinalScale;\n});\ndefine('zrender/graphic/Pattern', ['require'], function (require) {\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n        // Can be cloned\n        this.type = 'pattern';\n    };\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return this._canvasPattern || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n    return Pattern;\n});\ndefine('echarts/model/mixin/areaStyle', ['require', './makeStyleMapper'], function (require) {\n    return {\n        getAreaStyle: require('./makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['opacity'],\n            ['shadowColor']\n        ])\n    };\n});\ndefine('echarts/model/mixin/textStyle', ['require', 'zrender/contain/text'], function (require) {\n    var textContain = require('zrender/contain/text');\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n    return {\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color') || ecModel && ecModel.get('textStyle.color');\n        },\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n        getTextRect: function (text) {\n            var textStyle = this.get('textStyle') || {};\n            return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);\n        },\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(text, containerWidth, this.getFont(), ellipsis, options);\n        }\n    };\n});\ndefine('echarts/model/mixin/itemStyle', ['require', './makeStyleMapper'], function (require) {\n    var getItemStyle = require('./makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            [\n                'stroke',\n                'borderColor'\n            ],\n            [\n                'lineWidth',\n                'borderWidth'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n                5,\n                5\n            ] : [\n                1,\n                1\n            ];\n        }\n    };\n});\ndefine('zrender/graphic/Style', ['require'], function (require) {\n    var STYLE_COMMON_PROPS = [\n            [\n                'shadowBlur',\n                0\n            ],\n            [\n                'shadowOffsetX',\n                0\n            ],\n            [\n                'shadowOffsetY',\n                0\n            ],\n            [\n                'shadowColor',\n                '#000'\n            ],\n            [\n                'lineCap',\n                'butt'\n            ],\n            [\n                'lineJoin',\n                'miter'\n            ],\n            [\n                'miterLimit',\n                10\n            ]\n        ];\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n        return canvasGradient;\n    }\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n        return canvasGradient;\n    }\n    Style.prototype = {\n        constructor: Style,\n        fill: '#000000',\n        stroke: null,\n        opacity: 1,\n        lineDash: null,\n        lineDashOffset: 0,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        lineWidth: 1,\n        strokeNoScale: false,\n        text: null,\n        textFill: '#000',\n        textStroke: null,\n        textPosition: 'inside',\n        textBaseline: null,\n        textAlign: null,\n        textVerticalAlign: null,\n        textDistance: 5,\n        textShadowBlur: 0,\n        textShadowOffsetX: 0,\n        textShadowOffsetY: 0,\n        textTransform: false,\n        textRotation: 0,\n        blend: null,\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n            if (firstDraw || style.fill !== prevStyle.fill) {\n                ctx.fillStyle = style.fill;\n            }\n            if (firstDraw || style.stroke !== prevStyle.stroke) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if (firstDraw || style.opacity !== prevStyle.opacity) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n            if (firstDraw || style.blend !== prevStyle.blend) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n            }\n        },\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            } else {\n                this.extendFrom(obj, true);\n            }\n        },\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n            }\n            return canvasGradient;\n        }\n    };\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n    return Style;\n});\ndefine('zrender/graphic/mixin/RectText', ['require', '../../contain/text', '../../core/BoundingRect'], function (require) {\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n    var tmpRect = new BoundingRect();\n    var RectText = function () {\n    };\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n    RectText.prototype = {\n        constructor: RectText,\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n            // FIXME\n            ctx.save();\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            } else {\n                this.setTransform(ctx);\n            }\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                    case 'middle':\n                        y -= textRect.height / 2 - textRect.lineHeight / 2;\n                        break;\n                    case 'bottom':\n                        y -= textRect.height - textRect.lineHeight / 2;\n                        break;\n                    default:\n                        y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            } else {\n                var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n            var textLines = text.split('\\n');\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n            ctx.restore();\n        }\n    };\n    return RectText;\n});\ndefine('zrender/Element', ['require', './core/guid', './mixin/Eventful', './mixin/Transformable', './mixin/Animatable', './core/util'], function (require) {\n    'use strict';\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n    Element.prototype = {\n        type: 'element',\n        name: '',\n        __zr: null,\n        ignore: false,\n        clipPath: null,\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n            case 'horizontal':\n                dy = 0;\n                break;\n            case 'vertical':\n                dx = 0;\n                break;\n            }\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0\n                ];\n            }\n            m[4] += dx;\n            m[5] += dy;\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n        beforeUpdate: function () {\n        },\n        afterUpdate: function () {\n        },\n        update: function () {\n            this.updateTransform();\n        },\n        traverse: function (cb, context) {\n        },\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            } else {\n                this[key] = value;\n            }\n        },\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            } else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n            this.dirty(false);\n            return this;\n        },\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n            this.dirty(false);\n        },\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n                this.dirty(false);\n            }\n        },\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n    return Element;\n});\ndefine('echarts/model/mixin/makeStyleMapper', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    return function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n                properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n});\ndefine('echarts/coord/cartesian/Cartesian', ['require', 'zrender/core/util'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n        this._dimList = [];\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n    Cartesian.prototype = {\n        constructor: Cartesian,\n        type: 'cartesian',\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(this.getAxes(), function (axis) {\n                return axis.scale.type === scaleType;\n            });\n        },\n        addAxis: function (axis) {\n            var dim = axis.dim;\n            this._axes[dim] = axis;\n            this._dimList.push(dim);\n        },\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n            var output = input instanceof Array ? [] : {};\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n                output[dim] = axis[method](input[dim]);\n            }\n            return output;\n        }\n    };\n    return Cartesian;\n});\ndefine('zrender/core/guid', [], function () {\n    var idStart = 2311;\n    return function () {\n        return idStart++;\n    };\n});\ndefine('zrender/mixin/Transformable', ['require', '../core/matrix', '../core/vector'], function (require) {\n    'use strict';\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n    var EPSILON = 0.00005;\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [\n                0,\n                0\n            ];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [\n                1,\n                1\n            ];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n    };\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n        m = m || matrix.create();\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        } else {\n            mIdentity(m);\n        }\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            } else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n        var origin = this.origin;\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n        m[4] += position[0];\n        m[5] += position[1];\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        } else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n    var tmpTransform = [];\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [\n                1,\n                1\n            ];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [\n            sx,\n            sy\n        ];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [\n                x,\n                y\n            ];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [\n                x,\n                y\n            ];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n    return Transformable;\n});\ndefine('zrender/mixin/Animatable', ['require', '../animation/Animator', '../core/util', '../core/log'], function (require) {\n    'use strict';\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n    Animatable.prototype = {\n        constructor: Animatable,\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            } else {\n                target = el;\n            }\n            if (!target) {\n                log('Property \"' + path + '\" is not existed in element ' + el.id);\n                return;\n            }\n            var animators = el.animators;\n            var animator = new Animator(target, loop);\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            }).done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n            animators.push(animator);\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n            return animator;\n        },\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n            return this;\n        },\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }    // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }    // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }    // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }    // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i].done(done).start(easing);\n            }\n        },\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n                    } else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                } else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    } else {\n                        // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n            if (propertyCount > 0) {\n                this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n            }\n            return this;\n        }\n    };\n    return Animatable;\n});\ndefine('echarts/util/component', ['require', 'zrender/core/util', './clazz'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazz = require('./clazz');\n    var parseClassType = clazz.parseClassType;\n    var base = 0;\n    var componentUtil = {};\n    var DELIMITER = '_';\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [\n            type || '',\n            base++,\n            Math.random()\n        ].join(DELIMITER);\n    };\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n        var subTypeDefaulters = {};\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n        return entity;\n    };\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n            }\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n            zrUtil.each(fullNameList, function (name) {\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n            return {\n                graph: graph,\n                noEntryList: noEntryList\n            };\n        }\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {\n                    predecessor: [],\n                    successor: []\n                };\n            }\n            return graph[name];\n        }\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n    return componentUtil;\n});\ndefine('echarts/model/mixin/boxLayout', ['require'], function (require) {\n    return {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n});\ndefine('echarts/coord/Axis', ['require', '../util/number', 'zrender/core/util'], function (require) {\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/core/util');\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n    var normalizedExtent = [\n            0,\n            1\n        ];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [\n            0,\n            0\n        ];\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n    Axis.prototype = {\n        constructor: Axis,\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n        },\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n            return this.scale.scale(t);\n        },\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            } else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n            return Math.abs(size) / len;\n        }\n    };\n    return Axis;\n});\ndefine('echarts/coord/cartesian/axisLabelInterval', ['require', 'zrender/core/util', '../axisHelper'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var axisHelper = require('../axisHelper');\n    return function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n        return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());\n    };\n});\ndefine('zrender/core/log', ['require', '../config'], function (require) {\n    var config = require('../config');\n    /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n    return function () {\n        if (config.debugMode === 0) {\n            return;\n        } else if (config.debugMode == 1) {\n            for (var k in arguments) {\n                throw new Error(arguments[k]);\n            }\n        } else if (config.debugMode > 1) {\n            for (var k in arguments) {\n                console.log(arguments[k]);\n            }\n        }\n    };    /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>' \n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n});\ndefine('zrender/animation/Animator', ['require', './Clip', '../tool/color', '../core/util'], function (require) {\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n    var arraySlice = Array.prototype.slice;\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        } else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n                }\n            }\n        }\n    }\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            } else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            } else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        } else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n            }\n        } else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n                }\n            }\n        }\n    }\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n            return arraySlice.call(value);\n        }\n        return value;\n    }\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n        // For vertices morphing\n        var arrDim = isValueArray && isArrayLike(firstVal[0]) ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function (a, b) {\n            return a.time - b.time;\n        });\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n            // Check if value is equal, deep check if value is array\n            if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                } else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            } else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n        if (isValueColor) {\n            var rgba = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n        }\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            } else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            } else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n            var range = kfPercents[frame + 1] - kfPercents[frame];\n            if (range === 0) {\n                return;\n            } else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n                } else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n                        value = rgba2String(rgba);\n                    } else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    } else {\n                        value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n                    }\n                    setter(target, propName, value);\n                }\n            } else {\n                if (isValueArray) {\n                    interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n                } else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n                        value = rgba2String(rgba);\n                    } else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    } else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(target, propName, value);\n                }\n            }\n        };\n        var clip = new Clip({\n                target: animator._target,\n                life: trackMaxTime,\n                loop: animator._loop,\n                delay: animator._delay,\n                onframe: onframe,\n                ondestroy: oneTrackDone\n            });\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n        return clip;\n    }\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function (target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n        this._loop = loop || false;\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n        this._clipCount = 0;\n        this._delay = 0;\n        this._doneList = [];\n        this._onframeList = [];\n        this._clipList = [];\n    };\n    Animator.prototype = {\n        when: function (time, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        start: function (easing) {\n            var self = this;\n            var clipCount = 0;\n            var oneTrackDone = function () {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n            var lastClip;\n            for (var propName in this._tracks) {\n                var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n                    lastClip = clip;\n                }\n            }\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        done: function (cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n    return Animator;\n});\ndefine('echarts/coord/cartesian/AxisModel', ['require', '../../model/Component', 'zrender/core/util', '../axisModelCreator', '../axisModelCommonMixin'], function (require) {\n    'use strict';\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n    var AxisModel = ComponentModel.extend({\n            type: 'cartesian2dAxis',\n            axis: null,\n            init: function () {\n                AxisModel.superApply(this, 'init', arguments);\n                this._resetRange();\n            },\n            mergeOption: function () {\n                AxisModel.superApply(this, 'mergeOption', arguments);\n                this._resetRange();\n            },\n            restoreData: function () {\n                AxisModel.superApply(this, 'restoreData', arguments);\n                this._resetRange();\n            },\n            setRange: function (rangeStart, rangeEnd) {\n                this.option.rangeStart = rangeStart;\n                this.option.rangeEnd = rangeEnd;\n            },\n            getMin: function () {\n                var option = this.option;\n                return option.rangeStart != null ? option.rangeStart : option.min;\n            },\n            getMax: function () {\n                var option = this.option;\n                return option.rangeEnd != null ? option.rangeEnd : option.max;\n            },\n            getNeedCrossZero: function () {\n                var option = this.option;\n                return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n            },\n            findGridModel: function () {\n                return this.ecModel.queryComponents({\n                    mainType: 'grid',\n                    index: this.get('gridIndex'),\n                    id: this.get('gridId')\n                })[0];\n            },\n            _resetRange: function () {\n                // rangeStart and rangeEnd is readonly.\n                this.option.rangeStart = this.option.rangeEnd = null;\n            }\n        });\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n    var extraOption = { offset: 0 };\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n    return AxisModel;\n});\ndefine('zrender/animation/Clip', ['require', './easing'], function (require) {\n    var easingFuncs = require('./easing');\n    function Clip(options) {\n        this._target = options.target;\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n        // \n        this.loop = options.loop == null ? false : options.loop;\n        this.gap = options.gap || 0;\n        this.easing = options.easing || 'Linear';\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n    Clip.prototype = {\n        constructor: Clip,\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n            var percent = (globalTime - this._startTime) / this._life;\n            // \n            if (percent < 0) {\n                return;\n            }\n            percent = Math.min(percent, 1);\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n            this.fire('frame', schedule);\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart(globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n            return null;\n        },\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._needsRemove = false;\n        },\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n    return Clip;\n});\ndefine('echarts/coord/axisModelCreator', ['require', './axisDefault', 'zrender/core/util', '../model/Component', '../util/layout'], function (require) {\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = [\n            'value',\n            'category',\n            'time',\n            'log'\n        ];\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    return function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n            BaseAxisModelClass.extend({\n                type: axisName + 'Axis.' + axisType,\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n                    option.type = axisTypeDefaulter(axisName, option);\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n                defaultOption: zrUtil.mergeAll([\n                    {},\n                    axisDefault[axisType + 'Axis'],\n                    extraDefaultOption\n                ], true)\n            });\n        });\n        ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n    };\n});\ndefine('echarts/coord/axisModelCommonMixin', ['require', 'zrender/core/util', './axisHelper'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var axisHelper = require('./axisHelper');\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        } else {\n            return obj;\n        }\n    }\n    /**\n     * Get categories\n     */\n    function getCategories() {\n        return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n    }\n    /**\n     * Format labels\n     * @return {Array.<string>}\n     */\n    function getFormattedLabels() {\n        return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n    }\n    return {\n        getFormattedLabels: getFormattedLabels,\n        getCategories: getCategories\n    };\n});\ndefine('zrender/animation/easing', [], function () {\n    var easing = {\n            linear: function (k) {\n                return k;\n            },\n            quadraticIn: function (k) {\n                return k * k;\n            },\n            quadraticOut: function (k) {\n                return k * (2 - k);\n            },\n            quadraticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k;\n                }\n                return -0.5 * (--k * (k - 2) - 1);\n            },\n            cubicIn: function (k) {\n                return k * k * k;\n            },\n            cubicOut: function (k) {\n                return --k * k * k + 1;\n            },\n            cubicInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k;\n                }\n                return 0.5 * ((k -= 2) * k * k + 2);\n            },\n            quarticIn: function (k) {\n                return k * k * k * k;\n            },\n            quarticOut: function (k) {\n                return 1 - --k * k * k * k;\n            },\n            quarticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k;\n                }\n                return -0.5 * ((k -= 2) * k * k * k - 2);\n            },\n            quinticIn: function (k) {\n                return k * k * k * k * k;\n            },\n            quinticOut: function (k) {\n                return --k * k * k * k * k + 1;\n            },\n            quinticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k * k;\n                }\n                return 0.5 * ((k -= 2) * k * k * k * k + 2);\n            },\n            sinusoidalIn: function (k) {\n                return 1 - Math.cos(k * Math.PI / 2);\n            },\n            sinusoidalOut: function (k) {\n                return Math.sin(k * Math.PI / 2);\n            },\n            sinusoidalInOut: function (k) {\n                return 0.5 * (1 - Math.cos(Math.PI * k));\n            },\n            exponentialIn: function (k) {\n                return k === 0 ? 0 : Math.pow(1024, k - 1);\n            },\n            exponentialOut: function (k) {\n                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n            },\n            exponentialInOut: function (k) {\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if ((k *= 2) < 1) {\n                    return 0.5 * Math.pow(1024, k - 1);\n                }\n                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n            },\n            circularIn: function (k) {\n                return 1 - Math.sqrt(1 - k * k);\n            },\n            circularOut: function (k) {\n                return Math.sqrt(1 - --k * k);\n            },\n            circularInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return -0.5 * (Math.sqrt(1 - k * k) - 1);\n                }\n                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n            },\n            elasticIn: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n            },\n            elasticOut: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n            },\n            elasticInOut: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                if ((k *= 2) < 1) {\n                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n                }\n                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n            },\n            backIn: function (k) {\n                var s = 1.70158;\n                return k * k * ((s + 1) * k - s);\n            },\n            backOut: function (k) {\n                var s = 1.70158;\n                return --k * k * ((s + 1) * k + s) + 1;\n            },\n            backInOut: function (k) {\n                var s = 1.70158 * 1.525;\n                if ((k *= 2) < 1) {\n                    return 0.5 * (k * k * ((s + 1) * k - s));\n                }\n                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n            },\n            bounceIn: function (k) {\n                return 1 - easing.bounceOut(1 - k);\n            },\n            bounceOut: function (k) {\n                if (k < 1 / 2.75) {\n                    return 7.5625 * k * k;\n                } else if (k < 2 / 2.75) {\n                    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n                } else if (k < 2.5 / 2.75) {\n                    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n                } else {\n                    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n                }\n            },\n            bounceInOut: function (k) {\n                if (k < 0.5) {\n                    return easing.bounceIn(k * 2) * 0.5;\n                }\n                return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n            }\n        };\n    return easing;\n});\ndefine('echarts/coord/axisDefault', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var defaultOption = {\n            show: true,\n            zlevel: 0,\n            z: 0,\n            inverse: false,\n            name: '',\n            nameLocation: 'end',\n            nameRotate: null,\n            nameTruncate: {\n                maxWidth: null,\n                ellipsis: '...',\n                placeholder: '.'\n            },\n            nameTextStyle: {},\n            nameGap: 15,\n            silent: false,\n            triggerEvent: false,\n            tooltip: { show: false },\n            axisLine: {\n                show: true,\n                onZero: true,\n                lineStyle: {\n                    color: '#333',\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            axisTick: {\n                show: true,\n                inside: false,\n                length: 5,\n                lineStyle: { width: 1 }\n            },\n            axisLabel: {\n                show: true,\n                inside: false,\n                rotate: 0,\n                margin: 8,\n                textStyle: { fontSize: 12 }\n            },\n            splitLine: {\n                show: true,\n                lineStyle: {\n                    color: ['#ccc'],\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            splitArea: {\n                show: false,\n                areaStyle: {\n                    color: [\n                        'rgba(250,250,250,0.3)',\n                        'rgba(200,200,200,0.3)'\n                    ]\n                }\n            }\n        };\n    var categoryAxis = zrUtil.merge({\n            boundaryGap: true,\n            splitLine: { show: false },\n            axisTick: {\n                alignWithLabel: false,\n                interval: 'auto'\n            },\n            axisLabel: { interval: 'auto' }\n        }, defaultOption);\n    var valueAxis = zrUtil.merge({\n            boundaryGap: [\n                0,\n                0\n            ],\n            splitNumber: 5\n        }, defaultOption);\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n            scale: true,\n            min: 'dataMin',\n            max: 'dataMax'\n        }, valueAxis);\n    var logAxis = zrUtil.defaults({ logBase: 10 }, valueAxis);\n    logAxis.scale = true;\n    return {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n});\ndefine('zrender/config', [], function () {\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n            debugMode: 0,\n            devicePixelRatio: dpr\n        };\n    return config;\n});\ndefine('echarts/chart/helper/createListFromArray', ['require', '../../data/List', '../../data/helper/completeDimensions', 'zrender/core/util', '../../util/model', '../../CoordinateSystem'], function (require) {\n    'use strict';\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = registeredCoordSys && registeredCoordSys.dimensions || [\n                'x',\n                'y'\n            ];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n        var list = new List(dimensions, seriesModel);\n        var nameList = createNameList(axesInfo, data);\n        var categories = {};\n        var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            } : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n        return list;\n    }\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n    }\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n            cartesian2d: function (data, seriesModel, ecModel) {\n                var axesModels = zrUtil.map([\n                        'xAxis',\n                        'yAxis'\n                    ], function (name) {\n                        return ecModel.queryComponents({\n                            mainType: name,\n                            index: seriesModel.get(name + 'Index'),\n                            id: seriesModel.get(name + 'Id')\n                        })[0];\n                    });\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n                if (true) {\n                    if (!xAxisModel) {\n                        throw new Error('xAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n                    }\n                    if (!yAxisModel) {\n                        throw new Error('yAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n                    }\n                }\n                var xAxisType = xAxisModel.get('type');\n                var yAxisType = yAxisModel.get('type');\n                var dimensions = [\n                        {\n                            name: 'x',\n                            type: getDimTypeByAxis(xAxisType),\n                            stackable: isStackable(xAxisType)\n                        },\n                        {\n                            name: 'y',\n                            type: getDimTypeByAxis(yAxisType),\n                            stackable: isStackable(yAxisType)\n                        }\n                    ];\n                var isXAxisCateogry = xAxisType === 'category';\n                var isYAxisCategory = yAxisType === 'category';\n                completeDimensions(dimensions, data, [\n                    'x',\n                    'y',\n                    'z'\n                ]);\n                var categoryAxesModels = {};\n                if (isXAxisCateogry) {\n                    categoryAxesModels.x = xAxisModel;\n                }\n                if (isYAxisCategory) {\n                    categoryAxesModels.y = yAxisModel;\n                }\n                return {\n                    dimensions: dimensions,\n                    categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n                    categoryAxesModels: categoryAxesModels\n                };\n            },\n            polar: function (data, seriesModel, ecModel) {\n                var polarModel = ecModel.queryComponents({\n                        mainType: 'polar',\n                        index: seriesModel.get('polarIndex'),\n                        id: seriesModel.get('polarId')\n                    })[0];\n                var angleAxisModel = polarModel.findAxisModel('angleAxis');\n                var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n                if (true) {\n                    if (!angleAxisModel) {\n                        throw new Error('angleAxis option not found');\n                    }\n                    if (!radiusAxisModel) {\n                        throw new Error('radiusAxis option not found');\n                    }\n                }\n                var radiusAxisType = radiusAxisModel.get('type');\n                var angleAxisType = angleAxisModel.get('type');\n                var dimensions = [\n                        {\n                            name: 'radius',\n                            type: getDimTypeByAxis(radiusAxisType),\n                            stackable: isStackable(radiusAxisType)\n                        },\n                        {\n                            name: 'angle',\n                            type: getDimTypeByAxis(angleAxisType),\n                            stackable: isStackable(angleAxisType)\n                        }\n                    ];\n                var isAngleAxisCateogry = angleAxisType === 'category';\n                var isRadiusAxisCateogry = radiusAxisType === 'category';\n                completeDimensions(dimensions, data, [\n                    'radius',\n                    'angle',\n                    'value'\n                ]);\n                var categoryAxesModels = {};\n                if (isRadiusAxisCateogry) {\n                    categoryAxesModels.radius = radiusAxisModel;\n                }\n                if (isAngleAxisCateogry) {\n                    categoryAxesModels.angle = angleAxisModel;\n                }\n                return {\n                    dimensions: dimensions,\n                    categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n                    categoryAxesModels: categoryAxesModels\n                };\n            },\n            geo: function (data, seriesModel, ecModel) {\n                // TODO Region\n                // \n                return {\n                    dimensions: completeDimensions([\n                        { name: 'lng' },\n                        { name: 'lat' }\n                    ], data, [\n                        'lng',\n                        'lat',\n                        'value'\n                    ])\n                };\n            }\n        };\n    function createNameList(result, data) {\n        var nameList = [];\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                } else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n        return nameList;\n    }\n    return createListFromArray;\n});\ndefine('zrender/core/curve', ['require', './vector'], function (require) {\n    'use strict';\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 0.0001;\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1 - p0);\n        var d = p0 - val;\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n        var n = 0;\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            } else {\n                var t1 = -c / b;\n                //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        } else {\n            var disc = B * B - 4 * A * C;\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;\n                // t1, a is not zero\n                var t2 = -K / 2;\n                // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                } else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                } else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            } else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n            }\n        } else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n        _v0[0] = x;\n        _v0[1] = y;\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n            d1 = v2DistSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            } else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                } else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        } else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        } else {\n            return (p0 - p1) / divider;\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        _v0[0] = x;\n        _v0[1] = y;\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n            var d1 = v2DistSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            } else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                } else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n    return {\n        cubicAt: cubicAt,\n        cubicDerivativeAt: cubicDerivativeAt,\n        cubicRootAt: cubicRootAt,\n        cubicExtrema: cubicExtrema,\n        cubicSubdivide: cubicSubdivide,\n        cubicProjectPoint: cubicProjectPoint,\n        quadraticAt: quadraticAt,\n        quadraticDerivativeAt: quadraticDerivativeAt,\n        quadraticRootAt: quadraticRootAt,\n        quadraticExtremum: quadraticExtremum,\n        quadraticSubdivide: quadraticSubdivide,\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n});\ndefine('zrender/core/bbox', ['require', './vector', './curve'], function (require) {\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function (points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function (x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n        var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff % PI2 < 0.0001 && diff > 0.0001) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % PI2;\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % PI2;\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        } else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n    return bbox;\n});\ndefine('echarts/data/DataDiffer', ['require'], function (require) {\n    'use strict';\n    function defaultKeyGetter(item) {\n        return item;\n    }\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n    DataDiffer.prototype = {\n        constructor: DataDiffer,\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    } else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                } else {\n                    this._remove && this._remove(i);\n                }\n            }\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    } else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            } else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n    return DataDiffer;\n});\ndefine('echarts/data/helper/completeDimensions', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || extraPrefix + (i - defaultNames.length);\n                dimensions[i] = guessOrdinal(data, i) ? {\n                    type: 'ordinal',\n                    name: name\n                } : name;\n            }\n        }\n        return dimensions;\n    }\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                var value = retrieveValue(data[i]);\n                if (!zrUtil.isArray(value)) {\n                    return false;\n                }\n                var value = value[dimIndex];\n                if (value != null && isFinite(value)) {\n                    return false;\n                } else if (zrUtil.isString(value) && value !== '-') {\n                    return true;\n                }\n            }\n            return false;\n        };\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n    }\n    return completeDimensions;\n});\ndefine('zrender/contain/cubic', ['require', '../core/curve'], function (require) {\n    var curve = require('../core/curve');\n    return {\n        containStroke: function (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n            return d <= _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/line', [], function () {\n    return {\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n                return false;\n            }\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n            } else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/quadratic', ['require', '../core/curve'], function (require) {\n    var curve = require('../core/curve');\n    return {\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n            return d <= _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/arc', ['require', './util'], function (require) {\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n    return {\n        containStroke: function (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n            if (d - _l > r || d + _l < r) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 0.0001) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n        }\n    };\n});\ndefine('zrender/contain/util', ['require'], function (require) {\n    var PI2 = Math.PI * 2;\n    return {\n        normalizeRadian: function (angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n});\ndefine('zrender/contain/windingLine', [], function () {\n    return function windingLine(x0, y0, x1, y1, x, y) {\n        if (y > y0 && y > y1 || y < y0 && y < y1) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n        var x_ = t * (x1 - x0) + x0;\n        return x_ > x ? dir : 0;\n    };\n});\ndefine('echarts/chart/bar/barItemStyle', ['require', '../../model/mixin/makeStyleMapper'], function (require) {\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            [\n                'stroke',\n                'borderColor'\n            ],\n            [\n                'lineWidth',\n                'borderWidth'\n            ],\n            [\n                'stroke',\n                'barBorderColor'\n            ],\n            [\n                'lineWidth',\n                'barBorderWidth'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n});\ndefine('zrender/core/LRU', ['require'], function (require) {\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n        this._len = 0;\n    };\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        } else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        } else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        } else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n        this._list = new LinkedList();\n        this._map = {};\n        this._maxSize = maxSize || 10;\n    };\n    var LRUProto = LRU.prototype;\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n            return entry.value;\n        }\n    };\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n    return LRU;\n});\ndefine('zrender/graphic/helper/poly', ['require', './smoothSpline', './smoothBezier'], function (require) {\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n    return {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n                    }\n                } else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n                closePath && ctx.closePath();\n            }\n        }\n    };\n});\ndefine('zrender/graphic/helper/smoothSpline', ['require', '../../core/vector'], function (require) {\n    var vec2 = require('../../core/vector');\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    return function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n            var w = pos - idx;\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            } else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n            var w2 = w * w;\n            var w3 = w * w2;\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n});\ndefine('zrender/graphic/helper/smoothBezier', ['require', '../../core/vector'], function (require) {\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    return function (points, smooth, isLoop, constraint) {\n        var cps = [];\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n        var min, max;\n        if (constraint) {\n            min = [\n                Infinity,\n                Infinity\n            ];\n            max = [\n                -Infinity,\n                -Infinity\n            ];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            } else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                } else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n            vec2.sub(v, nextPoint, prevPoint);\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n        return cps;\n    };\n});\ndefine('zrender/graphic/helper/roundRect', ['require'], function (require) {\n    return {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            } else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                } else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                } else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                } else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            } else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n});\ndefine('zrender/Storage', ['require', './core/util', './core/env', './container/Group', './core/timsort'], function (require) {\n    'use strict';\n    var util = require('./core/util');\n    var env = require('./core/env');\n    var Group = require('./container/Group');\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // idmap\n        this._elements = {};\n        this._roots = [];\n        this._displayList = [];\n        this._displayListLen = 0;\n    };\n    Storage.prototype = {\n        constructor: Storage,\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n            el.beforeUpdate();\n            if (el.__dirty) {\n                el.update();\n            }\n            el.afterUpdate();\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath  group \n                clipPath.parent = el;\n                clipPath.updateTransform();\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                } else {\n                    clipPaths = [clipPath];\n                }\n            }\n            if (el.isGroup) {\n                var children = el._children;\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n                // Mark group clean here\n                el.__dirty = false;\n            } else {\n                el.__clipPaths = clipPaths;\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n        delRoot: function (elId) {\n            if (elId == null) {\n                // elId\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n                return;\n            }\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n            var el;\n            if (typeof elId == 'string') {\n                el = this._elements[elId];\n            } else {\n                el = elId;\n            }\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n            this._elements[el.id] = el;\n            return this;\n        },\n        get: function (elId) {\n            return this._elements[elId];\n        },\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n            return this;\n        },\n        dispose: function () {\n            this._elements = this._renderList = this._roots = null;\n        },\n        displayableSortFunc: shapeCompareFunc\n    };\n    return Storage;\n});\ndefine('zrender/Handler', ['require', './core/util', './mixin/Draggable', './mixin/Eventful'], function (require) {\n    'use strict';\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n    var Eventful = require('./mixin/Eventful');\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta\n        };\n    }\n    function EmptyProxy() {\n    }\n    EmptyProxy.prototype.dispose = function () {\n    };\n    var handlerNames = [\n            'click',\n            'dblclick',\n            'mousewheel',\n            'mouseout',\n            'mouseup',\n            'mousedown',\n            'mousemove'\n        ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {HTMLElement} root Main HTML element for painting.\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     */\n    var Handler = function (storage, painter, proxy) {\n        Eventful.call(this);\n        this.storage = storage;\n        this.painter = painter;\n        proxy = proxy || new EmptyProxy();\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n        // Attach handler\n        proxy.handler = this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n        Draggable.call(this);\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n    Handler.prototype = {\n        constructor: Handler,\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n            this._hovered = hovered;\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n            this.trigger('globalout', { event: event });\n        },\n        resize: function (event) {\n            this._hovered = null;\n        },\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n        dispose: function () {\n            this.proxy.dispose();\n            this.storage = this.proxy = this.painter = null;\n        },\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n            var el = targetEl;\n            while (el) {\n                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n                el.trigger(eventName, eventPacket);\n                el = el.parent;\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof layer[eventHandler] == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n        findHover: function (x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0; i--) {\n                if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n    // Common handlers\n    util.each([\n        'click',\n        'mousedown',\n        'mouseup',\n        'mousewheel',\n        'dblclick'\n    ], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            } else if (name === 'mosueup') {\n                this._upel = hovered;\n            } else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || el.clipPath && !el.clipPath.contain(x, y)) {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n        return false;\n    }\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n    return Handler;\n});\ndefine('zrender/animation/Animation', ['require', '../core/util', '../core/event', './requestAnimationFrame', './Animator'], function (require) {\n    'use strict';\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n    var requestAnimationFrame = require('./requestAnimationFrame');\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n        options = options || {};\n        this.stage = options.stage || {};\n        this.onframe = options.onframe || function () {\n        };\n        // private properties\n        this._clips = [];\n        this._running = false;\n        this._time;\n        this._pausedTime;\n        this._pauseStart;\n        this._paused = false;\n        Dispatcher.call(this);\n    };\n    Animation.prototype = {\n        constructor: Animation,\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        removeClip: function (clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n        _update: function () {\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                } else {\n                    i++;\n                }\n            }\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n            this._time = time;\n            this.onframe(delta);\n            this.trigger('frame', delta);\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n        _startLoop: function () {\n            var self = this;\n            this._running = true;\n            function step() {\n                if (self._running) {\n                    requestAnimationFrame(step);\n                    !self._paused && self._update();\n                }\n            }\n            requestAnimationFrame(step);\n        },\n        start: function () {\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n            this._startLoop();\n        },\n        stop: function () {\n            this._running = false;\n        },\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += new Date().getTime() - this._pauseStart;\n                this._paused = false;\n            }\n        },\n        clear: function () {\n            this._clips = [];\n        },\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(target, options.loop, options.getter, options.setter);\n            return animator;\n        }\n    };\n    util.mixin(Animation, Dispatcher);\n    return Animation;\n});\ndefine('zrender/dom/HandlerProxy', ['require', '../core/event', '../core/util', '../mixin/Eventful', '../core/env', '../core/GestureMgr'], function (require) {\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n    var TOUCH_CLICK_DELAY = 300;\n    var mouseHandlerNames = [\n            'click',\n            'dblclick',\n            'mousewheel',\n            'mouseout',\n            'mouseup',\n            'mousedown',\n            'mousemove'\n        ];\n    var touchHandlerNames = [\n            'touchstart',\n            'touchend',\n            'touchmove'\n        ];\n    function eventNameFix(name) {\n        return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n    }\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n        stage === 'start' && gestureMgr.clear();\n        var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null), proxy.dom);\n        stage === 'end' && gestureMgr.clear();\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n    var domHandlers = {\n            mousemove: function (event) {\n                event = normalizeEvent(this.dom, event);\n                this.trigger('mousemove', event);\n            },\n            mouseout: function (event) {\n                event = normalizeEvent(this.dom, event);\n                var element = event.toElement || event.relatedTarget;\n                if (element != this.dom) {\n                    while (element && element.nodeType != 9) {\n                        // rootdommouseOut\n                        if (element === this.dom) {\n                            return;\n                        }\n                        element = element.parentNode;\n                    }\n                }\n                this.trigger('mouseout', event);\n            },\n            touchstart: function (event) {\n                // Default mouse behaviour should not be disabled here.\n                // For example, page may needs to be slided.\n                event = normalizeEvent(this.dom, event);\n                this._lastTouchMoment = new Date();\n                processGesture(this, event, 'start');\n                // findHover\n                // this._mobileFindFixed(event);\n                // Trigger mousemove and mousedown\n                domHandlers.mousemove.call(this, event);\n                domHandlers.mousedown.call(this, event);\n                setTouchTimer(this);\n            },\n            touchmove: function (event) {\n                event = normalizeEvent(this.dom, event);\n                processGesture(this, event, 'change');\n                // Mouse move should always be triggered no matter whether\n                // there is gestrue event, because mouse move and pinch may\n                // be used at the same time.\n                domHandlers.mousemove.call(this, event);\n                setTouchTimer(this);\n            },\n            touchend: function (event) {\n                event = normalizeEvent(this.dom, event);\n                processGesture(this, event, 'end');\n                domHandlers.mouseup.call(this, event);\n                // click event should always be triggered no matter whether\n                // there is gestrue event. System click can not be prevented.\n                if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                    domHandlers.click.call(this, event);\n                }\n                setTouchTimer(this);\n            }\n        };\n    // Common handlers\n    zrUtil.each([\n        'click',\n        'mousedown',\n        'mouseup',\n        'mousewheel',\n        'dblclick'\n    ], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        for (var i = 0; i < touchHandlerNames.length; i++) {\n            var name = touchHandlerNames[i];\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        }\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n        this.dom = dom;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n        this._handlers = {};\n        initDomHandler(this);\n        if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);    // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                                                       // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n    return HandlerDomProxy;\n});\ndefine('zrender/Painter', ['require', './config', './core/util', './core/log', './core/BoundingRect', './core/timsort', './Layer', './animation/requestAnimationFrame', './graphic/Image'], function (require) {\n    'use strict';\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n    var Layer = require('./Layer');\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n        if (layer.isBuildin) {\n            return true;\n        }\n        if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n            return false;\n        }\n        return true;\n    }\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) {\n            // Can both be null or undefined\n            return false;\n        }\n        if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n        var domRootStyle = domRoot.style;\n        // domRoot.onselectstart = returnFalse; // \n        domRootStyle.position = 'relative';\n        domRootStyle.overflow = 'hidden';\n        domRootStyle.width = width + 'px';\n        domRootStyle.height = height + 'px';\n        return domRoot;\n    }\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';\n        opts = opts || {};\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n        var rootStyle = root.style;\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n            root.innerHTML = '';\n        }\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n        if (!singleCanvas) {\n            this._width = this._getWidth();\n            this._height = this._getHeight();\n            var domRoot = this._domRoot = createRoot(this._width, this._height);\n            root.appendChild(domRoot);\n        } else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n        }\n        this.pathToImage = this._createPathToImage();\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n        this._hoverElements = [];\n    };\n    Painter.prototype = {\n        constructor: Painter,\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n        refresh: function (paintAll) {\n            var list = this.storage.getDisplayList(true);\n            var zlevelList = this._zlevelList;\n            this._paintList(list, paintAll);\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n            this.refreshHover();\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n            return this;\n        },\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                    style: el.style,\n                    shape: el.shape\n                });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(100000);\n            }\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n        _startProgessive: function () {\n            var self = this;\n            if (!self._furtherProgressive) {\n                return;\n            }\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n            self._progress++;\n            requestAnimationFrame(step);\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n                    self._doPaintList(self.storage.getDisplayList());\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    } else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n        _paintList: function (list, paintAll) {\n            if (paintAll == null) {\n                paintAll = false;\n            }\n            this._updateLayerStatus(list);\n            this._clearProgressive();\n            this.eachBuildinLayer(preProcessLayer);\n            this._doPaintList(list, paintAll);\n            this.eachBuildinLayer(postProcessLayer);\n        },\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n            // var invTransform = [];\n            var scope;\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n                var elFrame = el.__frame;\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n                    // Reset scope\n                    scope = {};\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n                    if (!currentLayer.isBuildin) {\n                        log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n                    }\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n                        if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n                        layerProgress = currentProgressiveLayer.__progress;\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                } else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n                el.__dirty = false;\n            }\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n                var clipPaths = el.__clipPaths;\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n                this.insertLayer(zlevel, layer);\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n            return layer;\n        },\n        insertLayer: function (zlevel, layer) {\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n                } else {\n                    domRoot.appendChild(layer.dom);\n                }\n            } else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                } else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            layersMap[zlevel] = layer;\n        },\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n        getLayers: function () {\n            return this._layers;\n        },\n        _updateLayerStatus: function (list) {\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n                    currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                } else {\n                    el.__frame = -1;\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n            // \n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                } else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n                var layer = this._layers[zlevel];\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n            width = width || this._getWidth();\n            height = height || this._getHeight();\n            domRoot.style.display = '';\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n                for (var id in this._layers) {\n                    this._layers[id].resize(width, height);\n                }\n                this.refresh(true);\n            }\n            this._width = width;\n            this._height = height;\n            return this;\n        },\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n        dispose: function () {\n            this.root.innerHTML = '';\n            this.root = this.storage = this._domRoot = this._layers = null;\n        },\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n            var displayList = this.storage.getDisplayList(true);\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n            return imageLayer.dom;\n        },\n        getWidth: function () {\n            return this._width;\n        },\n        getHeight: function () {\n            return this._height;\n        },\n        _getWidth: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            // FIXME Better way to get the width and height when element has not been append to the document\n            return (root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0) | 0;\n        },\n        _getHeight: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            return (root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0) | 0;\n        },\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n            var pathTransform = {\n                    position: path.position,\n                    rotation: path.rotation,\n                    scale: path.scale\n                };\n            path.position = [\n                0,\n                0,\n                0\n            ];\n            path.rotation = 0;\n            path.scale = [\n                1,\n                1\n            ];\n            if (path) {\n                path.brush(ctx);\n            }\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                    id: id,\n                    style: {\n                        x: 0,\n                        y: 0,\n                        image: canvas\n                    }\n                });\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n            return imgShape;\n        },\n        _createPathToImage: function () {\n            var me = this;\n            return function (id, e, width, height) {\n                return me._pathToImage(id, e, width, height, me.dpr);\n            };\n        }\n    };\n    return Painter;\n});\ndefine('zrender/mixin/Draggable', ['require'], function (require) {\n    function Draggable() {\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);    // this._dropTarget = null;\n                                                      // this._draggingTarget = null;\n                                                      // this._x = 0;\n                                                      // this._y = 0;\n    }\n    Draggable.prototype = {\n        constructor: Draggable,\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                var x = e.offsetX;\n                var y = e.offsetY;\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n    };\n    return Draggable;\n});\ndefine('zrender/core/event', ['require', '../mixin/Eventful'], function (require) {\n    'use strict';\n    var Eventful = require('../mixin/Eventful');\n    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n            left: 0,\n            top: 0\n        };\n    }\n    function clientToLocal(el, e, out) {\n        // clientX/clientY is according to view port.\n        var box = getBoundingClientRect(el);\n        out = out || {};\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n        return out;\n    }\n    /**\n     * domtouch\n     */\n    function normalizeEvent(el, e) {\n        e = e || window.event;\n        if (e.zrX != null) {\n            return e;\n        }\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n        if (!isTouch) {\n            clientToLocal(el, e, e);\n            e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        } else {\n            var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e);\n        }\n        return e;\n    }\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        } else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        } else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2 ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        } : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n    return {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        stop: stop,\n        Dispatcher: Eventful\n    };\n});\ndefine('zrender/animation/requestAnimationFrame', ['require'], function (require) {\n    return typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n        setTimeout(func, 16);\n    };\n});\ndefine('zrender/core/GestureMgr', ['require', './event'], function (require) {\n    'use strict';\n    var eventUtil = require('./event');\n    var GestureMgr = function () {\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n    GestureMgr.prototype = {\n        constructor: GestureMgr,\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n            if (!touches) {\n                return;\n            }\n            var trackItem = {\n                    points: [],\n                    touches: [],\n                    target: target,\n                    event: event\n                };\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch);\n                trackItem.points.push([\n                    pos.zrX,\n                    pos.zrY\n                ]);\n                trackItem.touches.push(touch);\n            }\n            this._track.push(trackItem);\n        },\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n    var recognizers = {\n            pinch: function (track, event) {\n                var trackLen = track.length;\n                if (!trackLen) {\n                    return;\n                }\n                var pinchEnd = (track[trackLen - 1] || {}).points;\n                var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n                if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n                    var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                    !isFinite(pinchScale) && (pinchScale = 1);\n                    event.pinchScale = pinchScale;\n                    var pinchCenter = center(pinchEnd);\n                    event.pinchX = pinchCenter[0];\n                    event.pinchY = pinchCenter[1];\n                    return {\n                        type: 'pinch',\n                        target: track[0].target,\n                        event: event\n                    };\n                }\n            }    // Only pinch currently.\n        };\n    return GestureMgr;\n});\ndefine('zrender/Layer', ['require', './core/util', './config', './graphic/Style', './graphic/Pattern'], function (require) {\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n    function returnFalse() {\n        return false;\n    }\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function (id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }    // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n        var domStyle = dom.style;\n        if (domStyle) {\n            // Not in node\n            dom.onselectstart = returnFalse;\n            // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n        }\n        this.domBack = null;\n        this.ctxBack = null;\n        this.painter = painter;\n        this.config = null;\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n    Layer.prototype = {\n        constructor: Layer,\n        elCount: 0,\n        __dirty: true,\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n            this.ctx.dpr = this.dpr;\n        },\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n        resize: function (width, height) {\n            var dpr = this.dpr;\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n            var dpr = this.dpr;\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n            }\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }    // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n    return Layer;\n});\ndefine('echarts/preprocessor/helper/compatStyle', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var POSSIBLE_STYLES = [\n            'areaStyle',\n            'lineStyle',\n            'nodeStyle',\n            'linkStyle',\n            'chordStyle',\n            'label',\n            'labelLine'\n        ];\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    } else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    } else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n    return function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    } else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n});\ndefine('echarts/component/helper/selectableMixin', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    return {\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n});\ndefine('echarts/component/axis/AxisView', ['require', 'zrender/core/util', '../../util/graphic', './AxisBuilder', '../../echarts'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n    var axisBuilderAttrs = [\n            'axisLine',\n            'axisLabel',\n            'axisTick',\n            'axisName'\n        ];\n    var selfBuilderAttrs = [\n            'splitArea',\n            'splitLine'\n        ];\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n    var AxisView = require('../../echarts').extendComponentView({\n            type: 'axis',\n            render: function (axisModel, ecModel) {\n                this.group.removeAll();\n                var oldAxisGroup = this._axisGroup;\n                this._axisGroup = new graphic.Group();\n                this.group.add(this._axisGroup);\n                if (!axisModel.get('show')) {\n                    return;\n                }\n                var gridModel = axisModel.findGridModel();\n                var layout = layoutAxis(gridModel, axisModel);\n                var axisBuilder = new AxisBuilder(axisModel, layout);\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this._axisGroup.add(axisBuilder.getGroup());\n                zrUtil.each(selfBuilderAttrs, function (name) {\n                    if (axisModel.get(name + '.show')) {\n                        this['_' + name](axisModel, gridModel, layout.labelInterval);\n                    }\n                }, this);\n                graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n            },\n            _splitLine: function (axisModel, gridModel, labelInterval) {\n                var axis = axisModel.axis;\n                var splitLineModel = axisModel.getModel('splitLine');\n                var lineStyleModel = splitLineModel.getModel('lineStyle');\n                var lineColors = lineStyleModel.get('color');\n                var lineInterval = getInterval(splitLineModel, labelInterval);\n                lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n                var gridRect = gridModel.coordinateSystem.getRect();\n                var isHorizontal = axis.isHorizontal();\n                var lineCount = 0;\n                var ticksCoords = axis.getTicksCoords();\n                var ticks = axis.scale.getTicks();\n                var p1 = [];\n                var p2 = [];\n                // Simple optimization\n                // Batching the lines if color are the same\n                var lineStyle = lineStyleModel.getLineStyle();\n                for (var i = 0; i < ticksCoords.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                        continue;\n                    }\n                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n                    if (isHorizontal) {\n                        p1[0] = tickCoord;\n                        p1[1] = gridRect.y;\n                        p2[0] = tickCoord;\n                        p2[1] = gridRect.y + gridRect.height;\n                    } else {\n                        p1[0] = gridRect.x;\n                        p1[1] = tickCoord;\n                        p2[0] = gridRect.x + gridRect.width;\n                        p2[1] = tickCoord;\n                    }\n                    var colorIndex = lineCount++ % lineColors.length;\n                    this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                        anid: 'line_' + ticks[i],\n                        shape: {\n                            x1: p1[0],\n                            y1: p1[1],\n                            x2: p2[0],\n                            y2: p2[1]\n                        },\n                        style: zrUtil.defaults({ stroke: lineColors[colorIndex] }, lineStyle),\n                        silent: true\n                    })));\n                }\n            },\n            _splitArea: function (axisModel, gridModel, labelInterval) {\n                var axis = axisModel.axis;\n                var splitAreaModel = axisModel.getModel('splitArea');\n                var areaStyleModel = splitAreaModel.getModel('areaStyle');\n                var areaColors = areaStyleModel.get('color');\n                var gridRect = gridModel.coordinateSystem.getRect();\n                var ticksCoords = axis.getTicksCoords();\n                var ticks = axis.scale.getTicks();\n                var prevX = axis.toGlobalCoord(ticksCoords[0]);\n                var prevY = axis.toGlobalCoord(ticksCoords[0]);\n                var count = 0;\n                var areaInterval = getInterval(splitAreaModel, labelInterval);\n                var areaStyle = areaStyleModel.getAreaStyle();\n                areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n                for (var i = 1; i < ticksCoords.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                        continue;\n                    }\n                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n                    var x;\n                    var y;\n                    var width;\n                    var height;\n                    if (axis.isHorizontal()) {\n                        x = prevX;\n                        y = gridRect.y;\n                        width = tickCoord - x;\n                        height = gridRect.height;\n                    } else {\n                        x = gridRect.x;\n                        y = prevY;\n                        width = gridRect.width;\n                        height = tickCoord - y;\n                    }\n                    var colorIndex = count++ % areaColors.length;\n                    this._axisGroup.add(new graphic.Rect({\n                        anid: 'area_' + ticks[i],\n                        shape: {\n                            x: x,\n                            y: y,\n                            width: width,\n                            height: height\n                        },\n                        style: zrUtil.defaults({ fill: areaColors[colorIndex] }, areaStyle),\n                        silent: true\n                    }));\n                    prevX = x + width;\n                    prevY = y + height;\n                }\n            }\n        });\n    AxisView.extend({ type: 'xAxis' });\n    AxisView.extend({ type: 'yAxis' });\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [\n                rect.x,\n                rect.x + rect.width,\n                rect.y,\n                rect.y + rect.height\n            ];\n        var axisOffset = axisModel.get('offset') || 0;\n        var posMap = {\n                x: {\n                    top: rectBound[2] - axisOffset,\n                    bottom: rectBound[3] + axisOffset\n                },\n                y: {\n                    left: rectBound[0] - axisOffset,\n                    right: rectBound[1] + axisOffset\n                }\n            };\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n        // Tick and label direction, x y is axisDim\n        var dirMap = {\n                top: -1,\n                bottom: 1,\n                left: -1,\n                right: 1\n            };\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n        return layout;\n    }\n});\ndefine('echarts/chart/pie/labelLayout', ['require', 'zrender/contain/text'], function (require) {\n    'use strict';\n    var textContain = require('zrender/contain/text');\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n            shiftUp(end - 1, delta / 2);\n        }\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n                    break;\n                }\n            }\n        }\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;\n            // \n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            } else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            } else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                } else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n    return function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n            cx = layout.cx;\n            cy = layout.cy;\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            } else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n                    var y3 = y2;\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [\n                        [\n                            x1,\n                            y1\n                        ],\n                        [\n                            x2,\n                            y2\n                        ],\n                        [\n                            x3,\n                            y3\n                        ]\n                    ];\n                }\n                textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n            var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n            var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n});\ndefine('echarts/component/axis/AxisBuilder', ['require', 'zrender/core/util', '../../util/format', '../../util/graphic', '../../model/Model', '../../util/number', 'zrender/core/vector'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n    var PI = Math.PI;\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = { componentType: axisModel.mainType };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n        // Default value\n        zrUtil.defaults(opt, {\n            labelOffset: 0,\n            nameDirection: 1,\n            tickDirection: 1,\n            labelDirection: 1,\n            silent: true\n        });\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n                position: opt.position.slice(),\n                rotation: opt.rotation\n            });\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n        this._dumbGroup = dumbGroup;\n    };\n    AxisBuilder.prototype = {\n        constructor: AxisBuilder,\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n        add: function (name) {\n            builders[name].call(this);\n        },\n        getGroup: function () {\n            return this.group;\n        }\n    };\n    var builders = {\n            axisLine: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                if (!axisModel.get('axisLine.show')) {\n                    return;\n                }\n                var extent = this.axisModel.axis.getExtent();\n                var matrix = this._transform;\n                var pt1 = [\n                        extent[0],\n                        0\n                    ];\n                var pt2 = [\n                        extent[1],\n                        0\n                    ];\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line',\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.extend({ lineCap: 'round' }, axisModel.getModel('axisLine.lineStyle').getLineStyle()),\n                    strokeContainThreshold: opt.strokeContainThreshold || 5,\n                    silent: true,\n                    z2: 1\n                })));\n            },\n            axisTick: function () {\n                var axisModel = this.axisModel;\n                if (!axisModel.get('axisTick.show')) {\n                    return;\n                }\n                var axis = axisModel.axis;\n                var tickModel = axisModel.getModel('axisTick');\n                var opt = this.opt;\n                var lineStyleModel = tickModel.getModel('lineStyle');\n                var tickLen = tickModel.get('length');\n                var tickInterval = getInterval(tickModel, opt.labelInterval);\n                var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n                var ticks = axis.scale.getTicks();\n                var pt1 = [];\n                var pt2 = [];\n                var matrix = this._transform;\n                for (var i = 0; i < ticksCoords.length; i++) {\n                    // Only ordinal scale support tick interval\n                    if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                        continue;\n                    }\n                    var tickCoord = ticksCoords[i];\n                    pt1[0] = tickCoord;\n                    pt1[1] = 0;\n                    pt2[0] = tickCoord;\n                    pt2[1] = opt.tickDirection * tickLen;\n                    if (matrix) {\n                        v2ApplyTransform(pt1, pt1, matrix);\n                        v2ApplyTransform(pt2, pt2, matrix);\n                    }\n                    // Tick line, Not use group transform to have better line draw\n                    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                        anid: 'tick_' + ticks[i],\n                        shape: {\n                            x1: pt1[0],\n                            y1: pt1[1],\n                            x2: pt2[0],\n                            y2: pt2[1]\n                        },\n                        style: zrUtil.defaults(lineStyleModel.getLineStyle(), { stroke: axisModel.get('axisLine.lineStyle.color') }),\n                        z2: 2,\n                        silent: true\n                    })));\n                }\n            },\n            axisLabel: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n                if (!show) {\n                    return;\n                }\n                var axis = axisModel.axis;\n                var labelModel = axisModel.getModel('axisLabel');\n                var textStyleModel = labelModel.getModel('textStyle');\n                var labelMargin = labelModel.get('margin');\n                var ticks = axis.scale.getTicks();\n                var labels = axisModel.getFormattedLabels();\n                // Special label rotate.\n                var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n                // To radian.\n                labelRotation = labelRotation * PI / 180;\n                var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n                var categoryData = axisModel.get('data');\n                var textEls = [];\n                var silent = isSilent(axisModel);\n                var triggerEvent = axisModel.get('triggerEvent');\n                for (var i = 0; i < ticks.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n                        continue;\n                    }\n                    var itemTextStyleModel = textStyleModel;\n                    if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n                        itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);\n                    }\n                    var textColor = itemTextStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n                    var tickCoord = axis.dataToCoord(ticks[i]);\n                    var pos = [\n                            tickCoord,\n                            opt.labelOffset + opt.labelDirection * labelMargin\n                        ];\n                    var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n                    var textEl = new graphic.Text({\n                            anid: 'label_' + ticks[i],\n                            style: {\n                                text: labels[i],\n                                textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                                textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                                textFont: itemTextStyleModel.getFont(),\n                                fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                            },\n                            position: pos,\n                            rotation: labelLayout.rotation,\n                            silent: silent,\n                            z2: 10\n                        });\n                    // Pack data for mouse event\n                    if (triggerEvent) {\n                        textEl.eventData = makeAxisEventDataBase(axisModel);\n                        textEl.eventData.targetType = 'axisLabel';\n                        textEl.eventData.value = labelBeforeFormat;\n                    }\n                    // FIXME\n                    this._dumbGroup.add(textEl);\n                    textEl.updateTransform();\n                    textEls.push(textEl);\n                    this.group.add(textEl);\n                    textEl.decomposeTransform();\n                }\n                function isTwoLabelOverlapped(current, next) {\n                    var firstRect = current && current.getBoundingRect().clone();\n                    var nextRect = next && next.getBoundingRect().clone();\n                    if (firstRect && nextRect) {\n                        firstRect.applyTransform(current.getLocalTransform());\n                        nextRect.applyTransform(next.getLocalTransform());\n                        return firstRect.intersect(nextRect);\n                    }\n                }\n                if (axis.type !== 'category') {\n                    // If min or max are user set, we need to check\n                    // If the tick on min(max) are overlap on their neighbour tick\n                    // If they are overlapped, we need to hide the min(max) tick label\n                    if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n                        var firstLabel = textEls[0];\n                        var nextLabel = textEls[1];\n                        if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                            firstLabel.ignore = true;\n                        }\n                    }\n                    if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n                        var lastLabel = textEls[textEls.length - 1];\n                        var prevLabel = textEls[textEls.length - 2];\n                        if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                            lastLabel.ignore = true;\n                        }\n                    }\n                }\n            },\n            axisName: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                var name = retrieve(opt.axisName, axisModel.get('name'));\n                if (!name) {\n                    return;\n                }\n                var nameLocation = axisModel.get('nameLocation');\n                var nameDirection = opt.nameDirection;\n                var textStyleModel = axisModel.getModel('nameTextStyle');\n                var gap = axisModel.get('nameGap') || 0;\n                var extent = this.axisModel.axis.getExtent();\n                var gapSignal = extent[0] > extent[1] ? -1 : 1;\n                var pos = [\n                        nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n                        nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n                    ];\n                var labelLayout;\n                var nameRotation = axisModel.get('nameRotate');\n                if (nameRotation != null) {\n                    nameRotation = nameRotation * PI / 180;    // To radian.\n                }\n                var axisNameAvailableWidth;\n                if (nameLocation === 'middle') {\n                    labelLayout = innerTextLayout(opt, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n                } else {\n                    labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n                    axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                    if (axisNameAvailableWidth != null) {\n                        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n                        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                    }\n                }\n                var textFont = textStyleModel.getFont();\n                var truncateOpt = axisModel.get('nameTruncate', true) || {};\n                var ellipsis = truncateOpt.ellipsis;\n                var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n                var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n                        minChar: 2,\n                        placeholder: truncateOpt.placeholder\n                    }) : name;\n                var tooltipOpt = axisModel.get('tooltip', true);\n                var mainType = axisModel.mainType;\n                var formatterParams = {\n                        componentType: mainType,\n                        name: name,\n                        $vars: ['name']\n                    };\n                formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n                var textEl = new graphic.Text({\n                        anid: 'name',\n                        __fullText: name,\n                        __truncatedText: truncatedText,\n                        style: {\n                            text: truncatedText,\n                            textFont: textFont,\n                            fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n                            textAlign: labelLayout.textAlign,\n                            textVerticalAlign: labelLayout.verticalAlign\n                        },\n                        position: pos,\n                        rotation: labelLayout.rotation,\n                        silent: isSilent(axisModel),\n                        z2: 1,\n                        tooltip: tooltipOpt && tooltipOpt.show ? zrUtil.extend({\n                            content: name,\n                            formatter: function () {\n                                return name;\n                            },\n                            formatterParams: formatterParams\n                        }, tooltipOpt) : null\n                    });\n                if (axisModel.get('triggerEvent')) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisName';\n                    textEl.eventData.name = name;\n                }\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n                this.group.add(textEl);\n                textEl.decomposeTransform();\n            }\n        };\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        if (isRadianAroundZero(rotationDiff)) {\n            // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        } else if (isRadianAroundZero(rotationDiff - PI)) {\n            // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        } else {\n            verticalAlign = 'middle';\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            } else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        } else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            } else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n    }\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n            var rawTick;\n            var scale = axis.scale;\n            return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n        };\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n            var interval = model.get('interval');\n            if (interval == null || interval == 'auto') {\n                interval = labelInterval;\n            }\n            return interval;\n        };\n    return AxisBuilder;\n});\ndefine('zrender', ['zrender/zrender'], function (zrender) { return zrender;});\ndefine('echarts', ['echarts/echarts'], function (echarts) { return echarts;});\nvar echarts = require('echarts');\n\necharts.graphic = require('echarts/util/graphic');\necharts.number = require('echarts/util/number');\necharts.format = require('echarts/util/format');\n\n\nrequire('echarts/chart/bar');\n\nrequire('echarts/chart/pie');\n\n\nrequire('echarts/component/grid');\n\nrequire('echarts/component/title');\n\n\n\n\nreturn echarts;\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/echarts.js\n// module id = 47\n// module chunks = 2"],"sourceRoot":""}